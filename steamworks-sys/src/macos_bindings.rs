/* automatically generated by rust-bindgen 0.69.5 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const STEAMCLIENT_INTERFACE_VERSION: &[u8; 15] = b"SteamClient021\0";
pub const STEAMUSER_INTERFACE_VERSION: &[u8; 13] = b"SteamUser023\0";
pub const STEAMFRIENDS_INTERFACE_VERSION: &[u8; 16] = b"SteamFriends018\0";
pub const STEAMUTILS_INTERFACE_VERSION: &[u8; 14] = b"SteamUtils010\0";
pub const STEAMMATCHMAKING_INTERFACE_VERSION: &[u8; 20] = b"SteamMatchMaking009\0";
pub const STEAMMATCHMAKINGSERVERS_INTERFACE_VERSION: &[u8; 27] = b"SteamMatchMakingServers002\0";
pub const STEAMGAMESEARCH_INTERFACE_VERSION: &[u8; 24] = b"SteamMatchGameSearch001\0";
pub const STEAMPARTIES_INTERFACE_VERSION: &[u8; 16] = b"SteamParties002\0";
pub const STEAMREMOTESTORAGE_INTERFACE_VERSION: &[u8; 40] =
    b"STEAMREMOTESTORAGE_INTERFACE_VERSION016\0";
pub const STEAMUSERSTATS_INTERFACE_VERSION: &[u8; 36] = b"STEAMUSERSTATS_INTERFACE_VERSION013\0";
pub const STEAMAPPS_INTERFACE_VERSION: &[u8; 31] = b"STEAMAPPS_INTERFACE_VERSION008\0";
pub const STEAMNETWORKING_INTERFACE_VERSION: &[u8; 19] = b"SteamNetworking006\0";
pub const STEAMSCREENSHOTS_INTERFACE_VERSION: &[u8; 38] =
    b"STEAMSCREENSHOTS_INTERFACE_VERSION003\0";
pub const STEAMMUSIC_INTERFACE_VERSION: &[u8; 32] = b"STEAMMUSIC_INTERFACE_VERSION001\0";
pub const k_SteamMusicNameMaxLength: u32 = 255;
pub const k_SteamMusicPNGMaxLength: u32 = 65535;
pub const STEAMMUSICREMOTE_INTERFACE_VERSION: &[u8; 38] =
    b"STEAMMUSICREMOTE_INTERFACE_VERSION001\0";
pub const STEAMHTTP_INTERFACE_VERSION: &[u8; 31] = b"STEAMHTTP_INTERFACE_VERSION003\0";
pub const STEAM_INPUT_MAX_COUNT: u32 = 16;
pub const STEAM_INPUT_MAX_ANALOG_ACTIONS: u32 = 24;
pub const STEAM_INPUT_MAX_DIGITAL_ACTIONS: u32 = 256;
pub const STEAM_INPUT_MAX_ORIGINS: u32 = 8;
pub const STEAM_INPUT_MAX_ACTIVE_LAYERS: u32 = 16;
pub const STEAM_INPUT_MIN_ANALOG_ACTION_DATA: f64 = -1.0;
pub const STEAM_INPUT_MAX_ANALOG_ACTION_DATA: f64 = 1.0;
pub const STEAMINPUT_INTERFACE_VERSION: &[u8; 14] = b"SteamInput006\0";
pub const STEAM_CONTROLLER_MAX_COUNT: u32 = 16;
pub const STEAM_CONTROLLER_MAX_ANALOG_ACTIONS: u32 = 24;
pub const STEAM_CONTROLLER_MAX_DIGITAL_ACTIONS: u32 = 256;
pub const STEAM_CONTROLLER_MAX_ORIGINS: u32 = 8;
pub const STEAM_CONTROLLER_MAX_ACTIVE_LAYERS: u32 = 16;
pub const STEAM_CONTROLLER_MIN_ANALOG_ACTION_DATA: f64 = -1.0;
pub const STEAM_CONTROLLER_MAX_ANALOG_ACTION_DATA: f64 = 1.0;
pub const STEAMCONTROLLER_INTERFACE_VERSION: &[u8; 19] = b"SteamController008\0";
pub const STEAMUGC_INTERFACE_VERSION: &[u8; 30] = b"STEAMUGC_INTERFACE_VERSION021\0";
pub const STEAMHTMLSURFACE_INTERFACE_VERSION: &[u8; 39] =
    b"STEAMHTMLSURFACE_INTERFACE_VERSION_005\0";
pub const STEAMINVENTORY_INTERFACE_VERSION: &[u8; 30] = b"STEAMINVENTORY_INTERFACE_V003\0";
pub const STEAMTIMELINE_INTERFACE_VERSION: &[u8; 29] = b"STEAMTIMELINE_INTERFACE_V004\0";
pub const STEAMVIDEO_INTERFACE_VERSION: &[u8; 26] = b"STEAMVIDEO_INTERFACE_V007\0";
pub const STEAMPARENTALSETTINGS_INTERFACE_VERSION: &[u8; 43] =
    b"STEAMPARENTALSETTINGS_INTERFACE_VERSION001\0";
pub const STEAMREMOTEPLAY_INTERFACE_VERSION: &[u8; 37] = b"STEAMREMOTEPLAY_INTERFACE_VERSION003\0";
pub const STEAMNETWORKINGMESSAGES_INTERFACE_VERSION: &[u8; 27] = b"SteamNetworkingMessages002\0";
pub const STEAMNETWORKINGSOCKETS_INTERFACE_VERSION: &[u8; 26] = b"SteamNetworkingSockets012\0";
pub const STEAMNETWORKINGUTILS_INTERFACE_VERSION: &[u8; 24] = b"SteamNetworkingUtils004\0";
pub const STEAMGAMESERVER_INTERFACE_VERSION: &[u8; 19] = b"SteamGameServer015\0";
pub const STEAMGAMESERVERSTATS_INTERFACE_VERSION: &[u8; 24] = b"SteamGameServerStats001\0";
pub type uint8 = ::std::os::raw::c_uchar;
pub type int16 = ::std::os::raw::c_short;
pub type uint16 = ::std::os::raw::c_ushort;
pub type int32 = ::std::os::raw::c_int;
pub type uint32 = ::std::os::raw::c_uint;
pub type int64 = ::std::os::raw::c_longlong;
pub type uint64 = ::std::os::raw::c_ulonglong;
pub type AppId_t = uint32;
pub type DepotId_t = uint32;
pub type RTime32 = uint32;
pub type SteamAPICall_t = uint64;
pub type AccountID_t = uint32;
pub type PartyBeaconID_t = uint64;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamIPType {
    k_ESteamIPTypeIPv4 = 0,
    k_ESteamIPTypeIPv6 = 1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct SteamIPAddress_t {
    pub __bindgen_anon_1: SteamIPAddress_t__bindgen_ty_1,
    pub m_eType: ESteamIPType,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union SteamIPAddress_t__bindgen_ty_1 {
    pub m_unIPv4: uint32,
    pub m_rgubIPv6: [uint8; 16usize],
    pub m_ipv6Qword: [uint64; 2usize],
}
#[test]
fn bindgen_test_layout_SteamIPAddress_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<SteamIPAddress_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamIPAddress_t__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(SteamIPAddress_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamIPAddress_t__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamIPAddress_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unIPv4) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamIPAddress_t__bindgen_ty_1),
            "::",
            stringify!(m_unIPv4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgubIPv6) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamIPAddress_t__bindgen_ty_1),
            "::",
            stringify!(m_rgubIPv6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ipv6Qword) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamIPAddress_t__bindgen_ty_1),
            "::",
            stringify!(m_ipv6Qword)
        )
    );
}
#[test]
fn bindgen_test_layout_SteamIPAddress_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamIPAddress_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamIPAddress_t>(),
        20usize,
        concat!("Size of: ", stringify!(SteamIPAddress_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamIPAddress_t>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamIPAddress_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamIPAddress_t),
            "::",
            stringify!(m_eType)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EUniverse {
    k_EUniverseInvalid = 0,
    k_EUniversePublic = 1,
    k_EUniverseBeta = 2,
    k_EUniverseInternal = 3,
    k_EUniverseDev = 4,
    k_EUniverseMax = 5,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EResult {
    k_EResultNone = 0,
    k_EResultOK = 1,
    k_EResultFail = 2,
    k_EResultNoConnection = 3,
    k_EResultInvalidPassword = 5,
    k_EResultLoggedInElsewhere = 6,
    k_EResultInvalidProtocolVer = 7,
    k_EResultInvalidParam = 8,
    k_EResultFileNotFound = 9,
    k_EResultBusy = 10,
    k_EResultInvalidState = 11,
    k_EResultInvalidName = 12,
    k_EResultInvalidEmail = 13,
    k_EResultDuplicateName = 14,
    k_EResultAccessDenied = 15,
    k_EResultTimeout = 16,
    k_EResultBanned = 17,
    k_EResultAccountNotFound = 18,
    k_EResultInvalidSteamID = 19,
    k_EResultServiceUnavailable = 20,
    k_EResultNotLoggedOn = 21,
    k_EResultPending = 22,
    k_EResultEncryptionFailure = 23,
    k_EResultInsufficientPrivilege = 24,
    k_EResultLimitExceeded = 25,
    k_EResultRevoked = 26,
    k_EResultExpired = 27,
    k_EResultAlreadyRedeemed = 28,
    k_EResultDuplicateRequest = 29,
    k_EResultAlreadyOwned = 30,
    k_EResultIPNotFound = 31,
    k_EResultPersistFailed = 32,
    k_EResultLockingFailed = 33,
    k_EResultLogonSessionReplaced = 34,
    k_EResultConnectFailed = 35,
    k_EResultHandshakeFailed = 36,
    k_EResultIOFailure = 37,
    k_EResultRemoteDisconnect = 38,
    k_EResultShoppingCartNotFound = 39,
    k_EResultBlocked = 40,
    k_EResultIgnored = 41,
    k_EResultNoMatch = 42,
    k_EResultAccountDisabled = 43,
    k_EResultServiceReadOnly = 44,
    k_EResultAccountNotFeatured = 45,
    k_EResultAdministratorOK = 46,
    k_EResultContentVersion = 47,
    k_EResultTryAnotherCM = 48,
    k_EResultPasswordRequiredToKickSession = 49,
    k_EResultAlreadyLoggedInElsewhere = 50,
    k_EResultSuspended = 51,
    k_EResultCancelled = 52,
    k_EResultDataCorruption = 53,
    k_EResultDiskFull = 54,
    k_EResultRemoteCallFailed = 55,
    k_EResultPasswordUnset = 56,
    k_EResultExternalAccountUnlinked = 57,
    k_EResultPSNTicketInvalid = 58,
    k_EResultExternalAccountAlreadyLinked = 59,
    k_EResultRemoteFileConflict = 60,
    k_EResultIllegalPassword = 61,
    k_EResultSameAsPreviousValue = 62,
    k_EResultAccountLogonDenied = 63,
    k_EResultCannotUseOldPassword = 64,
    k_EResultInvalidLoginAuthCode = 65,
    k_EResultAccountLogonDeniedNoMail = 66,
    k_EResultHardwareNotCapableOfIPT = 67,
    k_EResultIPTInitError = 68,
    k_EResultParentalControlRestricted = 69,
    k_EResultFacebookQueryError = 70,
    k_EResultExpiredLoginAuthCode = 71,
    k_EResultIPLoginRestrictionFailed = 72,
    k_EResultAccountLockedDown = 73,
    k_EResultAccountLogonDeniedVerifiedEmailRequired = 74,
    k_EResultNoMatchingURL = 75,
    k_EResultBadResponse = 76,
    k_EResultRequirePasswordReEntry = 77,
    k_EResultValueOutOfRange = 78,
    k_EResultUnexpectedError = 79,
    k_EResultDisabled = 80,
    k_EResultInvalidCEGSubmission = 81,
    k_EResultRestrictedDevice = 82,
    k_EResultRegionLocked = 83,
    k_EResultRateLimitExceeded = 84,
    k_EResultAccountLoginDeniedNeedTwoFactor = 85,
    k_EResultItemDeleted = 86,
    k_EResultAccountLoginDeniedThrottle = 87,
    k_EResultTwoFactorCodeMismatch = 88,
    k_EResultTwoFactorActivationCodeMismatch = 89,
    k_EResultAccountAssociatedToMultiplePartners = 90,
    k_EResultNotModified = 91,
    k_EResultNoMobileDevice = 92,
    k_EResultTimeNotSynced = 93,
    k_EResultSmsCodeFailed = 94,
    k_EResultAccountLimitExceeded = 95,
    k_EResultAccountActivityLimitExceeded = 96,
    k_EResultPhoneActivityLimitExceeded = 97,
    k_EResultRefundToWallet = 98,
    k_EResultEmailSendFailure = 99,
    k_EResultNotSettled = 100,
    k_EResultNeedCaptcha = 101,
    k_EResultGSLTDenied = 102,
    k_EResultGSOwnerDenied = 103,
    k_EResultInvalidItemType = 104,
    k_EResultIPBanned = 105,
    k_EResultGSLTExpired = 106,
    k_EResultInsufficientFunds = 107,
    k_EResultTooManyPending = 108,
    k_EResultNoSiteLicensesFound = 109,
    k_EResultWGNetworkSendExceeded = 110,
    k_EResultAccountNotFriends = 111,
    k_EResultLimitedUserAccount = 112,
    k_EResultCantRemoveItem = 113,
    k_EResultAccountDeleted = 114,
    k_EResultExistingUserCancelledLicense = 115,
    k_EResultCommunityCooldown = 116,
    k_EResultNoLauncherSpecified = 117,
    k_EResultMustAgreeToSSA = 118,
    k_EResultLauncherMigrated = 119,
    k_EResultSteamRealmMismatch = 120,
    k_EResultInvalidSignature = 121,
    k_EResultParseFailure = 122,
    k_EResultNoVerifiedPhone = 123,
    k_EResultInsufficientBattery = 124,
    k_EResultChargerRequired = 125,
    k_EResultCachedCredentialInvalid = 126,
    K_EResultPhoneNumberIsVOIP = 127,
    k_EResultNotSupported = 128,
    k_EResultFamilySizeLimitExceeded = 129,
    k_EResultOfflineAppCacheInvalid = 130,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EVoiceResult {
    k_EVoiceResultOK = 0,
    k_EVoiceResultNotInitialized = 1,
    k_EVoiceResultNotRecording = 2,
    k_EVoiceResultNoData = 3,
    k_EVoiceResultBufferTooSmall = 4,
    k_EVoiceResultDataCorrupted = 5,
    k_EVoiceResultRestricted = 6,
    k_EVoiceResultUnsupportedCodec = 7,
    k_EVoiceResultReceiverOutOfDate = 8,
    k_EVoiceResultReceiverDidNotAnswer = 9,
}
pub type HAuthTicket = uint32;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EBeginAuthSessionResult {
    k_EBeginAuthSessionResultOK = 0,
    k_EBeginAuthSessionResultInvalidTicket = 1,
    k_EBeginAuthSessionResultDuplicateRequest = 2,
    k_EBeginAuthSessionResultInvalidVersion = 3,
    k_EBeginAuthSessionResultGameMismatch = 4,
    k_EBeginAuthSessionResultExpiredTicket = 5,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EUserHasLicenseForAppResult {
    k_EUserHasLicenseResultHasLicense = 0,
    k_EUserHasLicenseResultDoesNotHaveLicense = 1,
    k_EUserHasLicenseResultNoAuth = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EAccountType {
    k_EAccountTypeInvalid = 0,
    k_EAccountTypeIndividual = 1,
    k_EAccountTypeMultiseat = 2,
    k_EAccountTypeGameServer = 3,
    k_EAccountTypeAnonGameServer = 4,
    k_EAccountTypePending = 5,
    k_EAccountTypeContentServer = 6,
    k_EAccountTypeClan = 7,
    k_EAccountTypeChat = 8,
    k_EAccountTypeConsoleUser = 9,
    k_EAccountTypeAnonUser = 10,
    k_EAccountTypeMax = 11,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EChatEntryType {
    k_EChatEntryTypeInvalid = 0,
    k_EChatEntryTypeChatMsg = 1,
    k_EChatEntryTypeTyping = 2,
    k_EChatEntryTypeInviteGame = 3,
    k_EChatEntryTypeEmote = 4,
    k_EChatEntryTypeLeftConversation = 6,
    k_EChatEntryTypeEntered = 7,
    k_EChatEntryTypeWasKicked = 8,
    k_EChatEntryTypeWasBanned = 9,
    k_EChatEntryTypeDisconnected = 10,
    k_EChatEntryTypeHistoricalChat = 11,
    k_EChatEntryTypeLinkBlocked = 14,
}
pub const k_unSteamAccountIDMask: ::std::os::raw::c_uint = 4294967295;
pub const k_unSteamAccountInstanceMask: ::std::os::raw::c_uint = 1048575;
pub const k_unSteamUserDefaultInstance: ::std::os::raw::c_uint = 1;
impl EChatSteamIDInstanceFlags {
    pub const k_EChatAccountInstanceMask: EChatSteamIDInstanceFlags =
        EChatSteamIDInstanceFlags(4095);
}
impl EChatSteamIDInstanceFlags {
    pub const k_EChatInstanceFlagClan: EChatSteamIDInstanceFlags =
        EChatSteamIDInstanceFlags(524288);
}
impl EChatSteamIDInstanceFlags {
    pub const k_EChatInstanceFlagLobby: EChatSteamIDInstanceFlags =
        EChatSteamIDInstanceFlags(262144);
}
impl EChatSteamIDInstanceFlags {
    pub const k_EChatInstanceFlagMMSLobby: EChatSteamIDInstanceFlags =
        EChatSteamIDInstanceFlags(131072);
}
impl ::std::ops::BitOr<EChatSteamIDInstanceFlags> for EChatSteamIDInstanceFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        EChatSteamIDInstanceFlags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for EChatSteamIDInstanceFlags {
    #[inline]
    fn bitor_assign(&mut self, rhs: EChatSteamIDInstanceFlags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<EChatSteamIDInstanceFlags> for EChatSteamIDInstanceFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        EChatSteamIDInstanceFlags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for EChatSteamIDInstanceFlags {
    #[inline]
    fn bitand_assign(&mut self, rhs: EChatSteamIDInstanceFlags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct EChatSteamIDInstanceFlags(pub ::std::os::raw::c_uint);
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ENotificationPosition {
    k_EPositionInvalid = -1,
    k_EPositionTopLeft = 0,
    k_EPositionTopRight = 1,
    k_EPositionBottomLeft = 2,
    k_EPositionBottomRight = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EDurationControlOnlineState {
    k_EDurationControlOnlineState_Invalid = 0,
    k_EDurationControlOnlineState_Offline = 1,
    k_EDurationControlOnlineState_Online = 2,
    k_EDurationControlOnlineState_OnlineHighPri = 3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CSteamID {
    pub m_steamid: CSteamID_SteamID_t,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union CSteamID_SteamID_t {
    pub m_comp: CSteamID_SteamID_t_SteamIDComponent_t,
    pub m_unAll64Bits: uint64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CSteamID_SteamID_t_SteamIDComponent_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_CSteamID_SteamID_t_SteamIDComponent_t() {
    assert_eq!(
        ::std::mem::size_of::<CSteamID_SteamID_t_SteamIDComponent_t>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CSteamID_SteamID_t_SteamIDComponent_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CSteamID_SteamID_t_SteamIDComponent_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(CSteamID_SteamID_t_SteamIDComponent_t)
        )
    );
}
impl CSteamID_SteamID_t_SteamIDComponent_t {
    #[inline]
    pub fn m_unAccountID(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_m_unAccountID(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn m_unAccountInstance(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_m_unAccountInstance(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn m_EAccountType(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_m_EAccountType(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn m_EUniverse(&self) -> EUniverse {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_m_EUniverse(&mut self, val: EUniverse) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        m_unAccountID: uint32,
        m_unAccountInstance: ::std::os::raw::c_uint,
        m_EAccountType: ::std::os::raw::c_uint,
        m_EUniverse: EUniverse,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let m_unAccountID: u32 = unsafe { ::std::mem::transmute(m_unAccountID) };
            m_unAccountID as u64
        });
        __bindgen_bitfield_unit.set(32usize, 20u8, {
            let m_unAccountInstance: u32 = unsafe { ::std::mem::transmute(m_unAccountInstance) };
            m_unAccountInstance as u64
        });
        __bindgen_bitfield_unit.set(52usize, 4u8, {
            let m_EAccountType: u32 = unsafe { ::std::mem::transmute(m_EAccountType) };
            m_EAccountType as u64
        });
        __bindgen_bitfield_unit.set(56usize, 8u8, {
            let m_EUniverse: u32 = unsafe { ::std::mem::transmute(m_EUniverse) };
            m_EUniverse as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_CSteamID_SteamID_t() {
    const UNINIT: ::std::mem::MaybeUninit<CSteamID_SteamID_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CSteamID_SteamID_t>(),
        8usize,
        concat!("Size of: ", stringify!(CSteamID_SteamID_t))
    );
    assert_eq!(
        ::std::mem::align_of::<CSteamID_SteamID_t>(),
        1usize,
        concat!("Alignment of ", stringify!(CSteamID_SteamID_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_comp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamID_SteamID_t),
            "::",
            stringify!(m_comp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unAll64Bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamID_SteamID_t),
            "::",
            stringify!(m_unAll64Bits)
        )
    );
}
#[test]
fn bindgen_test_layout_CSteamID() {
    const UNINIT: ::std::mem::MaybeUninit<CSteamID> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CSteamID>(),
        8usize,
        concat!("Size of: ", stringify!(CSteamID))
    );
    assert_eq!(
        ::std::mem::align_of::<CSteamID>(),
        1usize,
        concat!("Alignment of ", stringify!(CSteamID))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamID),
            "::",
            stringify!(m_steamid)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK8CSteamID6RenderEv"]
    pub fn CSteamID_Render(this: *const CSteamID) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__ZN8CSteamID6RenderEy"]
    pub fn CSteamID_Render1(ulSteamID: uint64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__ZN8CSteamID13SetFromStringEPKc9EUniverse"]
    pub fn CSteamID_SetFromString(
        this: *mut CSteamID,
        pchSteamID: *const ::std::os::raw::c_char,
        eDefaultUniverse: EUniverse,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8CSteamID19SetFromStringStrictEPKc9EUniverse"]
    pub fn CSteamID_SetFromStringStrict(
        this: *mut CSteamID,
        pchSteamID: *const ::std::os::raw::c_char,
        eDefaultUniverse: EUniverse,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8CSteamID21BValidExternalSteamIDEv"]
    pub fn CSteamID_BValidExternalSteamID(this: *const CSteamID) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8CSteamIDC1EPKc9EUniverse"]
    pub fn CSteamID_CSteamID(
        this: *mut CSteamID,
        pchSteamID: *const ::std::os::raw::c_char,
        eDefaultUniverse: EUniverse,
    );
}
impl CSteamID {
    #[inline]
    pub unsafe fn Render(&self) -> *const ::std::os::raw::c_char {
        CSteamID_Render(self)
    }
    #[inline]
    pub unsafe fn Render1(ulSteamID: uint64) -> *const ::std::os::raw::c_char {
        CSteamID_Render1(ulSteamID)
    }
    #[inline]
    pub unsafe fn SetFromString(
        &mut self,
        pchSteamID: *const ::std::os::raw::c_char,
        eDefaultUniverse: EUniverse,
    ) {
        CSteamID_SetFromString(self, pchSteamID, eDefaultUniverse)
    }
    #[inline]
    pub unsafe fn SetFromStringStrict(
        &mut self,
        pchSteamID: *const ::std::os::raw::c_char,
        eDefaultUniverse: EUniverse,
    ) -> bool {
        CSteamID_SetFromStringStrict(self, pchSteamID, eDefaultUniverse)
    }
    #[inline]
    pub unsafe fn BValidExternalSteamID(&self) -> bool {
        CSteamID_BValidExternalSteamID(self)
    }
    #[inline]
    pub unsafe fn new(
        pchSteamID: *const ::std::os::raw::c_char,
        eDefaultUniverse: EUniverse,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        CSteamID_CSteamID(__bindgen_tmp.as_mut_ptr(), pchSteamID, eDefaultUniverse);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CGameID {
    pub __bindgen_anon_1: CGameID__bindgen_ty_1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CGameID_EGameIDType {
    k_EGameIDTypeApp = 0,
    k_EGameIDTypeGameMod = 1,
    k_EGameIDTypeShortcut = 2,
    k_EGameIDTypeP2P = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CGameID_GameID_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_CGameID_GameID_t() {
    assert_eq!(
        ::std::mem::size_of::<CGameID_GameID_t>(),
        8usize,
        concat!("Size of: ", stringify!(CGameID_GameID_t))
    );
    assert_eq!(
        ::std::mem::align_of::<CGameID_GameID_t>(),
        1usize,
        concat!("Alignment of ", stringify!(CGameID_GameID_t))
    );
}
impl CGameID_GameID_t {
    #[inline]
    pub fn m_nAppID(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_m_nAppID(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn m_nType(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_m_nType(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn m_nModID(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_m_nModID(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        m_nAppID: ::std::os::raw::c_uint,
        m_nType: ::std::os::raw::c_uint,
        m_nModID: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let m_nAppID: u32 = unsafe { ::std::mem::transmute(m_nAppID) };
            m_nAppID as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let m_nType: u32 = unsafe { ::std::mem::transmute(m_nType) };
            m_nType as u64
        });
        __bindgen_bitfield_unit.set(32usize, 32u8, {
            let m_nModID: u32 = unsafe { ::std::mem::transmute(m_nModID) };
            m_nModID as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union CGameID__bindgen_ty_1 {
    pub m_ulGameID: uint64,
    pub m_gameID: CGameID_GameID_t,
}
#[test]
fn bindgen_test_layout_CGameID__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<CGameID__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CGameID__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(CGameID__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<CGameID__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(CGameID__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulGameID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CGameID__bindgen_ty_1),
            "::",
            stringify!(m_ulGameID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_gameID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CGameID__bindgen_ty_1),
            "::",
            stringify!(m_gameID)
        )
    );
}
#[test]
fn bindgen_test_layout_CGameID() {
    assert_eq!(
        ::std::mem::size_of::<CGameID>(),
        8usize,
        concat!("Size of: ", stringify!(CGameID))
    );
    assert_eq!(
        ::std::mem::align_of::<CGameID>(),
        1usize,
        concat!("Alignment of ", stringify!(CGameID))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK7CGameID6RenderEv"]
    pub fn CGameID_Render(this: *const CGameID) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__ZN7CGameID6RenderEy"]
    pub fn CGameID_Render1(ulGameID: uint64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__ZN7CGameIDC1EPKc"]
    pub fn CGameID_CGameID(this: *mut CGameID, pchGameID: *const ::std::os::raw::c_char);
}
impl CGameID {
    #[inline]
    pub unsafe fn Render(&self) -> *const ::std::os::raw::c_char {
        CGameID_Render(self)
    }
    #[inline]
    pub unsafe fn Render1(ulGameID: uint64) -> *const ::std::os::raw::c_char {
        CGameID_Render1(ulGameID)
    }
    #[inline]
    pub unsafe fn new(pchGameID: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        CGameID_CGameID(__bindgen_tmp.as_mut_ptr(), pchGameID);
        __bindgen_tmp.assume_init()
    }
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EGameSearchErrorCode_t {
    k_EGameSearchErrorCode_OK = 1,
    k_EGameSearchErrorCode_Failed_Search_Already_In_Progress = 2,
    k_EGameSearchErrorCode_Failed_No_Search_In_Progress = 3,
    k_EGameSearchErrorCode_Failed_Not_Lobby_Leader = 4,
    k_EGameSearchErrorCode_Failed_No_Host_Available = 5,
    k_EGameSearchErrorCode_Failed_Search_Params_Invalid = 6,
    k_EGameSearchErrorCode_Failed_Offline = 7,
    k_EGameSearchErrorCode_Failed_NotAuthorized = 8,
    k_EGameSearchErrorCode_Failed_Unknown_Error = 9,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EPlayerResult_t {
    k_EPlayerResultFailedToConnect = 1,
    k_EPlayerResultAbandoned = 2,
    k_EPlayerResultKicked = 3,
    k_EPlayerResultIncomplete = 4,
    k_EPlayerResultCompleted = 5,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamIPv6ConnectivityProtocol {
    k_ESteamIPv6ConnectivityProtocol_Invalid = 0,
    k_ESteamIPv6ConnectivityProtocol_HTTP = 1,
    k_ESteamIPv6ConnectivityProtocol_UDP = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamIPv6ConnectivityState {
    k_ESteamIPv6ConnectivityState_Unknown = 0,
    k_ESteamIPv6ConnectivityState_Good = 1,
    k_ESteamIPv6ConnectivityState_Bad = 2,
}
pub type HSteamPipe = int32;
pub type HSteamUser = int32;
pub const k_cchMaxSteamErrMsg: ::std::os::raw::c_int = 1024;
pub type SteamErrMsg = [::std::os::raw::c_char; 1024usize];
pub type SteamAPIWarningMessageHook_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char),
>;
pub type SteamAPI_CheckCallbackRegistered_t =
    ::std::option::Option<unsafe extern "C" fn(iCallbackNum: ::std::os::raw::c_int) -> uint32>;
extern "C" {
    pub fn SteamAPI_RunCallbacks();
}
extern "C" {
    pub fn SteamGameServer_RunCallbacks();
}
#[repr(C)]
pub struct CCallbackBase__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CCallbackBase {
    pub vtable_: *const CCallbackBase__bindgen_vtable,
    pub m_nCallbackFlags: uint8,
    pub m_iCallback: ::std::os::raw::c_int,
}
pub const CCallbackBase_k_ECallbackFlagsRegistered: CCallbackBase__bindgen_ty_1 =
    CCallbackBase__bindgen_ty_1::k_ECallbackFlagsRegistered;
pub const CCallbackBase_k_ECallbackFlagsGameServer: CCallbackBase__bindgen_ty_1 =
    CCallbackBase__bindgen_ty_1::k_ECallbackFlagsGameServer;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CCallbackBase__bindgen_ty_1 {
    k_ECallbackFlagsRegistered = 1,
    k_ECallbackFlagsGameServer = 2,
}
#[test]
fn bindgen_test_layout_CCallbackBase() {
    const UNINIT: ::std::mem::MaybeUninit<CCallbackBase> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CCallbackBase>(),
        16usize,
        concat!("Size of: ", stringify!(CCallbackBase))
    );
    assert_eq!(
        ::std::mem::align_of::<CCallbackBase>(),
        8usize,
        concat!("Alignment of ", stringify!(CCallbackBase))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nCallbackFlags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CCallbackBase),
            "::",
            stringify!(m_nCallbackFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_iCallback) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CCallbackBase),
            "::",
            stringify!(m_iCallback)
        )
    );
}
extern "C" {
    pub fn SteamAPI_GetHSteamPipe() -> HSteamPipe;
}
extern "C" {
    pub fn SteamAPI_GetHSteamUser() -> HSteamUser;
}
extern "C" {
    pub fn SteamGameServer_GetHSteamPipe() -> HSteamPipe;
}
extern "C" {
    pub fn SteamGameServer_GetHSteamUser() -> HSteamUser;
}
extern "C" {
    pub fn SteamInternal_ContextInit(
        pContextInitData: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SteamInternal_CreateInterface(
        ver: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SteamInternal_FindOrCreateUserInterface(
        hSteamUser: HSteamUser,
        pszVersion: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SteamInternal_FindOrCreateGameServerInterface(
        hSteamUser: HSteamUser,
        pszVersion: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SteamAPI_RegisterCallback(
        pCallback: *mut CCallbackBase,
        iCallback: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_UnregisterCallback(pCallback: *mut CCallbackBase);
}
extern "C" {
    pub fn SteamAPI_RegisterCallResult(pCallback: *mut CCallbackBase, hAPICall: SteamAPICall_t);
}
extern "C" {
    pub fn SteamAPI_UnregisterCallResult(pCallback: *mut CCallbackBase, hAPICall: SteamAPICall_t);
}
#[doc = " Internal structure used in manual callback dispatch"]
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct CallbackMsg_t {
    pub m_hSteamUser: HSteamUser,
    pub m_iCallback: ::std::os::raw::c_int,
    pub m_pubParam: *mut uint8,
    pub m_cubParam: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CallbackMsg_t() {
    const UNINIT: ::std::mem::MaybeUninit<CallbackMsg_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CallbackMsg_t>(),
        20usize,
        concat!("Size of: ", stringify!(CallbackMsg_t))
    );
    assert_eq!(
        ::std::mem::align_of::<CallbackMsg_t>(),
        4usize,
        concat!("Alignment of ", stringify!(CallbackMsg_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hSteamUser) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CallbackMsg_t),
            "::",
            stringify!(m_hSteamUser)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_iCallback) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CallbackMsg_t),
            "::",
            stringify!(m_iCallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pubParam) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CallbackMsg_t),
            "::",
            stringify!(m_pubParam)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cubParam) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CallbackMsg_t),
            "::",
            stringify!(m_cubParam)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamContentServer {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct ISteamClient__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamClient {
    pub vtable_: *const ISteamClient__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamClient() {
    assert_eq!(
        ::std::mem::size_of::<ISteamClient>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamClient))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamClient>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamClient))
    );
}
#[repr(C)]
pub struct ISteamUser__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamUser {
    pub vtable_: *const ISteamUser__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamUser() {
    assert_eq!(
        ::std::mem::size_of::<ISteamUser>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamUser))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamUser>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamUser))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamServersConnected_t {
    pub _address: u8,
}
pub const SteamServersConnected_t_k_iCallback: SteamServersConnected_t__bindgen_ty_1 =
    SteamServersConnected_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamServersConnected_t__bindgen_ty_1 {
    k_iCallback = 101,
}
#[test]
fn bindgen_test_layout_SteamServersConnected_t() {
    assert_eq!(
        ::std::mem::size_of::<SteamServersConnected_t>(),
        1usize,
        concat!("Size of: ", stringify!(SteamServersConnected_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamServersConnected_t>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamServersConnected_t))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamServerConnectFailure_t {
    pub m_eResult: EResult,
    pub m_bStillRetrying: bool,
}
pub const SteamServerConnectFailure_t_k_iCallback: SteamServerConnectFailure_t__bindgen_ty_1 =
    SteamServerConnectFailure_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamServerConnectFailure_t__bindgen_ty_1 {
    k_iCallback = 102,
}
#[test]
fn bindgen_test_layout_SteamServerConnectFailure_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamServerConnectFailure_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamServerConnectFailure_t>(),
        8usize,
        concat!("Size of: ", stringify!(SteamServerConnectFailure_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamServerConnectFailure_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamServerConnectFailure_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamServerConnectFailure_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bStillRetrying) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamServerConnectFailure_t),
            "::",
            stringify!(m_bStillRetrying)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamServersDisconnected_t {
    pub m_eResult: EResult,
}
pub const SteamServersDisconnected_t_k_iCallback: SteamServersDisconnected_t__bindgen_ty_1 =
    SteamServersDisconnected_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamServersDisconnected_t__bindgen_ty_1 {
    k_iCallback = 103,
}
#[test]
fn bindgen_test_layout_SteamServersDisconnected_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamServersDisconnected_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamServersDisconnected_t>(),
        4usize,
        concat!("Size of: ", stringify!(SteamServersDisconnected_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamServersDisconnected_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamServersDisconnected_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamServersDisconnected_t),
            "::",
            stringify!(m_eResult)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EFriendRelationship {
    k_EFriendRelationshipNone = 0,
    k_EFriendRelationshipBlocked = 1,
    k_EFriendRelationshipRequestRecipient = 2,
    k_EFriendRelationshipFriend = 3,
    k_EFriendRelationshipRequestInitiator = 4,
    k_EFriendRelationshipIgnored = 5,
    k_EFriendRelationshipIgnoredFriend = 6,
    k_EFriendRelationshipSuggested_DEPRECATED = 7,
    k_EFriendRelationshipMax = 8,
}
pub type FriendsGroupID_t = int16;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EPersonaState {
    k_EPersonaStateOffline = 0,
    k_EPersonaStateOnline = 1,
    k_EPersonaStateBusy = 2,
    k_EPersonaStateAway = 3,
    k_EPersonaStateSnooze = 4,
    k_EPersonaStateLookingToTrade = 5,
    k_EPersonaStateLookingToPlay = 6,
    k_EPersonaStateInvisible = 7,
    k_EPersonaStateMax = 8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FriendGameInfo_t {
    pub m_gameID: CGameID,
    pub m_unGameIP: uint32,
    pub m_usGamePort: uint16,
    pub m_usQueryPort: uint16,
    pub m_steamIDLobby: CSteamID,
}
#[test]
fn bindgen_test_layout_FriendGameInfo_t() {
    const UNINIT: ::std::mem::MaybeUninit<FriendGameInfo_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FriendGameInfo_t>(),
        24usize,
        concat!("Size of: ", stringify!(FriendGameInfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<FriendGameInfo_t>(),
        4usize,
        concat!("Alignment of ", stringify!(FriendGameInfo_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_gameID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendGameInfo_t),
            "::",
            stringify!(m_gameID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unGameIP) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendGameInfo_t),
            "::",
            stringify!(m_unGameIP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_usGamePort) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendGameInfo_t),
            "::",
            stringify!(m_usGamePort)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_usQueryPort) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendGameInfo_t),
            "::",
            stringify!(m_usQueryPort)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDLobby) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendGameInfo_t),
            "::",
            stringify!(m_steamIDLobby)
        )
    );
}
impl EOverlayToStoreFlag {
    pub const k_EOverlayToStoreFlag_None: EOverlayToStoreFlag = EOverlayToStoreFlag(0);
}
impl EOverlayToStoreFlag {
    pub const k_EOverlayToStoreFlag_AddToCart: EOverlayToStoreFlag = EOverlayToStoreFlag(1);
}
impl EOverlayToStoreFlag {
    pub const k_EOverlayToStoreFlag_AddToCartAndShow: EOverlayToStoreFlag = EOverlayToStoreFlag(2);
}
impl ::std::ops::BitOr<EOverlayToStoreFlag> for EOverlayToStoreFlag {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        EOverlayToStoreFlag(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for EOverlayToStoreFlag {
    #[inline]
    fn bitor_assign(&mut self, rhs: EOverlayToStoreFlag) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<EOverlayToStoreFlag> for EOverlayToStoreFlag {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        EOverlayToStoreFlag(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for EOverlayToStoreFlag {
    #[inline]
    fn bitand_assign(&mut self, rhs: EOverlayToStoreFlag) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct EOverlayToStoreFlag(pub ::std::os::raw::c_uint);
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EActivateGameOverlayToWebPageMode {
    k_EActivateGameOverlayToWebPageMode_Default = 0,
    k_EActivateGameOverlayToWebPageMode_Modal = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ECommunityProfileItemType {
    k_ECommunityProfileItemType_AnimatedAvatar = 0,
    k_ECommunityProfileItemType_AvatarFrame = 1,
    k_ECommunityProfileItemType_ProfileModifier = 2,
    k_ECommunityProfileItemType_ProfileBackground = 3,
    k_ECommunityProfileItemType_MiniProfileBackground = 4,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ECommunityProfileItemProperty {
    k_ECommunityProfileItemProperty_ImageSmall = 0,
    k_ECommunityProfileItemProperty_ImageLarge = 1,
    k_ECommunityProfileItemProperty_InternalName = 2,
    k_ECommunityProfileItemProperty_Title = 3,
    k_ECommunityProfileItemProperty_Description = 4,
    k_ECommunityProfileItemProperty_AppID = 5,
    k_ECommunityProfileItemProperty_TypeID = 6,
    k_ECommunityProfileItemProperty_Class = 7,
    k_ECommunityProfileItemProperty_MovieWebM = 8,
    k_ECommunityProfileItemProperty_MovieMP4 = 9,
    k_ECommunityProfileItemProperty_MovieWebMSmall = 10,
    k_ECommunityProfileItemProperty_MovieMP4Small = 11,
}
#[repr(C)]
pub struct ISteamFriends__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamFriends {
    pub vtable_: *const ISteamFriends__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamFriends() {
    assert_eq!(
        ::std::mem::size_of::<ISteamFriends>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamFriends))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamFriends>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamFriends))
    );
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamAPICallFailure {
    k_ESteamAPICallFailureNone = -1,
    k_ESteamAPICallFailureSteamGone = 0,
    k_ESteamAPICallFailureNetworkFailure = 1,
    k_ESteamAPICallFailureInvalidHandle = 2,
    k_ESteamAPICallFailureMismatchedCallback = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EGamepadTextInputMode {
    k_EGamepadTextInputModeNormal = 0,
    k_EGamepadTextInputModePassword = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EGamepadTextInputLineMode {
    k_EGamepadTextInputLineModeSingleLine = 0,
    k_EGamepadTextInputLineModeMultipleLines = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EFloatingGamepadTextInputMode {
    k_EFloatingGamepadTextInputModeModeSingleLine = 0,
    k_EFloatingGamepadTextInputModeModeMultipleLines = 1,
    k_EFloatingGamepadTextInputModeModeEmail = 2,
    k_EFloatingGamepadTextInputModeModeNumeric = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ETextFilteringContext {
    k_ETextFilteringContextUnknown = 0,
    k_ETextFilteringContextGameContent = 1,
    k_ETextFilteringContextChat = 2,
    k_ETextFilteringContextName = 3,
}
#[repr(C)]
pub struct ISteamUtils__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamUtils {
    pub vtable_: *const ISteamUtils__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamUtils() {
    assert_eq!(
        ::std::mem::size_of::<ISteamUtils>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamUtils))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamUtils>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamUtils))
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct SteamAPICallCompleted_t {
    pub m_hAsyncCall: SteamAPICall_t,
    pub m_iCallback: ::std::os::raw::c_int,
    pub m_cubParam: uint32,
}
pub const SteamAPICallCompleted_t_k_iCallback: SteamAPICallCompleted_t__bindgen_ty_1 =
    SteamAPICallCompleted_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamAPICallCompleted_t__bindgen_ty_1 {
    k_iCallback = 703,
}
#[test]
fn bindgen_test_layout_SteamAPICallCompleted_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamAPICallCompleted_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamAPICallCompleted_t>(),
        16usize,
        concat!("Size of: ", stringify!(SteamAPICallCompleted_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamAPICallCompleted_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamAPICallCompleted_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hAsyncCall) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamAPICallCompleted_t),
            "::",
            stringify!(m_hAsyncCall)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_iCallback) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamAPICallCompleted_t),
            "::",
            stringify!(m_iCallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cubParam) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamAPICallCompleted_t),
            "::",
            stringify!(m_cubParam)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamShutdown_t {
    pub _address: u8,
}
pub const SteamShutdown_t_k_iCallback: SteamShutdown_t__bindgen_ty_1 =
    SteamShutdown_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamShutdown_t__bindgen_ty_1 {
    k_iCallback = 704,
}
#[test]
fn bindgen_test_layout_SteamShutdown_t() {
    assert_eq!(
        ::std::mem::size_of::<SteamShutdown_t>(),
        1usize,
        concat!("Size of: ", stringify!(SteamShutdown_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamShutdown_t>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamShutdown_t))
    );
}
#[doc = " Store key/value pair used in matchmaking queries.\n\n Actually, the name Key/Value is a bit misleading.  The \"key\" is better\n understood as \"filter operation code\" and the \"value\" is the operand to this\n filter operation.  The meaning of the operand depends upon the filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MatchMakingKeyValuePair_t {
    pub m_szKey: [::std::os::raw::c_char; 256usize],
    pub m_szValue: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_MatchMakingKeyValuePair_t() {
    const UNINIT: ::std::mem::MaybeUninit<MatchMakingKeyValuePair_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MatchMakingKeyValuePair_t>(),
        512usize,
        concat!("Size of: ", stringify!(MatchMakingKeyValuePair_t))
    );
    assert_eq!(
        ::std::mem::align_of::<MatchMakingKeyValuePair_t>(),
        1usize,
        concat!("Alignment of ", stringify!(MatchMakingKeyValuePair_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MatchMakingKeyValuePair_t),
            "::",
            stringify!(m_szKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szValue) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(MatchMakingKeyValuePair_t),
            "::",
            stringify!(m_szValue)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EMatchMakingServerResponse {
    eServerResponded = 0,
    eServerFailedToRespond = 1,
    eNoServersListedOnMasterServer = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct servernetadr_t {
    pub m_usConnectionPort: uint16,
    pub m_usQueryPort: uint16,
    pub m_unIP: uint32,
}
#[test]
fn bindgen_test_layout_servernetadr_t() {
    const UNINIT: ::std::mem::MaybeUninit<servernetadr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<servernetadr_t>(),
        8usize,
        concat!("Size of: ", stringify!(servernetadr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<servernetadr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(servernetadr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_usConnectionPort) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(servernetadr_t),
            "::",
            stringify!(m_usConnectionPort)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_usQueryPort) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(servernetadr_t),
            "::",
            stringify!(m_usQueryPort)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unIP) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(servernetadr_t),
            "::",
            stringify!(m_unIP)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gameserveritem_t {
    #[doc = "< IP/Query Port/Connection Port for this server"]
    pub m_NetAdr: servernetadr_t,
    #[doc = "< current ping time in milliseconds"]
    pub m_nPing: ::std::os::raw::c_int,
    #[doc = "< server has responded successfully in the past"]
    pub m_bHadSuccessfulResponse: bool,
    #[doc = "< server is marked as not responding and should no longer be refreshed"]
    pub m_bDoNotRefresh: bool,
    #[doc = "< current game directory"]
    pub m_szGameDir: [::std::os::raw::c_char; 32usize],
    #[doc = "< current map"]
    pub m_szMap: [::std::os::raw::c_char; 32usize],
    #[doc = "< game description"]
    pub m_szGameDescription: [::std::os::raw::c_char; 64usize],
    #[doc = "< Steam App ID of this server"]
    pub m_nAppID: uint32,
    #[doc = "< total number of players currently on the server.  INCLUDES BOTS!!"]
    pub m_nPlayers: ::std::os::raw::c_int,
    #[doc = "< Maximum players that can join this server"]
    pub m_nMaxPlayers: ::std::os::raw::c_int,
    #[doc = "< Number of bots (i.e simulated players) on this server"]
    pub m_nBotPlayers: ::std::os::raw::c_int,
    #[doc = "< true if this server needs a password to join"]
    pub m_bPassword: bool,
    #[doc = "< Is this server protected by VAC"]
    pub m_bSecure: bool,
    #[doc = "< time (in unix time) when this server was last played on (for favorite/history servers)"]
    pub m_ulTimeLastPlayed: uint32,
    #[doc = "< server version as reported to Steam"]
    pub m_nServerVersion: ::std::os::raw::c_int,
    #[doc = " Game server name"]
    pub m_szServerName: [::std::os::raw::c_char; 64usize],
    #[doc = " the tags this server exposes"]
    pub m_szGameTags: [::std::os::raw::c_char; 128usize],
    #[doc = " steamID of the game server - invalid if it's doesn't have one (old server, or not connected to Steam)"]
    pub m_steamID: CSteamID,
}
#[test]
fn bindgen_test_layout_gameserveritem_t() {
    const UNINIT: ::std::mem::MaybeUninit<gameserveritem_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gameserveritem_t>(),
        372usize,
        concat!("Size of: ", stringify!(gameserveritem_t))
    );
    assert_eq!(
        ::std::mem::align_of::<gameserveritem_t>(),
        4usize,
        concat!("Alignment of ", stringify!(gameserveritem_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_NetAdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_NetAdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPing) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_nPing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bHadSuccessfulResponse) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_bHadSuccessfulResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bDoNotRefresh) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_bDoNotRefresh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szGameDir) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_szGameDir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szMap) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_szMap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szGameDescription) as usize - ptr as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_szGameDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nAppID) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_nAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPlayers) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_nPlayers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nMaxPlayers) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_nMaxPlayers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nBotPlayers) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_nBotPlayers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bPassword) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_bPassword)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bSecure) as usize - ptr as usize },
        161usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_bSecure)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulTimeLastPlayed) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_ulTimeLastPlayed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nServerVersion) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_nServerVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szServerName) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_szServerName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szGameTags) as usize - ptr as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_szGameTags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamID) as usize - ptr as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_steamID)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ELobbyType {
    k_ELobbyTypePrivate = 0,
    k_ELobbyTypeFriendsOnly = 1,
    k_ELobbyTypePublic = 2,
    k_ELobbyTypeInvisible = 3,
    k_ELobbyTypePrivateUnique = 4,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ELobbyComparison {
    k_ELobbyComparisonEqualToOrLessThan = -2,
    k_ELobbyComparisonLessThan = -1,
    k_ELobbyComparisonEqual = 0,
    k_ELobbyComparisonGreaterThan = 1,
    k_ELobbyComparisonEqualToOrGreaterThan = 2,
    k_ELobbyComparisonNotEqual = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ELobbyDistanceFilter {
    k_ELobbyDistanceFilterClose = 0,
    k_ELobbyDistanceFilterDefault = 1,
    k_ELobbyDistanceFilterFar = 2,
    k_ELobbyDistanceFilterWorldwide = 3,
}
#[repr(C)]
pub struct ISteamMatchmaking__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamMatchmaking {
    pub vtable_: *const ISteamMatchmaking__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamMatchmaking() {
    assert_eq!(
        ::std::mem::size_of::<ISteamMatchmaking>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamMatchmaking))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamMatchmaking>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamMatchmaking))
    );
}
pub type HServerListRequest = *mut ::std::os::raw::c_void;
#[repr(C)]
pub struct ISteamMatchmakingServerListResponse__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamMatchmakingServerListResponse {
    pub vtable_: *const ISteamMatchmakingServerListResponse__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamMatchmakingServerListResponse() {
    assert_eq!(
        ::std::mem::size_of::<ISteamMatchmakingServerListResponse>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamMatchmakingServerListResponse))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamMatchmakingServerListResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ISteamMatchmakingServerListResponse)
        )
    );
}
#[repr(C)]
pub struct ISteamMatchmakingPingResponse__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamMatchmakingPingResponse {
    pub vtable_: *const ISteamMatchmakingPingResponse__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamMatchmakingPingResponse() {
    assert_eq!(
        ::std::mem::size_of::<ISteamMatchmakingPingResponse>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamMatchmakingPingResponse))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamMatchmakingPingResponse>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamMatchmakingPingResponse))
    );
}
#[repr(C)]
pub struct ISteamMatchmakingPlayersResponse__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamMatchmakingPlayersResponse {
    pub vtable_: *const ISteamMatchmakingPlayersResponse__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamMatchmakingPlayersResponse() {
    assert_eq!(
        ::std::mem::size_of::<ISteamMatchmakingPlayersResponse>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamMatchmakingPlayersResponse))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamMatchmakingPlayersResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ISteamMatchmakingPlayersResponse)
        )
    );
}
#[repr(C)]
pub struct ISteamMatchmakingRulesResponse__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamMatchmakingRulesResponse {
    pub vtable_: *const ISteamMatchmakingRulesResponse__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamMatchmakingRulesResponse() {
    assert_eq!(
        ::std::mem::size_of::<ISteamMatchmakingRulesResponse>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamMatchmakingRulesResponse))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamMatchmakingRulesResponse>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamMatchmakingRulesResponse))
    );
}
pub type HServerQuery = ::std::os::raw::c_int;
#[repr(C)]
pub struct ISteamMatchmakingServers__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamMatchmakingServers {
    pub vtable_: *const ISteamMatchmakingServers__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamMatchmakingServers() {
    assert_eq!(
        ::std::mem::size_of::<ISteamMatchmakingServers>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamMatchmakingServers))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamMatchmakingServers>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamMatchmakingServers))
    );
}
#[repr(C)]
pub struct ISteamGameSearch__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamGameSearch {
    pub vtable_: *const ISteamGameSearch__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamGameSearch() {
    assert_eq!(
        ::std::mem::size_of::<ISteamGameSearch>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamGameSearch))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamGameSearch>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamGameSearch))
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamPartyBeaconLocationType {
    k_ESteamPartyBeaconLocationType_Invalid = 0,
    k_ESteamPartyBeaconLocationType_ChatGroup = 1,
    k_ESteamPartyBeaconLocationType_Max = 2,
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct SteamPartyBeaconLocation_t {
    pub m_eType: ESteamPartyBeaconLocationType,
    pub m_ulLocationID: uint64,
}
#[test]
fn bindgen_test_layout_SteamPartyBeaconLocation_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamPartyBeaconLocation_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamPartyBeaconLocation_t>(),
        12usize,
        concat!("Size of: ", stringify!(SteamPartyBeaconLocation_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamPartyBeaconLocation_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamPartyBeaconLocation_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamPartyBeaconLocation_t),
            "::",
            stringify!(m_eType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulLocationID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamPartyBeaconLocation_t),
            "::",
            stringify!(m_ulLocationID)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamPartyBeaconLocationData {
    k_ESteamPartyBeaconLocationDataInvalid = 0,
    k_ESteamPartyBeaconLocationDataName = 1,
    k_ESteamPartyBeaconLocationDataIconURLSmall = 2,
    k_ESteamPartyBeaconLocationDataIconURLMedium = 3,
    k_ESteamPartyBeaconLocationDataIconURLLarge = 4,
}
#[repr(C)]
pub struct ISteamParties__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamParties {
    pub vtable_: *const ISteamParties__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamParties() {
    assert_eq!(
        ::std::mem::size_of::<ISteamParties>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamParties))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamParties>(),
        4usize,
        concat!("Alignment of ", stringify!(ISteamParties))
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct SteamParamStringArray_t {
    pub m_ppStrings: *mut *const ::std::os::raw::c_char,
    pub m_nNumStrings: int32,
}
#[test]
fn bindgen_test_layout_SteamParamStringArray_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamParamStringArray_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamParamStringArray_t>(),
        12usize,
        concat!("Size of: ", stringify!(SteamParamStringArray_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamParamStringArray_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamParamStringArray_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ppStrings) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamParamStringArray_t),
            "::",
            stringify!(m_ppStrings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nNumStrings) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamParamStringArray_t),
            "::",
            stringify!(m_nNumStrings)
        )
    );
}
pub type UGCHandle_t = uint64;
pub type PublishedFileUpdateHandle_t = uint64;
pub type PublishedFileId_t = uint64;
pub type UGCFileWriteStreamHandle_t = uint64;
impl ERemoteStoragePlatform {
    pub const k_ERemoteStoragePlatformNone: ERemoteStoragePlatform = ERemoteStoragePlatform(0);
}
impl ERemoteStoragePlatform {
    pub const k_ERemoteStoragePlatformWindows: ERemoteStoragePlatform = ERemoteStoragePlatform(1);
}
impl ERemoteStoragePlatform {
    pub const k_ERemoteStoragePlatformOSX: ERemoteStoragePlatform = ERemoteStoragePlatform(2);
}
impl ERemoteStoragePlatform {
    pub const k_ERemoteStoragePlatformPS3: ERemoteStoragePlatform = ERemoteStoragePlatform(4);
}
impl ERemoteStoragePlatform {
    pub const k_ERemoteStoragePlatformLinux: ERemoteStoragePlatform = ERemoteStoragePlatform(8);
}
impl ERemoteStoragePlatform {
    pub const k_ERemoteStoragePlatformSwitch: ERemoteStoragePlatform = ERemoteStoragePlatform(16);
}
impl ERemoteStoragePlatform {
    pub const k_ERemoteStoragePlatformAndroid: ERemoteStoragePlatform = ERemoteStoragePlatform(32);
}
impl ERemoteStoragePlatform {
    pub const k_ERemoteStoragePlatformIOS: ERemoteStoragePlatform = ERemoteStoragePlatform(64);
}
impl ERemoteStoragePlatform {
    pub const k_ERemoteStoragePlatformAll: ERemoteStoragePlatform =
        ERemoteStoragePlatform(4294967295);
}
impl ::std::ops::BitOr<ERemoteStoragePlatform> for ERemoteStoragePlatform {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ERemoteStoragePlatform(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ERemoteStoragePlatform {
    #[inline]
    fn bitor_assign(&mut self, rhs: ERemoteStoragePlatform) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ERemoteStoragePlatform> for ERemoteStoragePlatform {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ERemoteStoragePlatform(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ERemoteStoragePlatform {
    #[inline]
    fn bitand_assign(&mut self, rhs: ERemoteStoragePlatform) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ERemoteStoragePlatform(pub ::std::os::raw::c_uint);
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ERemoteStoragePublishedFileVisibility {
    k_ERemoteStoragePublishedFileVisibilityPublic = 0,
    k_ERemoteStoragePublishedFileVisibilityFriendsOnly = 1,
    k_ERemoteStoragePublishedFileVisibilityPrivate = 2,
    k_ERemoteStoragePublishedFileVisibilityUnlisted = 3,
}
impl EWorkshopFileType {
    pub const k_EWorkshopFileTypeCommunity: EWorkshopFileType =
        EWorkshopFileType::k_EWorkshopFileTypeFirst;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EWorkshopFileType {
    k_EWorkshopFileTypeFirst = 0,
    k_EWorkshopFileTypeMicrotransaction = 1,
    k_EWorkshopFileTypeCollection = 2,
    k_EWorkshopFileTypeArt = 3,
    k_EWorkshopFileTypeVideo = 4,
    k_EWorkshopFileTypeScreenshot = 5,
    k_EWorkshopFileTypeGame = 6,
    k_EWorkshopFileTypeSoftware = 7,
    k_EWorkshopFileTypeConcept = 8,
    k_EWorkshopFileTypeWebGuide = 9,
    k_EWorkshopFileTypeIntegratedGuide = 10,
    k_EWorkshopFileTypeMerch = 11,
    k_EWorkshopFileTypeControllerBinding = 12,
    k_EWorkshopFileTypeSteamworksAccessInvite = 13,
    k_EWorkshopFileTypeSteamVideo = 14,
    k_EWorkshopFileTypeGameManagedItem = 15,
    k_EWorkshopFileTypeClip = 16,
    k_EWorkshopFileTypeMax = 17,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EWorkshopFileAction {
    k_EWorkshopFileActionPlayed = 0,
    k_EWorkshopFileActionCompleted = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EWorkshopEnumerationType {
    k_EWorkshopEnumerationTypeRankedByVote = 0,
    k_EWorkshopEnumerationTypeRecent = 1,
    k_EWorkshopEnumerationTypeTrending = 2,
    k_EWorkshopEnumerationTypeFavoritesOfFriends = 3,
    k_EWorkshopEnumerationTypeVotedByFriends = 4,
    k_EWorkshopEnumerationTypeContentByFriends = 5,
    k_EWorkshopEnumerationTypeRecentFromFollowedUsers = 6,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EWorkshopVideoProvider {
    k_EWorkshopVideoProviderNone = 0,
    k_EWorkshopVideoProviderYoutube = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EUGCReadAction {
    k_EUGCRead_ContinueReadingUntilFinished = 0,
    k_EUGCRead_ContinueReading = 1,
    k_EUGCRead_Close = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ERemoteStorageLocalFileChange {
    k_ERemoteStorageLocalFileChange_Invalid = 0,
    k_ERemoteStorageLocalFileChange_FileUpdated = 1,
    k_ERemoteStorageLocalFileChange_FileDeleted = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ERemoteStorageFilePathType {
    k_ERemoteStorageFilePathType_Invalid = 0,
    k_ERemoteStorageFilePathType_Absolute = 1,
    k_ERemoteStorageFilePathType_APIFilename = 2,
}
#[repr(C)]
pub struct ISteamRemoteStorage__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamRemoteStorage {
    pub vtable_: *const ISteamRemoteStorage__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamRemoteStorage() {
    assert_eq!(
        ::std::mem::size_of::<ISteamRemoteStorage>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamRemoteStorage))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamRemoteStorage>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamRemoteStorage))
    );
}
pub type SteamLeaderboard_t = uint64;
pub type SteamLeaderboardEntries_t = uint64;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ELeaderboardDataRequest {
    k_ELeaderboardDataRequestGlobal = 0,
    k_ELeaderboardDataRequestGlobalAroundUser = 1,
    k_ELeaderboardDataRequestFriends = 2,
    k_ELeaderboardDataRequestUsers = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ELeaderboardSortMethod {
    k_ELeaderboardSortMethodNone = 0,
    k_ELeaderboardSortMethodAscending = 1,
    k_ELeaderboardSortMethodDescending = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ELeaderboardDisplayType {
    k_ELeaderboardDisplayTypeNone = 0,
    k_ELeaderboardDisplayTypeNumeric = 1,
    k_ELeaderboardDisplayTypeTimeSeconds = 2,
    k_ELeaderboardDisplayTypeTimeMilliSeconds = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ELeaderboardUploadScoreMethod {
    k_ELeaderboardUploadScoreMethodNone = 0,
    k_ELeaderboardUploadScoreMethodKeepBest = 1,
    k_ELeaderboardUploadScoreMethodForceUpdate = 2,
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct LeaderboardEntry_t {
    pub m_steamIDUser: CSteamID,
    pub m_nGlobalRank: int32,
    pub m_nScore: int32,
    pub m_cDetails: int32,
    pub m_hUGC: UGCHandle_t,
}
#[test]
fn bindgen_test_layout_LeaderboardEntry_t() {
    const UNINIT: ::std::mem::MaybeUninit<LeaderboardEntry_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LeaderboardEntry_t>(),
        28usize,
        concat!("Size of: ", stringify!(LeaderboardEntry_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LeaderboardEntry_t>(),
        4usize,
        concat!("Alignment of ", stringify!(LeaderboardEntry_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDUser) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardEntry_t),
            "::",
            stringify!(m_steamIDUser)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nGlobalRank) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardEntry_t),
            "::",
            stringify!(m_nGlobalRank)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nScore) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardEntry_t),
            "::",
            stringify!(m_nScore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cDetails) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardEntry_t),
            "::",
            stringify!(m_cDetails)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hUGC) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardEntry_t),
            "::",
            stringify!(m_hUGC)
        )
    );
}
#[repr(C)]
pub struct ISteamUserStats__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamUserStats {
    pub vtable_: *const ISteamUserStats__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamUserStats() {
    assert_eq!(
        ::std::mem::size_of::<ISteamUserStats>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamUserStats))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamUserStats>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamUserStats))
    );
}
#[repr(C)]
pub struct ISteamApps__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamApps {
    pub vtable_: *const ISteamApps__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamApps() {
    assert_eq!(
        ::std::mem::size_of::<ISteamApps>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamApps))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamApps>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamApps))
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EP2PSend {
    k_EP2PSendUnreliable = 0,
    k_EP2PSendUnreliableNoDelay = 1,
    k_EP2PSendReliable = 2,
    k_EP2PSendReliableWithBuffering = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct P2PSessionState_t {
    pub m_bConnectionActive: uint8,
    pub m_bConnecting: uint8,
    pub m_eP2PSessionError: uint8,
    pub m_bUsingRelay: uint8,
    pub m_nBytesQueuedForSend: int32,
    pub m_nPacketsQueuedForSend: int32,
    pub m_nRemoteIP: uint32,
    pub m_nRemotePort: uint16,
}
#[test]
fn bindgen_test_layout_P2PSessionState_t() {
    const UNINIT: ::std::mem::MaybeUninit<P2PSessionState_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<P2PSessionState_t>(),
        20usize,
        concat!("Size of: ", stringify!(P2PSessionState_t))
    );
    assert_eq!(
        ::std::mem::align_of::<P2PSessionState_t>(),
        4usize,
        concat!("Alignment of ", stringify!(P2PSessionState_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bConnectionActive) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(P2PSessionState_t),
            "::",
            stringify!(m_bConnectionActive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bConnecting) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(P2PSessionState_t),
            "::",
            stringify!(m_bConnecting)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eP2PSessionError) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(P2PSessionState_t),
            "::",
            stringify!(m_eP2PSessionError)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bUsingRelay) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(P2PSessionState_t),
            "::",
            stringify!(m_bUsingRelay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nBytesQueuedForSend) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(P2PSessionState_t),
            "::",
            stringify!(m_nBytesQueuedForSend)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPacketsQueuedForSend) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(P2PSessionState_t),
            "::",
            stringify!(m_nPacketsQueuedForSend)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nRemoteIP) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(P2PSessionState_t),
            "::",
            stringify!(m_nRemoteIP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nRemotePort) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(P2PSessionState_t),
            "::",
            stringify!(m_nRemotePort)
        )
    );
}
pub type SNetSocket_t = uint32;
pub type SNetListenSocket_t = uint32;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESNetSocketConnectionType {
    k_ESNetSocketConnectionTypeNotConnected = 0,
    k_ESNetSocketConnectionTypeUDP = 1,
    k_ESNetSocketConnectionTypeUDPRelay = 2,
}
#[repr(C)]
pub struct ISteamNetworking__bindgen_vtable(::std::os::raw::c_void);
#[doc = "      the Steamworks SDK.  Please see ISteamNetworkingSockets and\n      ISteamNetworkingMessages"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamNetworking {
    pub vtable_: *const ISteamNetworking__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamNetworking() {
    assert_eq!(
        ::std::mem::size_of::<ISteamNetworking>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamNetworking))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamNetworking>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamNetworking))
    );
}
pub type ScreenshotHandle = uint32;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EVRScreenshotType {
    k_EVRScreenshotType_None = 0,
    k_EVRScreenshotType_Mono = 1,
    k_EVRScreenshotType_Stereo = 2,
    k_EVRScreenshotType_MonoCubemap = 3,
    k_EVRScreenshotType_MonoPanorama = 4,
    k_EVRScreenshotType_StereoPanorama = 5,
}
#[repr(C)]
pub struct ISteamScreenshots__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamScreenshots {
    pub vtable_: *const ISteamScreenshots__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamScreenshots() {
    assert_eq!(
        ::std::mem::size_of::<ISteamScreenshots>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamScreenshots))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamScreenshots>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamScreenshots))
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AudioPlayback_Status {
    AudioPlayback_Undefined = 0,
    AudioPlayback_Playing = 1,
    AudioPlayback_Paused = 2,
    AudioPlayback_Idle = 3,
}
#[repr(C)]
pub struct ISteamMusic__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamMusic {
    pub vtable_: *const ISteamMusic__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamMusic() {
    assert_eq!(
        ::std::mem::size_of::<ISteamMusic>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamMusic))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamMusic>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamMusic))
    );
}
#[repr(C)]
pub struct ISteamMusicRemote__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamMusicRemote {
    pub vtable_: *const ISteamMusicRemote__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamMusicRemote() {
    assert_eq!(
        ::std::mem::size_of::<ISteamMusicRemote>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamMusicRemote))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamMusicRemote>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamMusicRemote))
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EHTTPMethod {
    k_EHTTPMethodInvalid = 0,
    k_EHTTPMethodGET = 1,
    k_EHTTPMethodHEAD = 2,
    k_EHTTPMethodPOST = 3,
    k_EHTTPMethodPUT = 4,
    k_EHTTPMethodDELETE = 5,
    k_EHTTPMethodOPTIONS = 6,
    k_EHTTPMethodPATCH = 7,
}
pub type HTTPRequestHandle = uint32;
pub type HTTPCookieContainerHandle = uint32;
#[repr(C)]
pub struct ISteamHTTP__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamHTTP {
    pub vtable_: *const ISteamHTTP__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamHTTP() {
    assert_eq!(
        ::std::mem::size_of::<ISteamHTTP>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamHTTP))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamHTTP>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamHTTP))
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EInputSourceMode {
    k_EInputSourceMode_None = 0,
    k_EInputSourceMode_Dpad = 1,
    k_EInputSourceMode_Buttons = 2,
    k_EInputSourceMode_FourButtons = 3,
    k_EInputSourceMode_AbsoluteMouse = 4,
    k_EInputSourceMode_RelativeMouse = 5,
    k_EInputSourceMode_JoystickMove = 6,
    k_EInputSourceMode_JoystickMouse = 7,
    k_EInputSourceMode_JoystickCamera = 8,
    k_EInputSourceMode_ScrollWheel = 9,
    k_EInputSourceMode_Trigger = 10,
    k_EInputSourceMode_TouchMenu = 11,
    k_EInputSourceMode_MouseJoystick = 12,
    k_EInputSourceMode_MouseRegion = 13,
    k_EInputSourceMode_RadialMenu = 14,
    k_EInputSourceMode_SingleButton = 15,
    k_EInputSourceMode_Switches = 16,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EInputActionOrigin {
    k_EInputActionOrigin_None = 0,
    k_EInputActionOrigin_SteamController_A = 1,
    k_EInputActionOrigin_SteamController_B = 2,
    k_EInputActionOrigin_SteamController_X = 3,
    k_EInputActionOrigin_SteamController_Y = 4,
    k_EInputActionOrigin_SteamController_LeftBumper = 5,
    k_EInputActionOrigin_SteamController_RightBumper = 6,
    k_EInputActionOrigin_SteamController_LeftGrip = 7,
    k_EInputActionOrigin_SteamController_RightGrip = 8,
    k_EInputActionOrigin_SteamController_Start = 9,
    k_EInputActionOrigin_SteamController_Back = 10,
    k_EInputActionOrigin_SteamController_LeftPad_Touch = 11,
    k_EInputActionOrigin_SteamController_LeftPad_Swipe = 12,
    k_EInputActionOrigin_SteamController_LeftPad_Click = 13,
    k_EInputActionOrigin_SteamController_LeftPad_DPadNorth = 14,
    k_EInputActionOrigin_SteamController_LeftPad_DPadSouth = 15,
    k_EInputActionOrigin_SteamController_LeftPad_DPadWest = 16,
    k_EInputActionOrigin_SteamController_LeftPad_DPadEast = 17,
    k_EInputActionOrigin_SteamController_RightPad_Touch = 18,
    k_EInputActionOrigin_SteamController_RightPad_Swipe = 19,
    k_EInputActionOrigin_SteamController_RightPad_Click = 20,
    k_EInputActionOrigin_SteamController_RightPad_DPadNorth = 21,
    k_EInputActionOrigin_SteamController_RightPad_DPadSouth = 22,
    k_EInputActionOrigin_SteamController_RightPad_DPadWest = 23,
    k_EInputActionOrigin_SteamController_RightPad_DPadEast = 24,
    k_EInputActionOrigin_SteamController_LeftTrigger_Pull = 25,
    k_EInputActionOrigin_SteamController_LeftTrigger_Click = 26,
    k_EInputActionOrigin_SteamController_RightTrigger_Pull = 27,
    k_EInputActionOrigin_SteamController_RightTrigger_Click = 28,
    k_EInputActionOrigin_SteamController_LeftStick_Move = 29,
    k_EInputActionOrigin_SteamController_LeftStick_Click = 30,
    k_EInputActionOrigin_SteamController_LeftStick_DPadNorth = 31,
    k_EInputActionOrigin_SteamController_LeftStick_DPadSouth = 32,
    k_EInputActionOrigin_SteamController_LeftStick_DPadWest = 33,
    k_EInputActionOrigin_SteamController_LeftStick_DPadEast = 34,
    k_EInputActionOrigin_SteamController_Gyro_Move = 35,
    k_EInputActionOrigin_SteamController_Gyro_Pitch = 36,
    k_EInputActionOrigin_SteamController_Gyro_Yaw = 37,
    k_EInputActionOrigin_SteamController_Gyro_Roll = 38,
    k_EInputActionOrigin_SteamController_Reserved0 = 39,
    k_EInputActionOrigin_SteamController_Reserved1 = 40,
    k_EInputActionOrigin_SteamController_Reserved2 = 41,
    k_EInputActionOrigin_SteamController_Reserved3 = 42,
    k_EInputActionOrigin_SteamController_Reserved4 = 43,
    k_EInputActionOrigin_SteamController_Reserved5 = 44,
    k_EInputActionOrigin_SteamController_Reserved6 = 45,
    k_EInputActionOrigin_SteamController_Reserved7 = 46,
    k_EInputActionOrigin_SteamController_Reserved8 = 47,
    k_EInputActionOrigin_SteamController_Reserved9 = 48,
    k_EInputActionOrigin_SteamController_Reserved10 = 49,
    k_EInputActionOrigin_PS4_X = 50,
    k_EInputActionOrigin_PS4_Circle = 51,
    k_EInputActionOrigin_PS4_Triangle = 52,
    k_EInputActionOrigin_PS4_Square = 53,
    k_EInputActionOrigin_PS4_LeftBumper = 54,
    k_EInputActionOrigin_PS4_RightBumper = 55,
    k_EInputActionOrigin_PS4_Options = 56,
    k_EInputActionOrigin_PS4_Share = 57,
    k_EInputActionOrigin_PS4_LeftPad_Touch = 58,
    k_EInputActionOrigin_PS4_LeftPad_Swipe = 59,
    k_EInputActionOrigin_PS4_LeftPad_Click = 60,
    k_EInputActionOrigin_PS4_LeftPad_DPadNorth = 61,
    k_EInputActionOrigin_PS4_LeftPad_DPadSouth = 62,
    k_EInputActionOrigin_PS4_LeftPad_DPadWest = 63,
    k_EInputActionOrigin_PS4_LeftPad_DPadEast = 64,
    k_EInputActionOrigin_PS4_RightPad_Touch = 65,
    k_EInputActionOrigin_PS4_RightPad_Swipe = 66,
    k_EInputActionOrigin_PS4_RightPad_Click = 67,
    k_EInputActionOrigin_PS4_RightPad_DPadNorth = 68,
    k_EInputActionOrigin_PS4_RightPad_DPadSouth = 69,
    k_EInputActionOrigin_PS4_RightPad_DPadWest = 70,
    k_EInputActionOrigin_PS4_RightPad_DPadEast = 71,
    k_EInputActionOrigin_PS4_CenterPad_Touch = 72,
    k_EInputActionOrigin_PS4_CenterPad_Swipe = 73,
    k_EInputActionOrigin_PS4_CenterPad_Click = 74,
    k_EInputActionOrigin_PS4_CenterPad_DPadNorth = 75,
    k_EInputActionOrigin_PS4_CenterPad_DPadSouth = 76,
    k_EInputActionOrigin_PS4_CenterPad_DPadWest = 77,
    k_EInputActionOrigin_PS4_CenterPad_DPadEast = 78,
    k_EInputActionOrigin_PS4_LeftTrigger_Pull = 79,
    k_EInputActionOrigin_PS4_LeftTrigger_Click = 80,
    k_EInputActionOrigin_PS4_RightTrigger_Pull = 81,
    k_EInputActionOrigin_PS4_RightTrigger_Click = 82,
    k_EInputActionOrigin_PS4_LeftStick_Move = 83,
    k_EInputActionOrigin_PS4_LeftStick_Click = 84,
    k_EInputActionOrigin_PS4_LeftStick_DPadNorth = 85,
    k_EInputActionOrigin_PS4_LeftStick_DPadSouth = 86,
    k_EInputActionOrigin_PS4_LeftStick_DPadWest = 87,
    k_EInputActionOrigin_PS4_LeftStick_DPadEast = 88,
    k_EInputActionOrigin_PS4_RightStick_Move = 89,
    k_EInputActionOrigin_PS4_RightStick_Click = 90,
    k_EInputActionOrigin_PS4_RightStick_DPadNorth = 91,
    k_EInputActionOrigin_PS4_RightStick_DPadSouth = 92,
    k_EInputActionOrigin_PS4_RightStick_DPadWest = 93,
    k_EInputActionOrigin_PS4_RightStick_DPadEast = 94,
    k_EInputActionOrigin_PS4_DPad_North = 95,
    k_EInputActionOrigin_PS4_DPad_South = 96,
    k_EInputActionOrigin_PS4_DPad_West = 97,
    k_EInputActionOrigin_PS4_DPad_East = 98,
    k_EInputActionOrigin_PS4_Gyro_Move = 99,
    k_EInputActionOrigin_PS4_Gyro_Pitch = 100,
    k_EInputActionOrigin_PS4_Gyro_Yaw = 101,
    k_EInputActionOrigin_PS4_Gyro_Roll = 102,
    k_EInputActionOrigin_PS4_DPad_Move = 103,
    k_EInputActionOrigin_PS4_Reserved1 = 104,
    k_EInputActionOrigin_PS4_Reserved2 = 105,
    k_EInputActionOrigin_PS4_Reserved3 = 106,
    k_EInputActionOrigin_PS4_Reserved4 = 107,
    k_EInputActionOrigin_PS4_Reserved5 = 108,
    k_EInputActionOrigin_PS4_Reserved6 = 109,
    k_EInputActionOrigin_PS4_Reserved7 = 110,
    k_EInputActionOrigin_PS4_Reserved8 = 111,
    k_EInputActionOrigin_PS4_Reserved9 = 112,
    k_EInputActionOrigin_PS4_Reserved10 = 113,
    k_EInputActionOrigin_XBoxOne_A = 114,
    k_EInputActionOrigin_XBoxOne_B = 115,
    k_EInputActionOrigin_XBoxOne_X = 116,
    k_EInputActionOrigin_XBoxOne_Y = 117,
    k_EInputActionOrigin_XBoxOne_LeftBumper = 118,
    k_EInputActionOrigin_XBoxOne_RightBumper = 119,
    k_EInputActionOrigin_XBoxOne_Menu = 120,
    k_EInputActionOrigin_XBoxOne_View = 121,
    k_EInputActionOrigin_XBoxOne_LeftTrigger_Pull = 122,
    k_EInputActionOrigin_XBoxOne_LeftTrigger_Click = 123,
    k_EInputActionOrigin_XBoxOne_RightTrigger_Pull = 124,
    k_EInputActionOrigin_XBoxOne_RightTrigger_Click = 125,
    k_EInputActionOrigin_XBoxOne_LeftStick_Move = 126,
    k_EInputActionOrigin_XBoxOne_LeftStick_Click = 127,
    k_EInputActionOrigin_XBoxOne_LeftStick_DPadNorth = 128,
    k_EInputActionOrigin_XBoxOne_LeftStick_DPadSouth = 129,
    k_EInputActionOrigin_XBoxOne_LeftStick_DPadWest = 130,
    k_EInputActionOrigin_XBoxOne_LeftStick_DPadEast = 131,
    k_EInputActionOrigin_XBoxOne_RightStick_Move = 132,
    k_EInputActionOrigin_XBoxOne_RightStick_Click = 133,
    k_EInputActionOrigin_XBoxOne_RightStick_DPadNorth = 134,
    k_EInputActionOrigin_XBoxOne_RightStick_DPadSouth = 135,
    k_EInputActionOrigin_XBoxOne_RightStick_DPadWest = 136,
    k_EInputActionOrigin_XBoxOne_RightStick_DPadEast = 137,
    k_EInputActionOrigin_XBoxOne_DPad_North = 138,
    k_EInputActionOrigin_XBoxOne_DPad_South = 139,
    k_EInputActionOrigin_XBoxOne_DPad_West = 140,
    k_EInputActionOrigin_XBoxOne_DPad_East = 141,
    k_EInputActionOrigin_XBoxOne_DPad_Move = 142,
    k_EInputActionOrigin_XBoxOne_LeftGrip_Lower = 143,
    k_EInputActionOrigin_XBoxOne_LeftGrip_Upper = 144,
    k_EInputActionOrigin_XBoxOne_RightGrip_Lower = 145,
    k_EInputActionOrigin_XBoxOne_RightGrip_Upper = 146,
    k_EInputActionOrigin_XBoxOne_Share = 147,
    k_EInputActionOrigin_XBoxOne_Reserved6 = 148,
    k_EInputActionOrigin_XBoxOne_Reserved7 = 149,
    k_EInputActionOrigin_XBoxOne_Reserved8 = 150,
    k_EInputActionOrigin_XBoxOne_Reserved9 = 151,
    k_EInputActionOrigin_XBoxOne_Reserved10 = 152,
    k_EInputActionOrigin_XBox360_A = 153,
    k_EInputActionOrigin_XBox360_B = 154,
    k_EInputActionOrigin_XBox360_X = 155,
    k_EInputActionOrigin_XBox360_Y = 156,
    k_EInputActionOrigin_XBox360_LeftBumper = 157,
    k_EInputActionOrigin_XBox360_RightBumper = 158,
    k_EInputActionOrigin_XBox360_Start = 159,
    k_EInputActionOrigin_XBox360_Back = 160,
    k_EInputActionOrigin_XBox360_LeftTrigger_Pull = 161,
    k_EInputActionOrigin_XBox360_LeftTrigger_Click = 162,
    k_EInputActionOrigin_XBox360_RightTrigger_Pull = 163,
    k_EInputActionOrigin_XBox360_RightTrigger_Click = 164,
    k_EInputActionOrigin_XBox360_LeftStick_Move = 165,
    k_EInputActionOrigin_XBox360_LeftStick_Click = 166,
    k_EInputActionOrigin_XBox360_LeftStick_DPadNorth = 167,
    k_EInputActionOrigin_XBox360_LeftStick_DPadSouth = 168,
    k_EInputActionOrigin_XBox360_LeftStick_DPadWest = 169,
    k_EInputActionOrigin_XBox360_LeftStick_DPadEast = 170,
    k_EInputActionOrigin_XBox360_RightStick_Move = 171,
    k_EInputActionOrigin_XBox360_RightStick_Click = 172,
    k_EInputActionOrigin_XBox360_RightStick_DPadNorth = 173,
    k_EInputActionOrigin_XBox360_RightStick_DPadSouth = 174,
    k_EInputActionOrigin_XBox360_RightStick_DPadWest = 175,
    k_EInputActionOrigin_XBox360_RightStick_DPadEast = 176,
    k_EInputActionOrigin_XBox360_DPad_North = 177,
    k_EInputActionOrigin_XBox360_DPad_South = 178,
    k_EInputActionOrigin_XBox360_DPad_West = 179,
    k_EInputActionOrigin_XBox360_DPad_East = 180,
    k_EInputActionOrigin_XBox360_DPad_Move = 181,
    k_EInputActionOrigin_XBox360_Reserved1 = 182,
    k_EInputActionOrigin_XBox360_Reserved2 = 183,
    k_EInputActionOrigin_XBox360_Reserved3 = 184,
    k_EInputActionOrigin_XBox360_Reserved4 = 185,
    k_EInputActionOrigin_XBox360_Reserved5 = 186,
    k_EInputActionOrigin_XBox360_Reserved6 = 187,
    k_EInputActionOrigin_XBox360_Reserved7 = 188,
    k_EInputActionOrigin_XBox360_Reserved8 = 189,
    k_EInputActionOrigin_XBox360_Reserved9 = 190,
    k_EInputActionOrigin_XBox360_Reserved10 = 191,
    k_EInputActionOrigin_Switch_A = 192,
    k_EInputActionOrigin_Switch_B = 193,
    k_EInputActionOrigin_Switch_X = 194,
    k_EInputActionOrigin_Switch_Y = 195,
    k_EInputActionOrigin_Switch_LeftBumper = 196,
    k_EInputActionOrigin_Switch_RightBumper = 197,
    k_EInputActionOrigin_Switch_Plus = 198,
    k_EInputActionOrigin_Switch_Minus = 199,
    k_EInputActionOrigin_Switch_Capture = 200,
    k_EInputActionOrigin_Switch_LeftTrigger_Pull = 201,
    k_EInputActionOrigin_Switch_LeftTrigger_Click = 202,
    k_EInputActionOrigin_Switch_RightTrigger_Pull = 203,
    k_EInputActionOrigin_Switch_RightTrigger_Click = 204,
    k_EInputActionOrigin_Switch_LeftStick_Move = 205,
    k_EInputActionOrigin_Switch_LeftStick_Click = 206,
    k_EInputActionOrigin_Switch_LeftStick_DPadNorth = 207,
    k_EInputActionOrigin_Switch_LeftStick_DPadSouth = 208,
    k_EInputActionOrigin_Switch_LeftStick_DPadWest = 209,
    k_EInputActionOrigin_Switch_LeftStick_DPadEast = 210,
    k_EInputActionOrigin_Switch_RightStick_Move = 211,
    k_EInputActionOrigin_Switch_RightStick_Click = 212,
    k_EInputActionOrigin_Switch_RightStick_DPadNorth = 213,
    k_EInputActionOrigin_Switch_RightStick_DPadSouth = 214,
    k_EInputActionOrigin_Switch_RightStick_DPadWest = 215,
    k_EInputActionOrigin_Switch_RightStick_DPadEast = 216,
    k_EInputActionOrigin_Switch_DPad_North = 217,
    k_EInputActionOrigin_Switch_DPad_South = 218,
    k_EInputActionOrigin_Switch_DPad_West = 219,
    k_EInputActionOrigin_Switch_DPad_East = 220,
    k_EInputActionOrigin_Switch_ProGyro_Move = 221,
    k_EInputActionOrigin_Switch_ProGyro_Pitch = 222,
    k_EInputActionOrigin_Switch_ProGyro_Yaw = 223,
    k_EInputActionOrigin_Switch_ProGyro_Roll = 224,
    k_EInputActionOrigin_Switch_DPad_Move = 225,
    k_EInputActionOrigin_Switch_Reserved1 = 226,
    k_EInputActionOrigin_Switch_Reserved2 = 227,
    k_EInputActionOrigin_Switch_Reserved3 = 228,
    k_EInputActionOrigin_Switch_Reserved4 = 229,
    k_EInputActionOrigin_Switch_Reserved5 = 230,
    k_EInputActionOrigin_Switch_Reserved6 = 231,
    k_EInputActionOrigin_Switch_Reserved7 = 232,
    k_EInputActionOrigin_Switch_Reserved8 = 233,
    k_EInputActionOrigin_Switch_Reserved9 = 234,
    k_EInputActionOrigin_Switch_Reserved10 = 235,
    k_EInputActionOrigin_Switch_RightGyro_Move = 236,
    k_EInputActionOrigin_Switch_RightGyro_Pitch = 237,
    k_EInputActionOrigin_Switch_RightGyro_Yaw = 238,
    k_EInputActionOrigin_Switch_RightGyro_Roll = 239,
    k_EInputActionOrigin_Switch_LeftGyro_Move = 240,
    k_EInputActionOrigin_Switch_LeftGyro_Pitch = 241,
    k_EInputActionOrigin_Switch_LeftGyro_Yaw = 242,
    k_EInputActionOrigin_Switch_LeftGyro_Roll = 243,
    k_EInputActionOrigin_Switch_LeftGrip_Lower = 244,
    k_EInputActionOrigin_Switch_LeftGrip_Upper = 245,
    k_EInputActionOrigin_Switch_RightGrip_Lower = 246,
    k_EInputActionOrigin_Switch_RightGrip_Upper = 247,
    k_EInputActionOrigin_Switch_JoyConButton_N = 248,
    k_EInputActionOrigin_Switch_JoyConButton_E = 249,
    k_EInputActionOrigin_Switch_JoyConButton_S = 250,
    k_EInputActionOrigin_Switch_JoyConButton_W = 251,
    k_EInputActionOrigin_Switch_Reserved15 = 252,
    k_EInputActionOrigin_Switch_Reserved16 = 253,
    k_EInputActionOrigin_Switch_Reserved17 = 254,
    k_EInputActionOrigin_Switch_Reserved18 = 255,
    k_EInputActionOrigin_Switch_Reserved19 = 256,
    k_EInputActionOrigin_Switch_Reserved20 = 257,
    k_EInputActionOrigin_PS5_X = 258,
    k_EInputActionOrigin_PS5_Circle = 259,
    k_EInputActionOrigin_PS5_Triangle = 260,
    k_EInputActionOrigin_PS5_Square = 261,
    k_EInputActionOrigin_PS5_LeftBumper = 262,
    k_EInputActionOrigin_PS5_RightBumper = 263,
    k_EInputActionOrigin_PS5_Option = 264,
    k_EInputActionOrigin_PS5_Create = 265,
    k_EInputActionOrigin_PS5_Mute = 266,
    k_EInputActionOrigin_PS5_LeftPad_Touch = 267,
    k_EInputActionOrigin_PS5_LeftPad_Swipe = 268,
    k_EInputActionOrigin_PS5_LeftPad_Click = 269,
    k_EInputActionOrigin_PS5_LeftPad_DPadNorth = 270,
    k_EInputActionOrigin_PS5_LeftPad_DPadSouth = 271,
    k_EInputActionOrigin_PS5_LeftPad_DPadWest = 272,
    k_EInputActionOrigin_PS5_LeftPad_DPadEast = 273,
    k_EInputActionOrigin_PS5_RightPad_Touch = 274,
    k_EInputActionOrigin_PS5_RightPad_Swipe = 275,
    k_EInputActionOrigin_PS5_RightPad_Click = 276,
    k_EInputActionOrigin_PS5_RightPad_DPadNorth = 277,
    k_EInputActionOrigin_PS5_RightPad_DPadSouth = 278,
    k_EInputActionOrigin_PS5_RightPad_DPadWest = 279,
    k_EInputActionOrigin_PS5_RightPad_DPadEast = 280,
    k_EInputActionOrigin_PS5_CenterPad_Touch = 281,
    k_EInputActionOrigin_PS5_CenterPad_Swipe = 282,
    k_EInputActionOrigin_PS5_CenterPad_Click = 283,
    k_EInputActionOrigin_PS5_CenterPad_DPadNorth = 284,
    k_EInputActionOrigin_PS5_CenterPad_DPadSouth = 285,
    k_EInputActionOrigin_PS5_CenterPad_DPadWest = 286,
    k_EInputActionOrigin_PS5_CenterPad_DPadEast = 287,
    k_EInputActionOrigin_PS5_LeftTrigger_Pull = 288,
    k_EInputActionOrigin_PS5_LeftTrigger_Click = 289,
    k_EInputActionOrigin_PS5_RightTrigger_Pull = 290,
    k_EInputActionOrigin_PS5_RightTrigger_Click = 291,
    k_EInputActionOrigin_PS5_LeftStick_Move = 292,
    k_EInputActionOrigin_PS5_LeftStick_Click = 293,
    k_EInputActionOrigin_PS5_LeftStick_DPadNorth = 294,
    k_EInputActionOrigin_PS5_LeftStick_DPadSouth = 295,
    k_EInputActionOrigin_PS5_LeftStick_DPadWest = 296,
    k_EInputActionOrigin_PS5_LeftStick_DPadEast = 297,
    k_EInputActionOrigin_PS5_RightStick_Move = 298,
    k_EInputActionOrigin_PS5_RightStick_Click = 299,
    k_EInputActionOrigin_PS5_RightStick_DPadNorth = 300,
    k_EInputActionOrigin_PS5_RightStick_DPadSouth = 301,
    k_EInputActionOrigin_PS5_RightStick_DPadWest = 302,
    k_EInputActionOrigin_PS5_RightStick_DPadEast = 303,
    k_EInputActionOrigin_PS5_DPad_North = 304,
    k_EInputActionOrigin_PS5_DPad_South = 305,
    k_EInputActionOrigin_PS5_DPad_West = 306,
    k_EInputActionOrigin_PS5_DPad_East = 307,
    k_EInputActionOrigin_PS5_Gyro_Move = 308,
    k_EInputActionOrigin_PS5_Gyro_Pitch = 309,
    k_EInputActionOrigin_PS5_Gyro_Yaw = 310,
    k_EInputActionOrigin_PS5_Gyro_Roll = 311,
    k_EInputActionOrigin_PS5_DPad_Move = 312,
    k_EInputActionOrigin_PS5_LeftGrip = 313,
    k_EInputActionOrigin_PS5_RightGrip = 314,
    k_EInputActionOrigin_PS5_LeftFn = 315,
    k_EInputActionOrigin_PS5_RightFn = 316,
    k_EInputActionOrigin_PS5_Reserved5 = 317,
    k_EInputActionOrigin_PS5_Reserved6 = 318,
    k_EInputActionOrigin_PS5_Reserved7 = 319,
    k_EInputActionOrigin_PS5_Reserved8 = 320,
    k_EInputActionOrigin_PS5_Reserved9 = 321,
    k_EInputActionOrigin_PS5_Reserved10 = 322,
    k_EInputActionOrigin_PS5_Reserved11 = 323,
    k_EInputActionOrigin_PS5_Reserved12 = 324,
    k_EInputActionOrigin_PS5_Reserved13 = 325,
    k_EInputActionOrigin_PS5_Reserved14 = 326,
    k_EInputActionOrigin_PS5_Reserved15 = 327,
    k_EInputActionOrigin_PS5_Reserved16 = 328,
    k_EInputActionOrigin_PS5_Reserved17 = 329,
    k_EInputActionOrigin_PS5_Reserved18 = 330,
    k_EInputActionOrigin_PS5_Reserved19 = 331,
    k_EInputActionOrigin_PS5_Reserved20 = 332,
    k_EInputActionOrigin_SteamDeck_A = 333,
    k_EInputActionOrigin_SteamDeck_B = 334,
    k_EInputActionOrigin_SteamDeck_X = 335,
    k_EInputActionOrigin_SteamDeck_Y = 336,
    k_EInputActionOrigin_SteamDeck_L1 = 337,
    k_EInputActionOrigin_SteamDeck_R1 = 338,
    k_EInputActionOrigin_SteamDeck_Menu = 339,
    k_EInputActionOrigin_SteamDeck_View = 340,
    k_EInputActionOrigin_SteamDeck_LeftPad_Touch = 341,
    k_EInputActionOrigin_SteamDeck_LeftPad_Swipe = 342,
    k_EInputActionOrigin_SteamDeck_LeftPad_Click = 343,
    k_EInputActionOrigin_SteamDeck_LeftPad_DPadNorth = 344,
    k_EInputActionOrigin_SteamDeck_LeftPad_DPadSouth = 345,
    k_EInputActionOrigin_SteamDeck_LeftPad_DPadWest = 346,
    k_EInputActionOrigin_SteamDeck_LeftPad_DPadEast = 347,
    k_EInputActionOrigin_SteamDeck_RightPad_Touch = 348,
    k_EInputActionOrigin_SteamDeck_RightPad_Swipe = 349,
    k_EInputActionOrigin_SteamDeck_RightPad_Click = 350,
    k_EInputActionOrigin_SteamDeck_RightPad_DPadNorth = 351,
    k_EInputActionOrigin_SteamDeck_RightPad_DPadSouth = 352,
    k_EInputActionOrigin_SteamDeck_RightPad_DPadWest = 353,
    k_EInputActionOrigin_SteamDeck_RightPad_DPadEast = 354,
    k_EInputActionOrigin_SteamDeck_L2_SoftPull = 355,
    k_EInputActionOrigin_SteamDeck_L2 = 356,
    k_EInputActionOrigin_SteamDeck_R2_SoftPull = 357,
    k_EInputActionOrigin_SteamDeck_R2 = 358,
    k_EInputActionOrigin_SteamDeck_LeftStick_Move = 359,
    k_EInputActionOrigin_SteamDeck_L3 = 360,
    k_EInputActionOrigin_SteamDeck_LeftStick_DPadNorth = 361,
    k_EInputActionOrigin_SteamDeck_LeftStick_DPadSouth = 362,
    k_EInputActionOrigin_SteamDeck_LeftStick_DPadWest = 363,
    k_EInputActionOrigin_SteamDeck_LeftStick_DPadEast = 364,
    k_EInputActionOrigin_SteamDeck_LeftStick_Touch = 365,
    k_EInputActionOrigin_SteamDeck_RightStick_Move = 366,
    k_EInputActionOrigin_SteamDeck_R3 = 367,
    k_EInputActionOrigin_SteamDeck_RightStick_DPadNorth = 368,
    k_EInputActionOrigin_SteamDeck_RightStick_DPadSouth = 369,
    k_EInputActionOrigin_SteamDeck_RightStick_DPadWest = 370,
    k_EInputActionOrigin_SteamDeck_RightStick_DPadEast = 371,
    k_EInputActionOrigin_SteamDeck_RightStick_Touch = 372,
    k_EInputActionOrigin_SteamDeck_L4 = 373,
    k_EInputActionOrigin_SteamDeck_R4 = 374,
    k_EInputActionOrigin_SteamDeck_L5 = 375,
    k_EInputActionOrigin_SteamDeck_R5 = 376,
    k_EInputActionOrigin_SteamDeck_DPad_Move = 377,
    k_EInputActionOrigin_SteamDeck_DPad_North = 378,
    k_EInputActionOrigin_SteamDeck_DPad_South = 379,
    k_EInputActionOrigin_SteamDeck_DPad_West = 380,
    k_EInputActionOrigin_SteamDeck_DPad_East = 381,
    k_EInputActionOrigin_SteamDeck_Gyro_Move = 382,
    k_EInputActionOrigin_SteamDeck_Gyro_Pitch = 383,
    k_EInputActionOrigin_SteamDeck_Gyro_Yaw = 384,
    k_EInputActionOrigin_SteamDeck_Gyro_Roll = 385,
    k_EInputActionOrigin_SteamDeck_Reserved1 = 386,
    k_EInputActionOrigin_SteamDeck_Reserved2 = 387,
    k_EInputActionOrigin_SteamDeck_Reserved3 = 388,
    k_EInputActionOrigin_SteamDeck_Reserved4 = 389,
    k_EInputActionOrigin_SteamDeck_Reserved5 = 390,
    k_EInputActionOrigin_SteamDeck_Reserved6 = 391,
    k_EInputActionOrigin_SteamDeck_Reserved7 = 392,
    k_EInputActionOrigin_SteamDeck_Reserved8 = 393,
    k_EInputActionOrigin_SteamDeck_Reserved9 = 394,
    k_EInputActionOrigin_SteamDeck_Reserved10 = 395,
    k_EInputActionOrigin_SteamDeck_Reserved11 = 396,
    k_EInputActionOrigin_SteamDeck_Reserved12 = 397,
    k_EInputActionOrigin_SteamDeck_Reserved13 = 398,
    k_EInputActionOrigin_SteamDeck_Reserved14 = 399,
    k_EInputActionOrigin_SteamDeck_Reserved15 = 400,
    k_EInputActionOrigin_SteamDeck_Reserved16 = 401,
    k_EInputActionOrigin_SteamDeck_Reserved17 = 402,
    k_EInputActionOrigin_SteamDeck_Reserved18 = 403,
    k_EInputActionOrigin_SteamDeck_Reserved19 = 404,
    k_EInputActionOrigin_SteamDeck_Reserved20 = 405,
    k_EInputActionOrigin_Horipad_M1 = 406,
    k_EInputActionOrigin_Horipad_M2 = 407,
    k_EInputActionOrigin_Horipad_L4 = 408,
    k_EInputActionOrigin_Horipad_R4 = 409,
    k_EInputActionOrigin_Count = 410,
    k_EInputActionOrigin_MaximumPossibleValue = 32767,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EXboxOrigin {
    k_EXboxOrigin_A = 0,
    k_EXboxOrigin_B = 1,
    k_EXboxOrigin_X = 2,
    k_EXboxOrigin_Y = 3,
    k_EXboxOrigin_LeftBumper = 4,
    k_EXboxOrigin_RightBumper = 5,
    k_EXboxOrigin_Menu = 6,
    k_EXboxOrigin_View = 7,
    k_EXboxOrigin_LeftTrigger_Pull = 8,
    k_EXboxOrigin_LeftTrigger_Click = 9,
    k_EXboxOrigin_RightTrigger_Pull = 10,
    k_EXboxOrigin_RightTrigger_Click = 11,
    k_EXboxOrigin_LeftStick_Move = 12,
    k_EXboxOrigin_LeftStick_Click = 13,
    k_EXboxOrigin_LeftStick_DPadNorth = 14,
    k_EXboxOrigin_LeftStick_DPadSouth = 15,
    k_EXboxOrigin_LeftStick_DPadWest = 16,
    k_EXboxOrigin_LeftStick_DPadEast = 17,
    k_EXboxOrigin_RightStick_Move = 18,
    k_EXboxOrigin_RightStick_Click = 19,
    k_EXboxOrigin_RightStick_DPadNorth = 20,
    k_EXboxOrigin_RightStick_DPadSouth = 21,
    k_EXboxOrigin_RightStick_DPadWest = 22,
    k_EXboxOrigin_RightStick_DPadEast = 23,
    k_EXboxOrigin_DPad_North = 24,
    k_EXboxOrigin_DPad_South = 25,
    k_EXboxOrigin_DPad_West = 26,
    k_EXboxOrigin_DPad_East = 27,
    k_EXboxOrigin_Count = 28,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamControllerPad {
    k_ESteamControllerPad_Left = 0,
    k_ESteamControllerPad_Right = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EControllerHapticLocation {
    k_EControllerHapticLocation_Left = 1,
    k_EControllerHapticLocation_Right = 2,
    k_EControllerHapticLocation_Both = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamInputType {
    k_ESteamInputType_Unknown = 0,
    k_ESteamInputType_SteamController = 1,
    k_ESteamInputType_XBox360Controller = 2,
    k_ESteamInputType_XBoxOneController = 3,
    k_ESteamInputType_GenericGamepad = 4,
    k_ESteamInputType_PS4Controller = 5,
    k_ESteamInputType_AppleMFiController = 6,
    k_ESteamInputType_AndroidController = 7,
    k_ESteamInputType_SwitchJoyConPair = 8,
    k_ESteamInputType_SwitchJoyConSingle = 9,
    k_ESteamInputType_SwitchProController = 10,
    k_ESteamInputType_MobileTouch = 11,
    k_ESteamInputType_PS3Controller = 12,
    k_ESteamInputType_PS5Controller = 13,
    k_ESteamInputType_SteamDeckController = 14,
    k_ESteamInputType_Count = 15,
    k_ESteamInputType_MaximumPossibleValue = 255,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamInputConfigurationEnableType {
    k_ESteamInputConfigurationEnableType_None = 0,
    k_ESteamInputConfigurationEnableType_Playstation = 1,
    k_ESteamInputConfigurationEnableType_Xbox = 2,
    k_ESteamInputConfigurationEnableType_Generic = 4,
    k_ESteamInputConfigurationEnableType_Switch = 8,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamInputLEDFlag {
    k_ESteamInputLEDFlag_SetColor = 0,
    k_ESteamInputLEDFlag_RestoreUserDefault = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamInputGlyphSize {
    k_ESteamInputGlyphSize_Small = 0,
    k_ESteamInputGlyphSize_Medium = 1,
    k_ESteamInputGlyphSize_Large = 2,
    k_ESteamInputGlyphSize_Count = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamInputGlyphStyle {
    ESteamInputGlyphStyle_Knockout = 0,
    ESteamInputGlyphStyle_Light = 1,
    ESteamInputGlyphStyle_Dark = 2,
    ESteamInputGlyphStyle_NeutralColorABXY = 16,
    ESteamInputGlyphStyle_SolidABXY = 32,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamInputActionEventType {
    ESteamInputActionEventType_DigitalAction = 0,
    ESteamInputActionEventType_AnalogAction = 1,
}
pub type InputHandle_t = uint64;
pub type InputActionSetHandle_t = uint64;
pub type InputDigitalActionHandle_t = uint64;
pub type InputAnalogActionHandle_t = uint64;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct InputAnalogActionData_t {
    pub eMode: EInputSourceMode,
    pub x: f32,
    pub y: f32,
    pub bActive: bool,
}
#[test]
fn bindgen_test_layout_InputAnalogActionData_t() {
    const UNINIT: ::std::mem::MaybeUninit<InputAnalogActionData_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<InputAnalogActionData_t>(),
        13usize,
        concat!("Size of: ", stringify!(InputAnalogActionData_t))
    );
    assert_eq!(
        ::std::mem::align_of::<InputAnalogActionData_t>(),
        1usize,
        concat!("Alignment of ", stringify!(InputAnalogActionData_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eMode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InputAnalogActionData_t),
            "::",
            stringify!(eMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(InputAnalogActionData_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(InputAnalogActionData_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bActive) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(InputAnalogActionData_t),
            "::",
            stringify!(bActive)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InputDigitalActionData_t {
    pub bState: bool,
    pub bActive: bool,
}
#[test]
fn bindgen_test_layout_InputDigitalActionData_t() {
    const UNINIT: ::std::mem::MaybeUninit<InputDigitalActionData_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<InputDigitalActionData_t>(),
        2usize,
        concat!("Size of: ", stringify!(InputDigitalActionData_t))
    );
    assert_eq!(
        ::std::mem::align_of::<InputDigitalActionData_t>(),
        1usize,
        concat!("Alignment of ", stringify!(InputDigitalActionData_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InputDigitalActionData_t),
            "::",
            stringify!(bState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bActive) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(InputDigitalActionData_t),
            "::",
            stringify!(bActive)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct InputMotionData_t {
    pub rotQuatX: f32,
    pub rotQuatY: f32,
    pub rotQuatZ: f32,
    pub rotQuatW: f32,
    pub posAccelX: f32,
    pub posAccelY: f32,
    pub posAccelZ: f32,
    pub rotVelX: f32,
    pub rotVelY: f32,
    pub rotVelZ: f32,
}
#[test]
fn bindgen_test_layout_InputMotionData_t() {
    const UNINIT: ::std::mem::MaybeUninit<InputMotionData_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<InputMotionData_t>(),
        40usize,
        concat!("Size of: ", stringify!(InputMotionData_t))
    );
    assert_eq!(
        ::std::mem::align_of::<InputMotionData_t>(),
        1usize,
        concat!("Alignment of ", stringify!(InputMotionData_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotQuatX) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InputMotionData_t),
            "::",
            stringify!(rotQuatX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotQuatY) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(InputMotionData_t),
            "::",
            stringify!(rotQuatY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotQuatZ) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(InputMotionData_t),
            "::",
            stringify!(rotQuatZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotQuatW) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(InputMotionData_t),
            "::",
            stringify!(rotQuatW)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).posAccelX) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(InputMotionData_t),
            "::",
            stringify!(posAccelX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).posAccelY) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(InputMotionData_t),
            "::",
            stringify!(posAccelY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).posAccelZ) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(InputMotionData_t),
            "::",
            stringify!(posAccelZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotVelX) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(InputMotionData_t),
            "::",
            stringify!(rotVelX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotVelY) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(InputMotionData_t),
            "::",
            stringify!(rotVelY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotVelZ) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(InputMotionData_t),
            "::",
            stringify!(rotVelZ)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct SteamInputActionEvent_t {
    pub controllerHandle: InputHandle_t,
    pub eEventType: ESteamInputActionEventType,
    pub __bindgen_anon_1: SteamInputActionEvent_t__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SteamInputActionEvent_t_AnalogAction_t {
    pub actionHandle: InputAnalogActionHandle_t,
    pub analogActionData: InputAnalogActionData_t,
}
#[test]
fn bindgen_test_layout_SteamInputActionEvent_t_AnalogAction_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInputActionEvent_t_AnalogAction_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInputActionEvent_t_AnalogAction_t>(),
        21usize,
        concat!(
            "Size of: ",
            stringify!(SteamInputActionEvent_t_AnalogAction_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInputActionEvent_t_AnalogAction_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SteamInputActionEvent_t_AnalogAction_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).actionHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputActionEvent_t_AnalogAction_t),
            "::",
            stringify!(actionHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).analogActionData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputActionEvent_t_AnalogAction_t),
            "::",
            stringify!(analogActionData)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SteamInputActionEvent_t_DigitalAction_t {
    pub actionHandle: InputDigitalActionHandle_t,
    pub digitalActionData: InputDigitalActionData_t,
}
#[test]
fn bindgen_test_layout_SteamInputActionEvent_t_DigitalAction_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInputActionEvent_t_DigitalAction_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInputActionEvent_t_DigitalAction_t>(),
        10usize,
        concat!(
            "Size of: ",
            stringify!(SteamInputActionEvent_t_DigitalAction_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInputActionEvent_t_DigitalAction_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SteamInputActionEvent_t_DigitalAction_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).actionHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputActionEvent_t_DigitalAction_t),
            "::",
            stringify!(actionHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).digitalActionData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputActionEvent_t_DigitalAction_t),
            "::",
            stringify!(digitalActionData)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SteamInputActionEvent_t__bindgen_ty_1 {
    pub analogAction: SteamInputActionEvent_t_AnalogAction_t,
    pub digitalAction: SteamInputActionEvent_t_DigitalAction_t,
}
#[test]
fn bindgen_test_layout_SteamInputActionEvent_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInputActionEvent_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInputActionEvent_t__bindgen_ty_1>(),
        21usize,
        concat!(
            "Size of: ",
            stringify!(SteamInputActionEvent_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInputActionEvent_t__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SteamInputActionEvent_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).analogAction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputActionEvent_t__bindgen_ty_1),
            "::",
            stringify!(analogAction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).digitalAction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputActionEvent_t__bindgen_ty_1),
            "::",
            stringify!(digitalAction)
        )
    );
}
#[test]
fn bindgen_test_layout_SteamInputActionEvent_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInputActionEvent_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInputActionEvent_t>(),
        33usize,
        concat!("Size of: ", stringify!(SteamInputActionEvent_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInputActionEvent_t>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamInputActionEvent_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).controllerHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputActionEvent_t),
            "::",
            stringify!(controllerHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eEventType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputActionEvent_t),
            "::",
            stringify!(eEventType)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScePadTriggerEffectParam {
    _unused: [u8; 0],
}
pub type SteamInputActionEventCallbackPointer =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut SteamInputActionEvent_t)>;
#[repr(C)]
pub struct ISteamInput__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamInput {
    pub vtable_: *const ISteamInput__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamInput() {
    assert_eq!(
        ::std::mem::size_of::<ISteamInput>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamInput))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamInput>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamInput))
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct SteamInputDeviceConnected_t {
    pub m_ulConnectedDeviceHandle: InputHandle_t,
}
pub const SteamInputDeviceConnected_t_k_iCallback: SteamInputDeviceConnected_t__bindgen_ty_1 =
    SteamInputDeviceConnected_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamInputDeviceConnected_t__bindgen_ty_1 {
    k_iCallback = 2801,
}
#[test]
fn bindgen_test_layout_SteamInputDeviceConnected_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInputDeviceConnected_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInputDeviceConnected_t>(),
        8usize,
        concat!("Size of: ", stringify!(SteamInputDeviceConnected_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInputDeviceConnected_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamInputDeviceConnected_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulConnectedDeviceHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputDeviceConnected_t),
            "::",
            stringify!(m_ulConnectedDeviceHandle)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct SteamInputDeviceDisconnected_t {
    pub m_ulDisconnectedDeviceHandle: InputHandle_t,
}
pub const SteamInputDeviceDisconnected_t_k_iCallback: SteamInputDeviceDisconnected_t__bindgen_ty_1 =
    SteamInputDeviceDisconnected_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamInputDeviceDisconnected_t__bindgen_ty_1 {
    k_iCallback = 2802,
}
#[test]
fn bindgen_test_layout_SteamInputDeviceDisconnected_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInputDeviceDisconnected_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInputDeviceDisconnected_t>(),
        8usize,
        concat!("Size of: ", stringify!(SteamInputDeviceDisconnected_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInputDeviceDisconnected_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamInputDeviceDisconnected_t))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_ulDisconnectedDeviceHandle) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputDeviceDisconnected_t),
            "::",
            stringify!(m_ulDisconnectedDeviceHandle)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct SteamInputConfigurationLoaded_t {
    pub m_unAppID: AppId_t,
    pub m_ulDeviceHandle: InputHandle_t,
    pub m_ulMappingCreator: CSteamID,
    pub m_unMajorRevision: uint32,
    pub m_unMinorRevision: uint32,
    pub m_bUsesSteamInputAPI: bool,
    pub m_bUsesGamepadAPI: bool,
}
pub const SteamInputConfigurationLoaded_t_k_iCallback:
    SteamInputConfigurationLoaded_t__bindgen_ty_1 =
    SteamInputConfigurationLoaded_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamInputConfigurationLoaded_t__bindgen_ty_1 {
    k_iCallback = 2803,
}
#[test]
fn bindgen_test_layout_SteamInputConfigurationLoaded_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInputConfigurationLoaded_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInputConfigurationLoaded_t>(),
        32usize,
        concat!("Size of: ", stringify!(SteamInputConfigurationLoaded_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInputConfigurationLoaded_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamInputConfigurationLoaded_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unAppID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputConfigurationLoaded_t),
            "::",
            stringify!(m_unAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulDeviceHandle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputConfigurationLoaded_t),
            "::",
            stringify!(m_ulDeviceHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulMappingCreator) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputConfigurationLoaded_t),
            "::",
            stringify!(m_ulMappingCreator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unMajorRevision) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputConfigurationLoaded_t),
            "::",
            stringify!(m_unMajorRevision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unMinorRevision) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputConfigurationLoaded_t),
            "::",
            stringify!(m_unMinorRevision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bUsesSteamInputAPI) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputConfigurationLoaded_t),
            "::",
            stringify!(m_bUsesSteamInputAPI)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bUsesGamepadAPI) as usize - ptr as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputConfigurationLoaded_t),
            "::",
            stringify!(m_bUsesGamepadAPI)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct SteamInputGamepadSlotChange_t {
    pub m_unAppID: AppId_t,
    pub m_ulDeviceHandle: InputHandle_t,
    pub m_eDeviceType: ESteamInputType,
    pub m_nOldGamepadSlot: ::std::os::raw::c_int,
    pub m_nNewGamepadSlot: ::std::os::raw::c_int,
}
pub const SteamInputGamepadSlotChange_t_k_iCallback: SteamInputGamepadSlotChange_t__bindgen_ty_1 =
    SteamInputGamepadSlotChange_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamInputGamepadSlotChange_t__bindgen_ty_1 {
    k_iCallback = 2804,
}
#[test]
fn bindgen_test_layout_SteamInputGamepadSlotChange_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInputGamepadSlotChange_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInputGamepadSlotChange_t>(),
        24usize,
        concat!("Size of: ", stringify!(SteamInputGamepadSlotChange_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInputGamepadSlotChange_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamInputGamepadSlotChange_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unAppID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputGamepadSlotChange_t),
            "::",
            stringify!(m_unAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulDeviceHandle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputGamepadSlotChange_t),
            "::",
            stringify!(m_ulDeviceHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eDeviceType) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputGamepadSlotChange_t),
            "::",
            stringify!(m_eDeviceType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nOldGamepadSlot) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputGamepadSlotChange_t),
            "::",
            stringify!(m_nOldGamepadSlot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nNewGamepadSlot) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputGamepadSlotChange_t),
            "::",
            stringify!(m_nNewGamepadSlot)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EControllerActionOrigin {
    k_EControllerActionOrigin_None = 0,
    k_EControllerActionOrigin_A = 1,
    k_EControllerActionOrigin_B = 2,
    k_EControllerActionOrigin_X = 3,
    k_EControllerActionOrigin_Y = 4,
    k_EControllerActionOrigin_LeftBumper = 5,
    k_EControllerActionOrigin_RightBumper = 6,
    k_EControllerActionOrigin_LeftGrip = 7,
    k_EControllerActionOrigin_RightGrip = 8,
    k_EControllerActionOrigin_Start = 9,
    k_EControllerActionOrigin_Back = 10,
    k_EControllerActionOrigin_LeftPad_Touch = 11,
    k_EControllerActionOrigin_LeftPad_Swipe = 12,
    k_EControllerActionOrigin_LeftPad_Click = 13,
    k_EControllerActionOrigin_LeftPad_DPadNorth = 14,
    k_EControllerActionOrigin_LeftPad_DPadSouth = 15,
    k_EControllerActionOrigin_LeftPad_DPadWest = 16,
    k_EControllerActionOrigin_LeftPad_DPadEast = 17,
    k_EControllerActionOrigin_RightPad_Touch = 18,
    k_EControllerActionOrigin_RightPad_Swipe = 19,
    k_EControllerActionOrigin_RightPad_Click = 20,
    k_EControllerActionOrigin_RightPad_DPadNorth = 21,
    k_EControllerActionOrigin_RightPad_DPadSouth = 22,
    k_EControllerActionOrigin_RightPad_DPadWest = 23,
    k_EControllerActionOrigin_RightPad_DPadEast = 24,
    k_EControllerActionOrigin_LeftTrigger_Pull = 25,
    k_EControllerActionOrigin_LeftTrigger_Click = 26,
    k_EControllerActionOrigin_RightTrigger_Pull = 27,
    k_EControllerActionOrigin_RightTrigger_Click = 28,
    k_EControllerActionOrigin_LeftStick_Move = 29,
    k_EControllerActionOrigin_LeftStick_Click = 30,
    k_EControllerActionOrigin_LeftStick_DPadNorth = 31,
    k_EControllerActionOrigin_LeftStick_DPadSouth = 32,
    k_EControllerActionOrigin_LeftStick_DPadWest = 33,
    k_EControllerActionOrigin_LeftStick_DPadEast = 34,
    k_EControllerActionOrigin_Gyro_Move = 35,
    k_EControllerActionOrigin_Gyro_Pitch = 36,
    k_EControllerActionOrigin_Gyro_Yaw = 37,
    k_EControllerActionOrigin_Gyro_Roll = 38,
    k_EControllerActionOrigin_PS4_X = 39,
    k_EControllerActionOrigin_PS4_Circle = 40,
    k_EControllerActionOrigin_PS4_Triangle = 41,
    k_EControllerActionOrigin_PS4_Square = 42,
    k_EControllerActionOrigin_PS4_LeftBumper = 43,
    k_EControllerActionOrigin_PS4_RightBumper = 44,
    k_EControllerActionOrigin_PS4_Options = 45,
    k_EControllerActionOrigin_PS4_Share = 46,
    k_EControllerActionOrigin_PS4_LeftPad_Touch = 47,
    k_EControllerActionOrigin_PS4_LeftPad_Swipe = 48,
    k_EControllerActionOrigin_PS4_LeftPad_Click = 49,
    k_EControllerActionOrigin_PS4_LeftPad_DPadNorth = 50,
    k_EControllerActionOrigin_PS4_LeftPad_DPadSouth = 51,
    k_EControllerActionOrigin_PS4_LeftPad_DPadWest = 52,
    k_EControllerActionOrigin_PS4_LeftPad_DPadEast = 53,
    k_EControllerActionOrigin_PS4_RightPad_Touch = 54,
    k_EControllerActionOrigin_PS4_RightPad_Swipe = 55,
    k_EControllerActionOrigin_PS4_RightPad_Click = 56,
    k_EControllerActionOrigin_PS4_RightPad_DPadNorth = 57,
    k_EControllerActionOrigin_PS4_RightPad_DPadSouth = 58,
    k_EControllerActionOrigin_PS4_RightPad_DPadWest = 59,
    k_EControllerActionOrigin_PS4_RightPad_DPadEast = 60,
    k_EControllerActionOrigin_PS4_CenterPad_Touch = 61,
    k_EControllerActionOrigin_PS4_CenterPad_Swipe = 62,
    k_EControllerActionOrigin_PS4_CenterPad_Click = 63,
    k_EControllerActionOrigin_PS4_CenterPad_DPadNorth = 64,
    k_EControllerActionOrigin_PS4_CenterPad_DPadSouth = 65,
    k_EControllerActionOrigin_PS4_CenterPad_DPadWest = 66,
    k_EControllerActionOrigin_PS4_CenterPad_DPadEast = 67,
    k_EControllerActionOrigin_PS4_LeftTrigger_Pull = 68,
    k_EControllerActionOrigin_PS4_LeftTrigger_Click = 69,
    k_EControllerActionOrigin_PS4_RightTrigger_Pull = 70,
    k_EControllerActionOrigin_PS4_RightTrigger_Click = 71,
    k_EControllerActionOrigin_PS4_LeftStick_Move = 72,
    k_EControllerActionOrigin_PS4_LeftStick_Click = 73,
    k_EControllerActionOrigin_PS4_LeftStick_DPadNorth = 74,
    k_EControllerActionOrigin_PS4_LeftStick_DPadSouth = 75,
    k_EControllerActionOrigin_PS4_LeftStick_DPadWest = 76,
    k_EControllerActionOrigin_PS4_LeftStick_DPadEast = 77,
    k_EControllerActionOrigin_PS4_RightStick_Move = 78,
    k_EControllerActionOrigin_PS4_RightStick_Click = 79,
    k_EControllerActionOrigin_PS4_RightStick_DPadNorth = 80,
    k_EControllerActionOrigin_PS4_RightStick_DPadSouth = 81,
    k_EControllerActionOrigin_PS4_RightStick_DPadWest = 82,
    k_EControllerActionOrigin_PS4_RightStick_DPadEast = 83,
    k_EControllerActionOrigin_PS4_DPad_North = 84,
    k_EControllerActionOrigin_PS4_DPad_South = 85,
    k_EControllerActionOrigin_PS4_DPad_West = 86,
    k_EControllerActionOrigin_PS4_DPad_East = 87,
    k_EControllerActionOrigin_PS4_Gyro_Move = 88,
    k_EControllerActionOrigin_PS4_Gyro_Pitch = 89,
    k_EControllerActionOrigin_PS4_Gyro_Yaw = 90,
    k_EControllerActionOrigin_PS4_Gyro_Roll = 91,
    k_EControllerActionOrigin_XBoxOne_A = 92,
    k_EControllerActionOrigin_XBoxOne_B = 93,
    k_EControllerActionOrigin_XBoxOne_X = 94,
    k_EControllerActionOrigin_XBoxOne_Y = 95,
    k_EControllerActionOrigin_XBoxOne_LeftBumper = 96,
    k_EControllerActionOrigin_XBoxOne_RightBumper = 97,
    k_EControllerActionOrigin_XBoxOne_Menu = 98,
    k_EControllerActionOrigin_XBoxOne_View = 99,
    k_EControllerActionOrigin_XBoxOne_LeftTrigger_Pull = 100,
    k_EControllerActionOrigin_XBoxOne_LeftTrigger_Click = 101,
    k_EControllerActionOrigin_XBoxOne_RightTrigger_Pull = 102,
    k_EControllerActionOrigin_XBoxOne_RightTrigger_Click = 103,
    k_EControllerActionOrigin_XBoxOne_LeftStick_Move = 104,
    k_EControllerActionOrigin_XBoxOne_LeftStick_Click = 105,
    k_EControllerActionOrigin_XBoxOne_LeftStick_DPadNorth = 106,
    k_EControllerActionOrigin_XBoxOne_LeftStick_DPadSouth = 107,
    k_EControllerActionOrigin_XBoxOne_LeftStick_DPadWest = 108,
    k_EControllerActionOrigin_XBoxOne_LeftStick_DPadEast = 109,
    k_EControllerActionOrigin_XBoxOne_RightStick_Move = 110,
    k_EControllerActionOrigin_XBoxOne_RightStick_Click = 111,
    k_EControllerActionOrigin_XBoxOne_RightStick_DPadNorth = 112,
    k_EControllerActionOrigin_XBoxOne_RightStick_DPadSouth = 113,
    k_EControllerActionOrigin_XBoxOne_RightStick_DPadWest = 114,
    k_EControllerActionOrigin_XBoxOne_RightStick_DPadEast = 115,
    k_EControllerActionOrigin_XBoxOne_DPad_North = 116,
    k_EControllerActionOrigin_XBoxOne_DPad_South = 117,
    k_EControllerActionOrigin_XBoxOne_DPad_West = 118,
    k_EControllerActionOrigin_XBoxOne_DPad_East = 119,
    k_EControllerActionOrigin_XBox360_A = 120,
    k_EControllerActionOrigin_XBox360_B = 121,
    k_EControllerActionOrigin_XBox360_X = 122,
    k_EControllerActionOrigin_XBox360_Y = 123,
    k_EControllerActionOrigin_XBox360_LeftBumper = 124,
    k_EControllerActionOrigin_XBox360_RightBumper = 125,
    k_EControllerActionOrigin_XBox360_Start = 126,
    k_EControllerActionOrigin_XBox360_Back = 127,
    k_EControllerActionOrigin_XBox360_LeftTrigger_Pull = 128,
    k_EControllerActionOrigin_XBox360_LeftTrigger_Click = 129,
    k_EControllerActionOrigin_XBox360_RightTrigger_Pull = 130,
    k_EControllerActionOrigin_XBox360_RightTrigger_Click = 131,
    k_EControllerActionOrigin_XBox360_LeftStick_Move = 132,
    k_EControllerActionOrigin_XBox360_LeftStick_Click = 133,
    k_EControllerActionOrigin_XBox360_LeftStick_DPadNorth = 134,
    k_EControllerActionOrigin_XBox360_LeftStick_DPadSouth = 135,
    k_EControllerActionOrigin_XBox360_LeftStick_DPadWest = 136,
    k_EControllerActionOrigin_XBox360_LeftStick_DPadEast = 137,
    k_EControllerActionOrigin_XBox360_RightStick_Move = 138,
    k_EControllerActionOrigin_XBox360_RightStick_Click = 139,
    k_EControllerActionOrigin_XBox360_RightStick_DPadNorth = 140,
    k_EControllerActionOrigin_XBox360_RightStick_DPadSouth = 141,
    k_EControllerActionOrigin_XBox360_RightStick_DPadWest = 142,
    k_EControllerActionOrigin_XBox360_RightStick_DPadEast = 143,
    k_EControllerActionOrigin_XBox360_DPad_North = 144,
    k_EControllerActionOrigin_XBox360_DPad_South = 145,
    k_EControllerActionOrigin_XBox360_DPad_West = 146,
    k_EControllerActionOrigin_XBox360_DPad_East = 147,
    k_EControllerActionOrigin_SteamV2_A = 148,
    k_EControllerActionOrigin_SteamV2_B = 149,
    k_EControllerActionOrigin_SteamV2_X = 150,
    k_EControllerActionOrigin_SteamV2_Y = 151,
    k_EControllerActionOrigin_SteamV2_LeftBumper = 152,
    k_EControllerActionOrigin_SteamV2_RightBumper = 153,
    k_EControllerActionOrigin_SteamV2_LeftGrip_Lower = 154,
    k_EControllerActionOrigin_SteamV2_LeftGrip_Upper = 155,
    k_EControllerActionOrigin_SteamV2_RightGrip_Lower = 156,
    k_EControllerActionOrigin_SteamV2_RightGrip_Upper = 157,
    k_EControllerActionOrigin_SteamV2_LeftBumper_Pressure = 158,
    k_EControllerActionOrigin_SteamV2_RightBumper_Pressure = 159,
    k_EControllerActionOrigin_SteamV2_LeftGrip_Pressure = 160,
    k_EControllerActionOrigin_SteamV2_RightGrip_Pressure = 161,
    k_EControllerActionOrigin_SteamV2_LeftGrip_Upper_Pressure = 162,
    k_EControllerActionOrigin_SteamV2_RightGrip_Upper_Pressure = 163,
    k_EControllerActionOrigin_SteamV2_Start = 164,
    k_EControllerActionOrigin_SteamV2_Back = 165,
    k_EControllerActionOrigin_SteamV2_LeftPad_Touch = 166,
    k_EControllerActionOrigin_SteamV2_LeftPad_Swipe = 167,
    k_EControllerActionOrigin_SteamV2_LeftPad_Click = 168,
    k_EControllerActionOrigin_SteamV2_LeftPad_Pressure = 169,
    k_EControllerActionOrigin_SteamV2_LeftPad_DPadNorth = 170,
    k_EControllerActionOrigin_SteamV2_LeftPad_DPadSouth = 171,
    k_EControllerActionOrigin_SteamV2_LeftPad_DPadWest = 172,
    k_EControllerActionOrigin_SteamV2_LeftPad_DPadEast = 173,
    k_EControllerActionOrigin_SteamV2_RightPad_Touch = 174,
    k_EControllerActionOrigin_SteamV2_RightPad_Swipe = 175,
    k_EControllerActionOrigin_SteamV2_RightPad_Click = 176,
    k_EControllerActionOrigin_SteamV2_RightPad_Pressure = 177,
    k_EControllerActionOrigin_SteamV2_RightPad_DPadNorth = 178,
    k_EControllerActionOrigin_SteamV2_RightPad_DPadSouth = 179,
    k_EControllerActionOrigin_SteamV2_RightPad_DPadWest = 180,
    k_EControllerActionOrigin_SteamV2_RightPad_DPadEast = 181,
    k_EControllerActionOrigin_SteamV2_LeftTrigger_Pull = 182,
    k_EControllerActionOrigin_SteamV2_LeftTrigger_Click = 183,
    k_EControllerActionOrigin_SteamV2_RightTrigger_Pull = 184,
    k_EControllerActionOrigin_SteamV2_RightTrigger_Click = 185,
    k_EControllerActionOrigin_SteamV2_LeftStick_Move = 186,
    k_EControllerActionOrigin_SteamV2_LeftStick_Click = 187,
    k_EControllerActionOrigin_SteamV2_LeftStick_DPadNorth = 188,
    k_EControllerActionOrigin_SteamV2_LeftStick_DPadSouth = 189,
    k_EControllerActionOrigin_SteamV2_LeftStick_DPadWest = 190,
    k_EControllerActionOrigin_SteamV2_LeftStick_DPadEast = 191,
    k_EControllerActionOrigin_SteamV2_Gyro_Move = 192,
    k_EControllerActionOrigin_SteamV2_Gyro_Pitch = 193,
    k_EControllerActionOrigin_SteamV2_Gyro_Yaw = 194,
    k_EControllerActionOrigin_SteamV2_Gyro_Roll = 195,
    k_EControllerActionOrigin_Switch_A = 196,
    k_EControllerActionOrigin_Switch_B = 197,
    k_EControllerActionOrigin_Switch_X = 198,
    k_EControllerActionOrigin_Switch_Y = 199,
    k_EControllerActionOrigin_Switch_LeftBumper = 200,
    k_EControllerActionOrigin_Switch_RightBumper = 201,
    k_EControllerActionOrigin_Switch_Plus = 202,
    k_EControllerActionOrigin_Switch_Minus = 203,
    k_EControllerActionOrigin_Switch_Capture = 204,
    k_EControllerActionOrigin_Switch_LeftTrigger_Pull = 205,
    k_EControllerActionOrigin_Switch_LeftTrigger_Click = 206,
    k_EControllerActionOrigin_Switch_RightTrigger_Pull = 207,
    k_EControllerActionOrigin_Switch_RightTrigger_Click = 208,
    k_EControllerActionOrigin_Switch_LeftStick_Move = 209,
    k_EControllerActionOrigin_Switch_LeftStick_Click = 210,
    k_EControllerActionOrigin_Switch_LeftStick_DPadNorth = 211,
    k_EControllerActionOrigin_Switch_LeftStick_DPadSouth = 212,
    k_EControllerActionOrigin_Switch_LeftStick_DPadWest = 213,
    k_EControllerActionOrigin_Switch_LeftStick_DPadEast = 214,
    k_EControllerActionOrigin_Switch_RightStick_Move = 215,
    k_EControllerActionOrigin_Switch_RightStick_Click = 216,
    k_EControllerActionOrigin_Switch_RightStick_DPadNorth = 217,
    k_EControllerActionOrigin_Switch_RightStick_DPadSouth = 218,
    k_EControllerActionOrigin_Switch_RightStick_DPadWest = 219,
    k_EControllerActionOrigin_Switch_RightStick_DPadEast = 220,
    k_EControllerActionOrigin_Switch_DPad_North = 221,
    k_EControllerActionOrigin_Switch_DPad_South = 222,
    k_EControllerActionOrigin_Switch_DPad_West = 223,
    k_EControllerActionOrigin_Switch_DPad_East = 224,
    k_EControllerActionOrigin_Switch_ProGyro_Move = 225,
    k_EControllerActionOrigin_Switch_ProGyro_Pitch = 226,
    k_EControllerActionOrigin_Switch_ProGyro_Yaw = 227,
    k_EControllerActionOrigin_Switch_ProGyro_Roll = 228,
    k_EControllerActionOrigin_Switch_RightGyro_Move = 229,
    k_EControllerActionOrigin_Switch_RightGyro_Pitch = 230,
    k_EControllerActionOrigin_Switch_RightGyro_Yaw = 231,
    k_EControllerActionOrigin_Switch_RightGyro_Roll = 232,
    k_EControllerActionOrigin_Switch_LeftGyro_Move = 233,
    k_EControllerActionOrigin_Switch_LeftGyro_Pitch = 234,
    k_EControllerActionOrigin_Switch_LeftGyro_Yaw = 235,
    k_EControllerActionOrigin_Switch_LeftGyro_Roll = 236,
    k_EControllerActionOrigin_Switch_LeftGrip_Lower = 237,
    k_EControllerActionOrigin_Switch_LeftGrip_Upper = 238,
    k_EControllerActionOrigin_Switch_RightGrip_Lower = 239,
    k_EControllerActionOrigin_Switch_RightGrip_Upper = 240,
    k_EControllerActionOrigin_PS4_DPad_Move = 241,
    k_EControllerActionOrigin_XBoxOne_DPad_Move = 242,
    k_EControllerActionOrigin_XBox360_DPad_Move = 243,
    k_EControllerActionOrigin_Switch_DPad_Move = 244,
    k_EControllerActionOrigin_PS5_X = 245,
    k_EControllerActionOrigin_PS5_Circle = 246,
    k_EControllerActionOrigin_PS5_Triangle = 247,
    k_EControllerActionOrigin_PS5_Square = 248,
    k_EControllerActionOrigin_PS5_LeftBumper = 249,
    k_EControllerActionOrigin_PS5_RightBumper = 250,
    k_EControllerActionOrigin_PS5_Option = 251,
    k_EControllerActionOrigin_PS5_Create = 252,
    k_EControllerActionOrigin_PS5_Mute = 253,
    k_EControllerActionOrigin_PS5_LeftPad_Touch = 254,
    k_EControllerActionOrigin_PS5_LeftPad_Swipe = 255,
    k_EControllerActionOrigin_PS5_LeftPad_Click = 256,
    k_EControllerActionOrigin_PS5_LeftPad_DPadNorth = 257,
    k_EControllerActionOrigin_PS5_LeftPad_DPadSouth = 258,
    k_EControllerActionOrigin_PS5_LeftPad_DPadWest = 259,
    k_EControllerActionOrigin_PS5_LeftPad_DPadEast = 260,
    k_EControllerActionOrigin_PS5_RightPad_Touch = 261,
    k_EControllerActionOrigin_PS5_RightPad_Swipe = 262,
    k_EControllerActionOrigin_PS5_RightPad_Click = 263,
    k_EControllerActionOrigin_PS5_RightPad_DPadNorth = 264,
    k_EControllerActionOrigin_PS5_RightPad_DPadSouth = 265,
    k_EControllerActionOrigin_PS5_RightPad_DPadWest = 266,
    k_EControllerActionOrigin_PS5_RightPad_DPadEast = 267,
    k_EControllerActionOrigin_PS5_CenterPad_Touch = 268,
    k_EControllerActionOrigin_PS5_CenterPad_Swipe = 269,
    k_EControllerActionOrigin_PS5_CenterPad_Click = 270,
    k_EControllerActionOrigin_PS5_CenterPad_DPadNorth = 271,
    k_EControllerActionOrigin_PS5_CenterPad_DPadSouth = 272,
    k_EControllerActionOrigin_PS5_CenterPad_DPadWest = 273,
    k_EControllerActionOrigin_PS5_CenterPad_DPadEast = 274,
    k_EControllerActionOrigin_PS5_LeftTrigger_Pull = 275,
    k_EControllerActionOrigin_PS5_LeftTrigger_Click = 276,
    k_EControllerActionOrigin_PS5_RightTrigger_Pull = 277,
    k_EControllerActionOrigin_PS5_RightTrigger_Click = 278,
    k_EControllerActionOrigin_PS5_LeftStick_Move = 279,
    k_EControllerActionOrigin_PS5_LeftStick_Click = 280,
    k_EControllerActionOrigin_PS5_LeftStick_DPadNorth = 281,
    k_EControllerActionOrigin_PS5_LeftStick_DPadSouth = 282,
    k_EControllerActionOrigin_PS5_LeftStick_DPadWest = 283,
    k_EControllerActionOrigin_PS5_LeftStick_DPadEast = 284,
    k_EControllerActionOrigin_PS5_RightStick_Move = 285,
    k_EControllerActionOrigin_PS5_RightStick_Click = 286,
    k_EControllerActionOrigin_PS5_RightStick_DPadNorth = 287,
    k_EControllerActionOrigin_PS5_RightStick_DPadSouth = 288,
    k_EControllerActionOrigin_PS5_RightStick_DPadWest = 289,
    k_EControllerActionOrigin_PS5_RightStick_DPadEast = 290,
    k_EControllerActionOrigin_PS5_DPad_Move = 291,
    k_EControllerActionOrigin_PS5_DPad_North = 292,
    k_EControllerActionOrigin_PS5_DPad_South = 293,
    k_EControllerActionOrigin_PS5_DPad_West = 294,
    k_EControllerActionOrigin_PS5_DPad_East = 295,
    k_EControllerActionOrigin_PS5_Gyro_Move = 296,
    k_EControllerActionOrigin_PS5_Gyro_Pitch = 297,
    k_EControllerActionOrigin_PS5_Gyro_Yaw = 298,
    k_EControllerActionOrigin_PS5_Gyro_Roll = 299,
    k_EControllerActionOrigin_XBoxOne_LeftGrip_Lower = 300,
    k_EControllerActionOrigin_XBoxOne_LeftGrip_Upper = 301,
    k_EControllerActionOrigin_XBoxOne_RightGrip_Lower = 302,
    k_EControllerActionOrigin_XBoxOne_RightGrip_Upper = 303,
    k_EControllerActionOrigin_XBoxOne_Share = 304,
    k_EControllerActionOrigin_SteamDeck_A = 305,
    k_EControllerActionOrigin_SteamDeck_B = 306,
    k_EControllerActionOrigin_SteamDeck_X = 307,
    k_EControllerActionOrigin_SteamDeck_Y = 308,
    k_EControllerActionOrigin_SteamDeck_L1 = 309,
    k_EControllerActionOrigin_SteamDeck_R1 = 310,
    k_EControllerActionOrigin_SteamDeck_Menu = 311,
    k_EControllerActionOrigin_SteamDeck_View = 312,
    k_EControllerActionOrigin_SteamDeck_LeftPad_Touch = 313,
    k_EControllerActionOrigin_SteamDeck_LeftPad_Swipe = 314,
    k_EControllerActionOrigin_SteamDeck_LeftPad_Click = 315,
    k_EControllerActionOrigin_SteamDeck_LeftPad_DPadNorth = 316,
    k_EControllerActionOrigin_SteamDeck_LeftPad_DPadSouth = 317,
    k_EControllerActionOrigin_SteamDeck_LeftPad_DPadWest = 318,
    k_EControllerActionOrigin_SteamDeck_LeftPad_DPadEast = 319,
    k_EControllerActionOrigin_SteamDeck_RightPad_Touch = 320,
    k_EControllerActionOrigin_SteamDeck_RightPad_Swipe = 321,
    k_EControllerActionOrigin_SteamDeck_RightPad_Click = 322,
    k_EControllerActionOrigin_SteamDeck_RightPad_DPadNorth = 323,
    k_EControllerActionOrigin_SteamDeck_RightPad_DPadSouth = 324,
    k_EControllerActionOrigin_SteamDeck_RightPad_DPadWest = 325,
    k_EControllerActionOrigin_SteamDeck_RightPad_DPadEast = 326,
    k_EControllerActionOrigin_SteamDeck_L2_SoftPull = 327,
    k_EControllerActionOrigin_SteamDeck_L2 = 328,
    k_EControllerActionOrigin_SteamDeck_R2_SoftPull = 329,
    k_EControllerActionOrigin_SteamDeck_R2 = 330,
    k_EControllerActionOrigin_SteamDeck_LeftStick_Move = 331,
    k_EControllerActionOrigin_SteamDeck_L3 = 332,
    k_EControllerActionOrigin_SteamDeck_LeftStick_DPadNorth = 333,
    k_EControllerActionOrigin_SteamDeck_LeftStick_DPadSouth = 334,
    k_EControllerActionOrigin_SteamDeck_LeftStick_DPadWest = 335,
    k_EControllerActionOrigin_SteamDeck_LeftStick_DPadEast = 336,
    k_EControllerActionOrigin_SteamDeck_LeftStick_Touch = 337,
    k_EControllerActionOrigin_SteamDeck_RightStick_Move = 338,
    k_EControllerActionOrigin_SteamDeck_R3 = 339,
    k_EControllerActionOrigin_SteamDeck_RightStick_DPadNorth = 340,
    k_EControllerActionOrigin_SteamDeck_RightStick_DPadSouth = 341,
    k_EControllerActionOrigin_SteamDeck_RightStick_DPadWest = 342,
    k_EControllerActionOrigin_SteamDeck_RightStick_DPadEast = 343,
    k_EControllerActionOrigin_SteamDeck_RightStick_Touch = 344,
    k_EControllerActionOrigin_SteamDeck_L4 = 345,
    k_EControllerActionOrigin_SteamDeck_R4 = 346,
    k_EControllerActionOrigin_SteamDeck_L5 = 347,
    k_EControllerActionOrigin_SteamDeck_R5 = 348,
    k_EControllerActionOrigin_SteamDeck_DPad_Move = 349,
    k_EControllerActionOrigin_SteamDeck_DPad_North = 350,
    k_EControllerActionOrigin_SteamDeck_DPad_South = 351,
    k_EControllerActionOrigin_SteamDeck_DPad_West = 352,
    k_EControllerActionOrigin_SteamDeck_DPad_East = 353,
    k_EControllerActionOrigin_SteamDeck_Gyro_Move = 354,
    k_EControllerActionOrigin_SteamDeck_Gyro_Pitch = 355,
    k_EControllerActionOrigin_SteamDeck_Gyro_Yaw = 356,
    k_EControllerActionOrigin_SteamDeck_Gyro_Roll = 357,
    k_EControllerActionOrigin_SteamDeck_Reserved1 = 358,
    k_EControllerActionOrigin_SteamDeck_Reserved2 = 359,
    k_EControllerActionOrigin_SteamDeck_Reserved3 = 360,
    k_EControllerActionOrigin_SteamDeck_Reserved4 = 361,
    k_EControllerActionOrigin_SteamDeck_Reserved5 = 362,
    k_EControllerActionOrigin_SteamDeck_Reserved6 = 363,
    k_EControllerActionOrigin_SteamDeck_Reserved7 = 364,
    k_EControllerActionOrigin_SteamDeck_Reserved8 = 365,
    k_EControllerActionOrigin_SteamDeck_Reserved9 = 366,
    k_EControllerActionOrigin_SteamDeck_Reserved10 = 367,
    k_EControllerActionOrigin_SteamDeck_Reserved11 = 368,
    k_EControllerActionOrigin_SteamDeck_Reserved12 = 369,
    k_EControllerActionOrigin_SteamDeck_Reserved13 = 370,
    k_EControllerActionOrigin_SteamDeck_Reserved14 = 371,
    k_EControllerActionOrigin_SteamDeck_Reserved15 = 372,
    k_EControllerActionOrigin_SteamDeck_Reserved16 = 373,
    k_EControllerActionOrigin_SteamDeck_Reserved17 = 374,
    k_EControllerActionOrigin_SteamDeck_Reserved18 = 375,
    k_EControllerActionOrigin_SteamDeck_Reserved19 = 376,
    k_EControllerActionOrigin_SteamDeck_Reserved20 = 377,
    k_EControllerActionOrigin_Switch_JoyConButton_N = 378,
    k_EControllerActionOrigin_Switch_JoyConButton_E = 379,
    k_EControllerActionOrigin_Switch_JoyConButton_S = 380,
    k_EControllerActionOrigin_Switch_JoyConButton_W = 381,
    k_EControllerActionOrigin_PS5_LeftGrip = 382,
    k_EControllerActionOrigin_PS5_RightGrip = 383,
    k_EControllerActionOrigin_PS5_LeftFn = 384,
    k_EControllerActionOrigin_PS5_RightFn = 385,
    k_EControllerActionOrigin_Horipad_M1 = 386,
    k_EControllerActionOrigin_Horipad_M2 = 387,
    k_EControllerActionOrigin_Horipad_L4 = 388,
    k_EControllerActionOrigin_Horipad_R4 = 389,
    k_EControllerActionOrigin_Count = 390,
    k_EControllerActionOrigin_MaximumPossibleValue = 32767,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamControllerLEDFlag {
    k_ESteamControllerLEDFlag_SetColor = 0,
    k_ESteamControllerLEDFlag_RestoreUserDefault = 1,
}
pub type ControllerHandle_t = uint64;
pub type ControllerActionSetHandle_t = uint64;
pub type ControllerDigitalActionHandle_t = uint64;
pub type ControllerAnalogActionHandle_t = uint64;
#[repr(C)]
pub struct ISteamController__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamController {
    pub vtable_: *const ISteamController__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamController() {
    assert_eq!(
        ::std::mem::size_of::<ISteamController>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamController))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamController>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamController))
    );
}
pub type UGCQueryHandle_t = uint64;
pub type UGCUpdateHandle_t = uint64;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EUGCMatchingUGCType {
    k_EUGCMatchingUGCType_Items = 0,
    k_EUGCMatchingUGCType_Items_Mtx = 1,
    k_EUGCMatchingUGCType_Items_ReadyToUse = 2,
    k_EUGCMatchingUGCType_Collections = 3,
    k_EUGCMatchingUGCType_Artwork = 4,
    k_EUGCMatchingUGCType_Videos = 5,
    k_EUGCMatchingUGCType_Screenshots = 6,
    k_EUGCMatchingUGCType_AllGuides = 7,
    k_EUGCMatchingUGCType_WebGuides = 8,
    k_EUGCMatchingUGCType_IntegratedGuides = 9,
    k_EUGCMatchingUGCType_UsableInGame = 10,
    k_EUGCMatchingUGCType_ControllerBindings = 11,
    k_EUGCMatchingUGCType_GameManagedItems = 12,
    k_EUGCMatchingUGCType_All = -1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EUserUGCList {
    k_EUserUGCList_Published = 0,
    k_EUserUGCList_VotedOn = 1,
    k_EUserUGCList_VotedUp = 2,
    k_EUserUGCList_VotedDown = 3,
    k_EUserUGCList_WillVoteLater = 4,
    k_EUserUGCList_Favorited = 5,
    k_EUserUGCList_Subscribed = 6,
    k_EUserUGCList_UsedOrPlayed = 7,
    k_EUserUGCList_Followed = 8,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EUserUGCListSortOrder {
    k_EUserUGCListSortOrder_CreationOrderDesc = 0,
    k_EUserUGCListSortOrder_CreationOrderAsc = 1,
    k_EUserUGCListSortOrder_TitleAsc = 2,
    k_EUserUGCListSortOrder_LastUpdatedDesc = 3,
    k_EUserUGCListSortOrder_SubscriptionDateDesc = 4,
    k_EUserUGCListSortOrder_VoteScoreDesc = 5,
    k_EUserUGCListSortOrder_ForModeration = 6,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EUGCQuery {
    k_EUGCQuery_RankedByVote = 0,
    k_EUGCQuery_RankedByPublicationDate = 1,
    k_EUGCQuery_AcceptedForGameRankedByAcceptanceDate = 2,
    k_EUGCQuery_RankedByTrend = 3,
    k_EUGCQuery_FavoritedByFriendsRankedByPublicationDate = 4,
    k_EUGCQuery_CreatedByFriendsRankedByPublicationDate = 5,
    k_EUGCQuery_RankedByNumTimesReported = 6,
    k_EUGCQuery_CreatedByFollowedUsersRankedByPublicationDate = 7,
    k_EUGCQuery_NotYetRated = 8,
    k_EUGCQuery_RankedByTotalVotesAsc = 9,
    k_EUGCQuery_RankedByVotesUp = 10,
    k_EUGCQuery_RankedByTextSearch = 11,
    k_EUGCQuery_RankedByTotalUniqueSubscriptions = 12,
    k_EUGCQuery_RankedByPlaytimeTrend = 13,
    k_EUGCQuery_RankedByTotalPlaytime = 14,
    k_EUGCQuery_RankedByAveragePlaytimeTrend = 15,
    k_EUGCQuery_RankedByLifetimeAveragePlaytime = 16,
    k_EUGCQuery_RankedByPlaytimeSessionsTrend = 17,
    k_EUGCQuery_RankedByLifetimePlaytimeSessions = 18,
    k_EUGCQuery_RankedByLastUpdatedDate = 19,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EItemUpdateStatus {
    k_EItemUpdateStatusInvalid = 0,
    k_EItemUpdateStatusPreparingConfig = 1,
    k_EItemUpdateStatusPreparingContent = 2,
    k_EItemUpdateStatusUploadingContent = 3,
    k_EItemUpdateStatusUploadingPreviewFile = 4,
    k_EItemUpdateStatusCommittingChanges = 5,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EItemStatistic {
    k_EItemStatistic_NumSubscriptions = 0,
    k_EItemStatistic_NumFavorites = 1,
    k_EItemStatistic_NumFollowers = 2,
    k_EItemStatistic_NumUniqueSubscriptions = 3,
    k_EItemStatistic_NumUniqueFavorites = 4,
    k_EItemStatistic_NumUniqueFollowers = 5,
    k_EItemStatistic_NumUniqueWebsiteViews = 6,
    k_EItemStatistic_ReportScore = 7,
    k_EItemStatistic_NumSecondsPlayed = 8,
    k_EItemStatistic_NumPlaytimeSessions = 9,
    k_EItemStatistic_NumComments = 10,
    k_EItemStatistic_NumSecondsPlayedDuringTimePeriod = 11,
    k_EItemStatistic_NumPlaytimeSessionsDuringTimePeriod = 12,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EItemPreviewType {
    k_EItemPreviewType_Image = 0,
    k_EItemPreviewType_YouTubeVideo = 1,
    k_EItemPreviewType_Sketchfab = 2,
    k_EItemPreviewType_EnvironmentMap_HorizontalCross = 3,
    k_EItemPreviewType_EnvironmentMap_LatLong = 4,
    k_EItemPreviewType_Clip = 5,
    k_EItemPreviewType_ReservedMax = 255,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EUGCContentDescriptorID {
    k_EUGCContentDescriptor_NudityOrSexualContent = 1,
    k_EUGCContentDescriptor_FrequentViolenceOrGore = 2,
    k_EUGCContentDescriptor_AdultOnlySexualContent = 3,
    k_EUGCContentDescriptor_GratuitousSexualContent = 4,
    k_EUGCContentDescriptor_AnyMatureContent = 5,
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct SteamUGCDetails_t {
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_eResult: EResult,
    pub m_eFileType: EWorkshopFileType,
    pub m_nCreatorAppID: AppId_t,
    pub m_nConsumerAppID: AppId_t,
    pub m_rgchTitle: [::std::os::raw::c_char; 129usize],
    pub m_rgchDescription: [::std::os::raw::c_char; 8000usize],
    pub m_ulSteamIDOwner: uint64,
    pub m_rtimeCreated: uint32,
    pub m_rtimeUpdated: uint32,
    pub m_rtimeAddedToUserList: uint32,
    pub m_eVisibility: ERemoteStoragePublishedFileVisibility,
    pub m_bBanned: bool,
    pub m_bAcceptedForUse: bool,
    pub m_bTagsTruncated: bool,
    pub m_rgchTags: [::std::os::raw::c_char; 1025usize],
    pub m_hFile: UGCHandle_t,
    pub m_hPreviewFile: UGCHandle_t,
    pub m_pchFileName: [::std::os::raw::c_char; 260usize],
    pub m_nFileSize: int32,
    pub m_nPreviewFileSize: int32,
    pub m_rgchURL: [::std::os::raw::c_char; 256usize],
    pub m_unVotesUp: uint32,
    pub m_unVotesDown: uint32,
    pub m_flScore: f32,
    pub m_unNumChildren: uint32,
    pub m_ulTotalFilesSize: uint64,
}
#[test]
fn bindgen_test_layout_SteamUGCDetails_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamUGCDetails_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamUGCDetails_t>(),
        9772usize,
        concat!("Size of: ", stringify!(SteamUGCDetails_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamUGCDetails_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamUGCDetails_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eFileType) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_eFileType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nCreatorAppID) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_nCreatorAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nConsumerAppID) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_nConsumerAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchTitle) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_rgchTitle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchDescription) as usize - ptr as usize },
        153usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_rgchDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDOwner) as usize - ptr as usize },
        8156usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_ulSteamIDOwner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rtimeCreated) as usize - ptr as usize },
        8164usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_rtimeCreated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rtimeUpdated) as usize - ptr as usize },
        8168usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_rtimeUpdated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rtimeAddedToUserList) as usize - ptr as usize },
        8172usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_rtimeAddedToUserList)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eVisibility) as usize - ptr as usize },
        8176usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_eVisibility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bBanned) as usize - ptr as usize },
        8180usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_bBanned)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bAcceptedForUse) as usize - ptr as usize },
        8181usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_bAcceptedForUse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bTagsTruncated) as usize - ptr as usize },
        8182usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_bTagsTruncated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchTags) as usize - ptr as usize },
        8183usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_rgchTags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hFile) as usize - ptr as usize },
        9208usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_hFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hPreviewFile) as usize - ptr as usize },
        9216usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_hPreviewFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pchFileName) as usize - ptr as usize },
        9224usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_pchFileName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nFileSize) as usize - ptr as usize },
        9484usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_nFileSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPreviewFileSize) as usize - ptr as usize },
        9488usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_nPreviewFileSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchURL) as usize - ptr as usize },
        9492usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_rgchURL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unVotesUp) as usize - ptr as usize },
        9748usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_unVotesUp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unVotesDown) as usize - ptr as usize },
        9752usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_unVotesDown)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_flScore) as usize - ptr as usize },
        9756usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_flScore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unNumChildren) as usize - ptr as usize },
        9760usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_unNumChildren)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulTotalFilesSize) as usize - ptr as usize },
        9764usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_ulTotalFilesSize)
        )
    );
}
#[repr(C)]
pub struct ISteamUGC__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamUGC {
    pub vtable_: *const ISteamUGC__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamUGC() {
    assert_eq!(
        ::std::mem::size_of::<ISteamUGC>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamUGC))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamUGC>(),
        4usize,
        concat!("Alignment of ", stringify!(ISteamUGC))
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct SteamUGCQueryCompleted_t {
    pub m_handle: UGCQueryHandle_t,
    pub m_eResult: EResult,
    pub m_unNumResultsReturned: uint32,
    pub m_unTotalMatchingResults: uint32,
    pub m_bCachedData: bool,
    pub m_rgchNextCursor: [::std::os::raw::c_char; 256usize],
}
pub const SteamUGCQueryCompleted_t_k_iCallback: SteamUGCQueryCompleted_t__bindgen_ty_1 =
    SteamUGCQueryCompleted_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamUGCQueryCompleted_t__bindgen_ty_1 {
    k_iCallback = 3401,
}
#[test]
fn bindgen_test_layout_SteamUGCQueryCompleted_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamUGCQueryCompleted_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamUGCQueryCompleted_t>(),
        280usize,
        concat!("Size of: ", stringify!(SteamUGCQueryCompleted_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamUGCQueryCompleted_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamUGCQueryCompleted_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCQueryCompleted_t),
            "::",
            stringify!(m_handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCQueryCompleted_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unNumResultsReturned) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCQueryCompleted_t),
            "::",
            stringify!(m_unNumResultsReturned)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unTotalMatchingResults) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCQueryCompleted_t),
            "::",
            stringify!(m_unTotalMatchingResults)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bCachedData) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCQueryCompleted_t),
            "::",
            stringify!(m_bCachedData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchNextCursor) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCQueryCompleted_t),
            "::",
            stringify!(m_rgchNextCursor)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamUGCRequestUGCDetailsResult_t {
    pub m_details: SteamUGCDetails_t,
    pub m_bCachedData: bool,
}
pub const SteamUGCRequestUGCDetailsResult_t_k_iCallback:
    SteamUGCRequestUGCDetailsResult_t__bindgen_ty_1 =
    SteamUGCRequestUGCDetailsResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamUGCRequestUGCDetailsResult_t__bindgen_ty_1 {
    k_iCallback = 3402,
}
#[test]
fn bindgen_test_layout_SteamUGCRequestUGCDetailsResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamUGCRequestUGCDetailsResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamUGCRequestUGCDetailsResult_t>(),
        9776usize,
        concat!("Size of: ", stringify!(SteamUGCRequestUGCDetailsResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamUGCRequestUGCDetailsResult_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SteamUGCRequestUGCDetailsResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_details) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCRequestUGCDetailsResult_t),
            "::",
            stringify!(m_details)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bCachedData) as usize - ptr as usize },
        9772usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCRequestUGCDetailsResult_t),
            "::",
            stringify!(m_bCachedData)
        )
    );
}
pub type HHTMLBrowser = uint32;
#[repr(C)]
pub struct ISteamHTMLSurface__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct ISteamHTMLSurface {
    pub vtable_: *const ISteamHTMLSurface__bindgen_vtable,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ISteamHTMLSurface_EHTMLMouseButton {
    eHTMLMouseButton_Left = 0,
    eHTMLMouseButton_Right = 1,
    eHTMLMouseButton_Middle = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ISteamHTMLSurface_EHTMLMouseCursor {
    k_EHTMLMouseCursor_User = 0,
    k_EHTMLMouseCursor_None = 1,
    k_EHTMLMouseCursor_Arrow = 2,
    k_EHTMLMouseCursor_IBeam = 3,
    k_EHTMLMouseCursor_Hourglass = 4,
    k_EHTMLMouseCursor_WaitArrow = 5,
    k_EHTMLMouseCursor_Crosshair = 6,
    k_EHTMLMouseCursor_Up = 7,
    k_EHTMLMouseCursor_SizeNW = 8,
    k_EHTMLMouseCursor_SizeSE = 9,
    k_EHTMLMouseCursor_SizeNE = 10,
    k_EHTMLMouseCursor_SizeSW = 11,
    k_EHTMLMouseCursor_SizeW = 12,
    k_EHTMLMouseCursor_SizeE = 13,
    k_EHTMLMouseCursor_SizeN = 14,
    k_EHTMLMouseCursor_SizeS = 15,
    k_EHTMLMouseCursor_SizeWE = 16,
    k_EHTMLMouseCursor_SizeNS = 17,
    k_EHTMLMouseCursor_SizeAll = 18,
    k_EHTMLMouseCursor_No = 19,
    k_EHTMLMouseCursor_Hand = 20,
    k_EHTMLMouseCursor_Blank = 21,
    k_EHTMLMouseCursor_MiddlePan = 22,
    k_EHTMLMouseCursor_NorthPan = 23,
    k_EHTMLMouseCursor_NorthEastPan = 24,
    k_EHTMLMouseCursor_EastPan = 25,
    k_EHTMLMouseCursor_SouthEastPan = 26,
    k_EHTMLMouseCursor_SouthPan = 27,
    k_EHTMLMouseCursor_SouthWestPan = 28,
    k_EHTMLMouseCursor_WestPan = 29,
    k_EHTMLMouseCursor_NorthWestPan = 30,
    k_EHTMLMouseCursor_Alias = 31,
    k_EHTMLMouseCursor_Cell = 32,
    k_EHTMLMouseCursor_ColResize = 33,
    k_EHTMLMouseCursor_CopyCur = 34,
    k_EHTMLMouseCursor_VerticalText = 35,
    k_EHTMLMouseCursor_RowResize = 36,
    k_EHTMLMouseCursor_ZoomIn = 37,
    k_EHTMLMouseCursor_ZoomOut = 38,
    k_EHTMLMouseCursor_Help = 39,
    k_EHTMLMouseCursor_Custom = 40,
    k_EHTMLMouseCursor_SizeNWSE = 41,
    k_EHTMLMouseCursor_SizeNESW = 42,
    k_EHTMLMouseCursor_last = 43,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ISteamHTMLSurface_EHTMLKeyModifiers {
    k_eHTMLKeyModifier_None = 0,
    k_eHTMLKeyModifier_AltDown = 1,
    k_eHTMLKeyModifier_CtrlDown = 2,
    k_eHTMLKeyModifier_ShiftDown = 4,
}
#[test]
fn bindgen_test_layout_ISteamHTMLSurface() {
    assert_eq!(
        ::std::mem::size_of::<ISteamHTMLSurface>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamHTMLSurface))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamHTMLSurface>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamHTMLSurface))
    );
}
pub type SteamItemInstanceID_t = uint64;
extern "C" {
    #[link_name = "\u{1}__ZL28k_SteamItemInstanceIDInvalid"]
    pub static k_SteamItemInstanceIDInvalid: SteamItemInstanceID_t;
}
pub type SteamItemDef_t = int32;
impl ESteamItemFlags {
    pub const k_ESteamItemNoTrade: ESteamItemFlags = ESteamItemFlags(1);
}
impl ESteamItemFlags {
    pub const k_ESteamItemRemoved: ESteamItemFlags = ESteamItemFlags(256);
}
impl ESteamItemFlags {
    pub const k_ESteamItemConsumed: ESteamItemFlags = ESteamItemFlags(512);
}
impl ::std::ops::BitOr<ESteamItemFlags> for ESteamItemFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ESteamItemFlags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ESteamItemFlags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ESteamItemFlags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ESteamItemFlags> for ESteamItemFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ESteamItemFlags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ESteamItemFlags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ESteamItemFlags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ESteamItemFlags(pub ::std::os::raw::c_uint);
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct SteamItemDetails_t {
    pub m_itemId: SteamItemInstanceID_t,
    pub m_iDefinition: SteamItemDef_t,
    pub m_unQuantity: uint16,
    pub m_unFlags: uint16,
}
#[test]
fn bindgen_test_layout_SteamItemDetails_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamItemDetails_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamItemDetails_t>(),
        16usize,
        concat!("Size of: ", stringify!(SteamItemDetails_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamItemDetails_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamItemDetails_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_itemId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamItemDetails_t),
            "::",
            stringify!(m_itemId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_iDefinition) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamItemDetails_t),
            "::",
            stringify!(m_iDefinition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unQuantity) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamItemDetails_t),
            "::",
            stringify!(m_unQuantity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unFlags) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamItemDetails_t),
            "::",
            stringify!(m_unFlags)
        )
    );
}
pub type SteamInventoryResult_t = int32;
pub const k_SteamInventoryResultInvalid: SteamInventoryResult_t = -1;
pub type SteamInventoryUpdateHandle_t = uint64;
pub const k_SteamInventoryUpdateHandleInvalid: SteamInventoryUpdateHandle_t = 18446744073709551615;
#[repr(C)]
pub struct ISteamInventory__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamInventory {
    pub vtable_: *const ISteamInventory__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamInventory() {
    assert_eq!(
        ::std::mem::size_of::<ISteamInventory>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamInventory))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamInventory>(),
        4usize,
        concat!("Alignment of ", stringify!(ISteamInventory))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamInventoryResultReady_t {
    pub m_handle: SteamInventoryResult_t,
    pub m_result: EResult,
}
pub const SteamInventoryResultReady_t_k_iCallback: SteamInventoryResultReady_t__bindgen_ty_1 =
    SteamInventoryResultReady_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamInventoryResultReady_t__bindgen_ty_1 {
    k_iCallback = 4700,
}
#[test]
fn bindgen_test_layout_SteamInventoryResultReady_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInventoryResultReady_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInventoryResultReady_t>(),
        8usize,
        concat!("Size of: ", stringify!(SteamInventoryResultReady_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInventoryResultReady_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamInventoryResultReady_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInventoryResultReady_t),
            "::",
            stringify!(m_handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_result) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInventoryResultReady_t),
            "::",
            stringify!(m_result)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamInventoryFullUpdate_t {
    pub m_handle: SteamInventoryResult_t,
}
pub const SteamInventoryFullUpdate_t_k_iCallback: SteamInventoryFullUpdate_t__bindgen_ty_1 =
    SteamInventoryFullUpdate_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamInventoryFullUpdate_t__bindgen_ty_1 {
    k_iCallback = 4701,
}
#[test]
fn bindgen_test_layout_SteamInventoryFullUpdate_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInventoryFullUpdate_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInventoryFullUpdate_t>(),
        4usize,
        concat!("Size of: ", stringify!(SteamInventoryFullUpdate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInventoryFullUpdate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamInventoryFullUpdate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInventoryFullUpdate_t),
            "::",
            stringify!(m_handle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamInventoryDefinitionUpdate_t {
    pub _address: u8,
}
pub const SteamInventoryDefinitionUpdate_t_k_iCallback:
    SteamInventoryDefinitionUpdate_t__bindgen_ty_1 =
    SteamInventoryDefinitionUpdate_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamInventoryDefinitionUpdate_t__bindgen_ty_1 {
    k_iCallback = 4702,
}
#[test]
fn bindgen_test_layout_SteamInventoryDefinitionUpdate_t() {
    assert_eq!(
        ::std::mem::size_of::<SteamInventoryDefinitionUpdate_t>(),
        1usize,
        concat!("Size of: ", stringify!(SteamInventoryDefinitionUpdate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInventoryDefinitionUpdate_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SteamInventoryDefinitionUpdate_t)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SteamInventoryEligiblePromoItemDefIDs_t {
    pub m_result: EResult,
    pub m_steamID: CSteamID,
    pub m_numEligiblePromoItemDefs: ::std::os::raw::c_int,
    pub m_bCachedData: bool,
}
pub const SteamInventoryEligiblePromoItemDefIDs_t_k_iCallback:
    SteamInventoryEligiblePromoItemDefIDs_t__bindgen_ty_1 =
    SteamInventoryEligiblePromoItemDefIDs_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamInventoryEligiblePromoItemDefIDs_t__bindgen_ty_1 {
    k_iCallback = 4703,
}
#[test]
fn bindgen_test_layout_SteamInventoryEligiblePromoItemDefIDs_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInventoryEligiblePromoItemDefIDs_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInventoryEligiblePromoItemDefIDs_t>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(SteamInventoryEligiblePromoItemDefIDs_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInventoryEligiblePromoItemDefIDs_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SteamInventoryEligiblePromoItemDefIDs_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_result) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInventoryEligiblePromoItemDefIDs_t),
            "::",
            stringify!(m_result)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInventoryEligiblePromoItemDefIDs_t),
            "::",
            stringify!(m_steamID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_numEligiblePromoItemDefs) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInventoryEligiblePromoItemDefIDs_t),
            "::",
            stringify!(m_numEligiblePromoItemDefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bCachedData) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInventoryEligiblePromoItemDefIDs_t),
            "::",
            stringify!(m_bCachedData)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct SteamInventoryStartPurchaseResult_t {
    pub m_result: EResult,
    pub m_ulOrderID: uint64,
    pub m_ulTransID: uint64,
}
pub const SteamInventoryStartPurchaseResult_t_k_iCallback:
    SteamInventoryStartPurchaseResult_t__bindgen_ty_1 =
    SteamInventoryStartPurchaseResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamInventoryStartPurchaseResult_t__bindgen_ty_1 {
    k_iCallback = 4704,
}
#[test]
fn bindgen_test_layout_SteamInventoryStartPurchaseResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInventoryStartPurchaseResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInventoryStartPurchaseResult_t>(),
        20usize,
        concat!("Size of: ", stringify!(SteamInventoryStartPurchaseResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInventoryStartPurchaseResult_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SteamInventoryStartPurchaseResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_result) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInventoryStartPurchaseResult_t),
            "::",
            stringify!(m_result)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulOrderID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInventoryStartPurchaseResult_t),
            "::",
            stringify!(m_ulOrderID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulTransID) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInventoryStartPurchaseResult_t),
            "::",
            stringify!(m_ulTransID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamInventoryRequestPricesResult_t {
    pub m_result: EResult,
    pub m_rgchCurrency: [::std::os::raw::c_char; 4usize],
}
pub const SteamInventoryRequestPricesResult_t_k_iCallback:
    SteamInventoryRequestPricesResult_t__bindgen_ty_1 =
    SteamInventoryRequestPricesResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamInventoryRequestPricesResult_t__bindgen_ty_1 {
    k_iCallback = 4705,
}
#[test]
fn bindgen_test_layout_SteamInventoryRequestPricesResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInventoryRequestPricesResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInventoryRequestPricesResult_t>(),
        8usize,
        concat!("Size of: ", stringify!(SteamInventoryRequestPricesResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInventoryRequestPricesResult_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SteamInventoryRequestPricesResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_result) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInventoryRequestPricesResult_t),
            "::",
            stringify!(m_result)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchCurrency) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInventoryRequestPricesResult_t),
            "::",
            stringify!(m_rgchCurrency)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ETimelineGameMode {
    k_ETimelineGameMode_Invalid = 0,
    k_ETimelineGameMode_Playing = 1,
    k_ETimelineGameMode_Staging = 2,
    k_ETimelineGameMode_Menus = 3,
    k_ETimelineGameMode_LoadingScreen = 4,
    k_ETimelineGameMode_Max = 5,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ETimelineEventClipPriority {
    k_ETimelineEventClipPriority_Invalid = 0,
    k_ETimelineEventClipPriority_None = 1,
    k_ETimelineEventClipPriority_Standard = 2,
    k_ETimelineEventClipPriority_Featured = 3,
}
pub type TimelineEventHandle_t = uint64;
#[repr(C)]
pub struct ISteamTimeline__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamTimeline {
    pub vtable_: *const ISteamTimeline__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamTimeline() {
    assert_eq!(
        ::std::mem::size_of::<ISteamTimeline>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamTimeline))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamTimeline>(),
        4usize,
        concat!("Alignment of ", stringify!(ISteamTimeline))
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct SteamTimelineGamePhaseRecordingExists_t {
    pub m_rgchPhaseID: [::std::os::raw::c_char; 64usize],
    pub m_ulRecordingMS: uint64,
    pub m_ulLongestClipMS: uint64,
    pub m_unClipCount: uint32,
    pub m_unScreenshotCount: uint32,
}
pub const SteamTimelineGamePhaseRecordingExists_t_k_iCallback:
    SteamTimelineGamePhaseRecordingExists_t__bindgen_ty_1 =
    SteamTimelineGamePhaseRecordingExists_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamTimelineGamePhaseRecordingExists_t__bindgen_ty_1 {
    k_iCallback = 6001,
}
#[test]
fn bindgen_test_layout_SteamTimelineGamePhaseRecordingExists_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamTimelineGamePhaseRecordingExists_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamTimelineGamePhaseRecordingExists_t>(),
        88usize,
        concat!(
            "Size of: ",
            stringify!(SteamTimelineGamePhaseRecordingExists_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamTimelineGamePhaseRecordingExists_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SteamTimelineGamePhaseRecordingExists_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchPhaseID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamTimelineGamePhaseRecordingExists_t),
            "::",
            stringify!(m_rgchPhaseID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulRecordingMS) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamTimelineGamePhaseRecordingExists_t),
            "::",
            stringify!(m_ulRecordingMS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulLongestClipMS) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamTimelineGamePhaseRecordingExists_t),
            "::",
            stringify!(m_ulLongestClipMS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unClipCount) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamTimelineGamePhaseRecordingExists_t),
            "::",
            stringify!(m_unClipCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unScreenshotCount) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamTimelineGamePhaseRecordingExists_t),
            "::",
            stringify!(m_unScreenshotCount)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct SteamTimelineEventRecordingExists_t {
    pub m_ulEventID: uint64,
    pub m_bRecordingExists: bool,
}
pub const SteamTimelineEventRecordingExists_t_k_iCallback:
    SteamTimelineEventRecordingExists_t__bindgen_ty_1 =
    SteamTimelineEventRecordingExists_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamTimelineEventRecordingExists_t__bindgen_ty_1 {
    k_iCallback = 6002,
}
#[test]
fn bindgen_test_layout_SteamTimelineEventRecordingExists_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamTimelineEventRecordingExists_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamTimelineEventRecordingExists_t>(),
        12usize,
        concat!("Size of: ", stringify!(SteamTimelineEventRecordingExists_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamTimelineEventRecordingExists_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SteamTimelineEventRecordingExists_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulEventID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamTimelineEventRecordingExists_t),
            "::",
            stringify!(m_ulEventID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bRecordingExists) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamTimelineEventRecordingExists_t),
            "::",
            stringify!(m_bRecordingExists)
        )
    );
}
#[repr(C)]
pub struct ISteamVideo__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamVideo {
    pub vtable_: *const ISteamVideo__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamVideo() {
    assert_eq!(
        ::std::mem::size_of::<ISteamVideo>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamVideo))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamVideo>(),
        4usize,
        concat!("Alignment of ", stringify!(ISteamVideo))
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EParentalFeature {
    k_EFeatureInvalid = 0,
    k_EFeatureStore = 1,
    k_EFeatureCommunity = 2,
    k_EFeatureProfile = 3,
    k_EFeatureFriends = 4,
    k_EFeatureNews = 5,
    k_EFeatureTrading = 6,
    k_EFeatureSettings = 7,
    k_EFeatureConsole = 8,
    k_EFeatureBrowser = 9,
    k_EFeatureParentalSetup = 10,
    k_EFeatureLibrary = 11,
    k_EFeatureTest = 12,
    k_EFeatureSiteLicense = 13,
    k_EFeatureKioskMode_Deprecated = 14,
    k_EFeatureBlockAlways = 15,
    k_EFeatureMax = 16,
}
#[repr(C)]
pub struct ISteamParentalSettings__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamParentalSettings {
    pub vtable_: *const ISteamParentalSettings__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamParentalSettings() {
    assert_eq!(
        ::std::mem::size_of::<ISteamParentalSettings>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamParentalSettings))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamParentalSettings>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamParentalSettings))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamParentalSettingsChanged_t {
    pub _address: u8,
}
pub const SteamParentalSettingsChanged_t_k_iCallback: SteamParentalSettingsChanged_t__bindgen_ty_1 =
    SteamParentalSettingsChanged_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamParentalSettingsChanged_t__bindgen_ty_1 {
    k_iCallback = 5001,
}
#[test]
fn bindgen_test_layout_SteamParentalSettingsChanged_t() {
    assert_eq!(
        ::std::mem::size_of::<SteamParentalSettingsChanged_t>(),
        1usize,
        concat!("Size of: ", stringify!(SteamParentalSettingsChanged_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamParentalSettingsChanged_t>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamParentalSettingsChanged_t))
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamDeviceFormFactor {
    k_ESteamDeviceFormFactorUnknown = 0,
    k_ESteamDeviceFormFactorPhone = 1,
    k_ESteamDeviceFormFactorTablet = 2,
    k_ESteamDeviceFormFactorComputer = 3,
    k_ESteamDeviceFormFactorTV = 4,
    k_ESteamDeviceFormFactorVRHeadset = 5,
}
pub type RemotePlaySessionID_t = uint32;
pub type RemotePlayCursorID_t = uint32;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ERemotePlayInputType {
    k_ERemotePlayInputUnknown = 0,
    k_ERemotePlayInputMouseMotion = 1,
    k_ERemotePlayInputMouseButtonDown = 2,
    k_ERemotePlayInputMouseButtonUp = 3,
    k_ERemotePlayInputMouseWheel = 4,
    k_ERemotePlayInputKeyDown = 5,
    k_ERemotePlayInputKeyUp = 6,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ERemotePlayMouseButton {
    k_ERemotePlayMouseButtonLeft = 1,
    k_ERemotePlayMouseButtonRight = 2,
    k_ERemotePlayMouseButtonMiddle = 16,
    k_ERemotePlayMouseButtonX1 = 32,
    k_ERemotePlayMouseButtonX2 = 64,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ERemotePlayMouseWheelDirection {
    k_ERemotePlayMouseWheelUp = 1,
    k_ERemotePlayMouseWheelDown = 2,
    k_ERemotePlayMouseWheelLeft = 3,
    k_ERemotePlayMouseWheelRight = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RemotePlayInputMouseMotion_t {
    pub m_bAbsolute: bool,
    pub m_flNormalizedX: f32,
    pub m_flNormalizedY: f32,
    pub m_nDeltaX: ::std::os::raw::c_int,
    pub m_nDeltaY: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_RemotePlayInputMouseMotion_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemotePlayInputMouseMotion_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemotePlayInputMouseMotion_t>(),
        20usize,
        concat!("Size of: ", stringify!(RemotePlayInputMouseMotion_t))
    );
    assert_eq!(
        ::std::mem::align_of::<RemotePlayInputMouseMotion_t>(),
        4usize,
        concat!("Alignment of ", stringify!(RemotePlayInputMouseMotion_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bAbsolute) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemotePlayInputMouseMotion_t),
            "::",
            stringify!(m_bAbsolute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_flNormalizedX) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RemotePlayInputMouseMotion_t),
            "::",
            stringify!(m_flNormalizedX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_flNormalizedY) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemotePlayInputMouseMotion_t),
            "::",
            stringify!(m_flNormalizedY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nDeltaX) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RemotePlayInputMouseMotion_t),
            "::",
            stringify!(m_nDeltaX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nDeltaY) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RemotePlayInputMouseMotion_t),
            "::",
            stringify!(m_nDeltaY)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RemotePlayInputMouseWheel_t {
    pub m_eDirection: ERemotePlayMouseWheelDirection,
    pub m_flAmount: f32,
}
#[test]
fn bindgen_test_layout_RemotePlayInputMouseWheel_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemotePlayInputMouseWheel_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemotePlayInputMouseWheel_t>(),
        8usize,
        concat!("Size of: ", stringify!(RemotePlayInputMouseWheel_t))
    );
    assert_eq!(
        ::std::mem::align_of::<RemotePlayInputMouseWheel_t>(),
        4usize,
        concat!("Alignment of ", stringify!(RemotePlayInputMouseWheel_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eDirection) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemotePlayInputMouseWheel_t),
            "::",
            stringify!(m_eDirection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_flAmount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RemotePlayInputMouseWheel_t),
            "::",
            stringify!(m_flAmount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RemotePlayInputKey_t {
    pub m_eScancode: ::std::os::raw::c_int,
    pub m_unModifiers: uint32,
    pub m_unKeycode: uint32,
}
#[test]
fn bindgen_test_layout_RemotePlayInputKey_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemotePlayInputKey_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemotePlayInputKey_t>(),
        12usize,
        concat!("Size of: ", stringify!(RemotePlayInputKey_t))
    );
    assert_eq!(
        ::std::mem::align_of::<RemotePlayInputKey_t>(),
        4usize,
        concat!("Alignment of ", stringify!(RemotePlayInputKey_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eScancode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemotePlayInputKey_t),
            "::",
            stringify!(m_eScancode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unModifiers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RemotePlayInputKey_t),
            "::",
            stringify!(m_unModifiers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unKeycode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemotePlayInputKey_t),
            "::",
            stringify!(m_unKeycode)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RemotePlayInput_t {
    pub m_unSessionID: RemotePlaySessionID_t,
    pub m_eType: ERemotePlayInputType,
    pub __bindgen_anon_1: RemotePlayInput_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RemotePlayInput_t__bindgen_ty_1 {
    pub m_MouseMotion: RemotePlayInputMouseMotion_t,
    pub m_eMouseButton: ERemotePlayMouseButton,
    pub m_MouseWheel: RemotePlayInputMouseWheel_t,
    pub m_Key: RemotePlayInputKey_t,
    pub padding: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout_RemotePlayInput_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<RemotePlayInput_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemotePlayInput_t__bindgen_ty_1>(),
        56usize,
        concat!("Size of: ", stringify!(RemotePlayInput_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<RemotePlayInput_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(RemotePlayInput_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_MouseMotion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemotePlayInput_t__bindgen_ty_1),
            "::",
            stringify!(m_MouseMotion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eMouseButton) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemotePlayInput_t__bindgen_ty_1),
            "::",
            stringify!(m_eMouseButton)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_MouseWheel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemotePlayInput_t__bindgen_ty_1),
            "::",
            stringify!(m_MouseWheel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_Key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemotePlayInput_t__bindgen_ty_1),
            "::",
            stringify!(m_Key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemotePlayInput_t__bindgen_ty_1),
            "::",
            stringify!(padding)
        )
    );
}
#[test]
fn bindgen_test_layout_RemotePlayInput_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemotePlayInput_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemotePlayInput_t>(),
        64usize,
        concat!("Size of: ", stringify!(RemotePlayInput_t))
    );
    assert_eq!(
        ::std::mem::align_of::<RemotePlayInput_t>(),
        4usize,
        concat!("Alignment of ", stringify!(RemotePlayInput_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unSessionID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemotePlayInput_t),
            "::",
            stringify!(m_unSessionID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eType) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RemotePlayInput_t),
            "::",
            stringify!(m_eType)
        )
    );
}
#[repr(C)]
pub struct ISteamRemotePlay__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamRemotePlay {
    pub vtable_: *const ISteamRemotePlay__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamRemotePlay() {
    assert_eq!(
        ::std::mem::size_of::<ISteamRemotePlay>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamRemotePlay))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamRemotePlay>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamRemotePlay))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamRemotePlaySessionConnected_t {
    pub m_unSessionID: RemotePlaySessionID_t,
}
pub const SteamRemotePlaySessionConnected_t_k_iCallback:
    SteamRemotePlaySessionConnected_t__bindgen_ty_1 =
    SteamRemotePlaySessionConnected_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamRemotePlaySessionConnected_t__bindgen_ty_1 {
    k_iCallback = 5701,
}
#[test]
fn bindgen_test_layout_SteamRemotePlaySessionConnected_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamRemotePlaySessionConnected_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamRemotePlaySessionConnected_t>(),
        4usize,
        concat!("Size of: ", stringify!(SteamRemotePlaySessionConnected_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamRemotePlaySessionConnected_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SteamRemotePlaySessionConnected_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unSessionID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamRemotePlaySessionConnected_t),
            "::",
            stringify!(m_unSessionID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamRemotePlaySessionDisconnected_t {
    pub m_unSessionID: RemotePlaySessionID_t,
}
pub const SteamRemotePlaySessionDisconnected_t_k_iCallback:
    SteamRemotePlaySessionDisconnected_t__bindgen_ty_1 =
    SteamRemotePlaySessionDisconnected_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamRemotePlaySessionDisconnected_t__bindgen_ty_1 {
    k_iCallback = 5702,
}
#[test]
fn bindgen_test_layout_SteamRemotePlaySessionDisconnected_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamRemotePlaySessionDisconnected_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamRemotePlaySessionDisconnected_t>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(SteamRemotePlaySessionDisconnected_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamRemotePlaySessionDisconnected_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SteamRemotePlaySessionDisconnected_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unSessionID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamRemotePlaySessionDisconnected_t),
            "::",
            stringify!(m_unSessionID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamRemotePlayTogetherGuestInvite_t {
    pub m_szConnectURL: [::std::os::raw::c_char; 1024usize],
}
pub const SteamRemotePlayTogetherGuestInvite_t_k_iCallback:
    SteamRemotePlayTogetherGuestInvite_t__bindgen_ty_1 =
    SteamRemotePlayTogetherGuestInvite_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamRemotePlayTogetherGuestInvite_t__bindgen_ty_1 {
    k_iCallback = 5703,
}
#[test]
fn bindgen_test_layout_SteamRemotePlayTogetherGuestInvite_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamRemotePlayTogetherGuestInvite_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamRemotePlayTogetherGuestInvite_t>(),
        1024usize,
        concat!(
            "Size of: ",
            stringify!(SteamRemotePlayTogetherGuestInvite_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamRemotePlayTogetherGuestInvite_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SteamRemotePlayTogetherGuestInvite_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szConnectURL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamRemotePlayTogetherGuestInvite_t),
            "::",
            stringify!(m_szConnectURL)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamDatagramRelayAuthTicket {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamDatagramHostedAddress {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamDatagramGameCoordinatorServerLogin {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamNetworkingFakeIPResult_t {
    _unused: [u8; 0],
}
pub type FnSteamNetConnectionStatusChanged = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut SteamNetConnectionStatusChangedCallback_t),
>;
pub type FnSteamNetAuthenticationStatusChanged =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut SteamNetAuthenticationStatus_t)>;
pub type FnSteamRelayNetworkStatusChanged =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut SteamRelayNetworkStatus_t)>;
pub type FnSteamNetworkingMessagesSessionRequest =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut SteamNetworkingMessagesSessionRequest_t)>;
pub type FnSteamNetworkingMessagesSessionFailed =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut SteamNetworkingMessagesSessionFailed_t)>;
pub type FnSteamNetworkingFakeIPResult =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut SteamNetworkingFakeIPResult_t)>;
#[doc = " Handle used to identify a connection to a remote host."]
pub type HSteamNetConnection = uint32;
pub const k_HSteamNetConnection_Invalid: HSteamNetConnection = 0;
#[doc = " Handle used to identify a \"listen socket\".  Unlike traditional\n Berkeley sockets, a listen socket and a connection are two\n different abstractions."]
pub type HSteamListenSocket = uint32;
pub const k_HSteamListenSocket_Invalid: HSteamListenSocket = 0;
#[doc = " Handle used to identify a poll group, used to query many\n connections at once efficiently."]
pub type HSteamNetPollGroup = uint32;
pub const k_HSteamNetPollGroup_Invalid: HSteamNetPollGroup = 0;
#[doc = " Max length of diagnostic error message"]
pub const k_cchMaxSteamNetworkingErrMsg: ::std::os::raw::c_int = 1024;
#[doc = " Used to return English-language diagnostic error messages to caller.\n (For debugging or spewing to a console, etc.  Not intended for UI.)"]
pub type SteamNetworkingErrMsg = [::std::os::raw::c_char; 1024usize];
#[doc = " Identifier used for a network location point of presence.  (E.g. a Valve data center.)\n Typically you won't need to directly manipulate these."]
pub type SteamNetworkingPOPID = uint32;
#[doc = " A local timestamp.  You can subtract two timestamps to get the number of elapsed\n microseconds.  This is guaranteed to increase over time during the lifetime\n of a process, but not globally across runs.  You don't need to worry about\n the value wrapping around.  Note that the underlying clock might not actually have\n microsecond resolution."]
pub type SteamNetworkingMicroseconds = int64;
#[repr(i32)]
#[non_exhaustive]
#[doc = " Describe the status of a particular network resource"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamNetworkingAvailability {
    k_ESteamNetworkingAvailability_CannotTry = -102,
    k_ESteamNetworkingAvailability_Failed = -101,
    k_ESteamNetworkingAvailability_Previously = -100,
    k_ESteamNetworkingAvailability_Retrying = -10,
    k_ESteamNetworkingAvailability_NeverTried = 1,
    k_ESteamNetworkingAvailability_Waiting = 2,
    k_ESteamNetworkingAvailability_Attempting = 3,
    k_ESteamNetworkingAvailability_Current = 100,
    k_ESteamNetworkingAvailability_Unknown = 0,
    k_ESteamNetworkingAvailability__Force32bit = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Different methods of describing the identity of a network host"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamNetworkingIdentityType {
    k_ESteamNetworkingIdentityType_Invalid = 0,
    k_ESteamNetworkingIdentityType_SteamID = 16,
    k_ESteamNetworkingIdentityType_XboxPairwiseID = 17,
    k_ESteamNetworkingIdentityType_SonyPSN = 18,
    k_ESteamNetworkingIdentityType_IPAddress = 1,
    k_ESteamNetworkingIdentityType_GenericString = 2,
    k_ESteamNetworkingIdentityType_GenericBytes = 3,
    k_ESteamNetworkingIdentityType_UnknownType = 4,
    k_ESteamNetworkingIdentityType__Force32bit = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " \"Fake IPs\" are assigned to hosts, to make it easier to interface with\n older code that assumed all hosts will have an IPv4 address"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamNetworkingFakeIPType {
    k_ESteamNetworkingFakeIPType_Invalid = 0,
    k_ESteamNetworkingFakeIPType_NotFake = 1,
    k_ESteamNetworkingFakeIPType_GlobalIPv4 = 2,
    k_ESteamNetworkingFakeIPType_LocalIPv4 = 3,
    k_ESteamNetworkingFakeIPType__Force32Bit = 2147483647,
}
#[doc = " Store an IP and port.  IPv6 is always used; IPv4 is represented using\n \"IPv4-mapped\" addresses: IPv4 aa.bb.cc.dd => IPv6 ::ffff:aabb:ccdd\n (RFC 4291 section 2.5.5.2.)"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct SteamNetworkingIPAddr {
    pub __bindgen_anon_1: SteamNetworkingIPAddr__bindgen_ty_2,
    pub m_port: uint16,
}
pub const SteamNetworkingIPAddr_k_cchMaxString: SteamNetworkingIPAddr__bindgen_ty_1 =
    SteamNetworkingIPAddr__bindgen_ty_1::k_cchMaxString;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamNetworkingIPAddr__bindgen_ty_1 {
    k_cchMaxString = 48,
}
#[doc = " RFC4038, section 4.2"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SteamNetworkingIPAddr_IPv4MappedAddress {
    pub m_8zeros: uint64,
    pub m_0000: uint16,
    pub m_ffff: uint16,
    pub m_ip: [uint8; 4usize],
}
#[test]
fn bindgen_test_layout_SteamNetworkingIPAddr_IPv4MappedAddress() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingIPAddr_IPv4MappedAddress> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingIPAddr_IPv4MappedAddress>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(SteamNetworkingIPAddr_IPv4MappedAddress)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingIPAddr_IPv4MappedAddress>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SteamNetworkingIPAddr_IPv4MappedAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_8zeros) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIPAddr_IPv4MappedAddress),
            "::",
            stringify!(m_8zeros)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_0000) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIPAddr_IPv4MappedAddress),
            "::",
            stringify!(m_0000)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ffff) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIPAddr_IPv4MappedAddress),
            "::",
            stringify!(m_ffff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ip) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIPAddr_IPv4MappedAddress),
            "::",
            stringify!(m_ip)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SteamNetworkingIPAddr__bindgen_ty_2 {
    pub m_ipv6: [uint8; 16usize],
    pub m_ipv4: SteamNetworkingIPAddr_IPv4MappedAddress,
}
#[test]
fn bindgen_test_layout_SteamNetworkingIPAddr__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingIPAddr__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingIPAddr__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(SteamNetworkingIPAddr__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingIPAddr__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SteamNetworkingIPAddr__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ipv6) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIPAddr__bindgen_ty_2),
            "::",
            stringify!(m_ipv6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ipv4) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIPAddr__bindgen_ty_2),
            "::",
            stringify!(m_ipv4)
        )
    );
}
#[test]
fn bindgen_test_layout_SteamNetworkingIPAddr() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingIPAddr> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingIPAddr>(),
        18usize,
        concat!("Size of: ", stringify!(SteamNetworkingIPAddr))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingIPAddr>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamNetworkingIPAddr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_port) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIPAddr),
            "::",
            stringify!(m_port)
        )
    );
}
#[doc = " An abstract way to represent the identity of a network host.  All identities can\n be represented as simple string.  Furthermore, this string representation is actually\n used on the wire in several places, even though it is less efficient, in order to\n facilitate forward compatibility.  (Old client code can handle an identity type that\n it doesn't understand.)"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct SteamNetworkingIdentity {
    #[doc = " Type of identity."]
    pub m_eType: ESteamNetworkingIdentityType,
    pub m_cbSize: ::std::os::raw::c_int,
    pub __bindgen_anon_1: SteamNetworkingIdentity__bindgen_ty_2,
}
pub const SteamNetworkingIdentity_k_cchMaxString: SteamNetworkingIdentity__bindgen_ty_1 =
    SteamNetworkingIdentity__bindgen_ty_1::k_cchMaxString;
pub const SteamNetworkingIdentity_k_cchMaxGenericString: SteamNetworkingIdentity__bindgen_ty_1 =
    SteamNetworkingIdentity__bindgen_ty_1::k_cchMaxGenericString;
pub const SteamNetworkingIdentity_k_cchMaxXboxPairwiseID: SteamNetworkingIdentity__bindgen_ty_1 =
    SteamNetworkingIdentity__bindgen_ty_1::k_cchMaxXboxPairwiseID;
pub const SteamNetworkingIdentity_k_cbMaxGenericBytes: SteamNetworkingIdentity__bindgen_ty_1 =
    SteamNetworkingIdentity__bindgen_ty_1::k_cchMaxGenericString;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamNetworkingIdentity__bindgen_ty_1 {
    k_cchMaxString = 128,
    k_cchMaxGenericString = 32,
    k_cchMaxXboxPairwiseID = 33,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union SteamNetworkingIdentity__bindgen_ty_2 {
    pub m_steamID64: uint64,
    pub m_PSNID: uint64,
    pub m_szGenericString: [::std::os::raw::c_char; 32usize],
    pub m_szXboxPairwiseID: [::std::os::raw::c_char; 33usize],
    pub m_genericBytes: [uint8; 32usize],
    pub m_szUnknownRawString: [::std::os::raw::c_char; 128usize],
    pub m_ip: SteamNetworkingIPAddr,
    pub m_reserved: [uint32; 32usize],
}
#[test]
fn bindgen_test_layout_SteamNetworkingIdentity__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingIdentity__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingIdentity__bindgen_ty_2>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(SteamNetworkingIdentity__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingIdentity__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SteamNetworkingIdentity__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamID64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIdentity__bindgen_ty_2),
            "::",
            stringify!(m_steamID64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_PSNID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIdentity__bindgen_ty_2),
            "::",
            stringify!(m_PSNID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szGenericString) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIdentity__bindgen_ty_2),
            "::",
            stringify!(m_szGenericString)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szXboxPairwiseID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIdentity__bindgen_ty_2),
            "::",
            stringify!(m_szXboxPairwiseID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_genericBytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIdentity__bindgen_ty_2),
            "::",
            stringify!(m_genericBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szUnknownRawString) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIdentity__bindgen_ty_2),
            "::",
            stringify!(m_szUnknownRawString)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ip) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIdentity__bindgen_ty_2),
            "::",
            stringify!(m_ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIdentity__bindgen_ty_2),
            "::",
            stringify!(m_reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_SteamNetworkingIdentity() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingIdentity> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingIdentity>(),
        136usize,
        concat!("Size of: ", stringify!(SteamNetworkingIdentity))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingIdentity>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamNetworkingIdentity))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIdentity),
            "::",
            stringify!(m_eType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cbSize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIdentity),
            "::",
            stringify!(m_cbSize)
        )
    );
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " High level connection status"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamNetworkingConnectionState {
    #[doc = " Dummy value used to indicate an error condition in the API.\n Specified connection doesn't exist or has already been closed."]
    k_ESteamNetworkingConnectionState_None = 0,
    #[doc = " We are trying to establish whether peers can talk to each other,\n whether they WANT to talk to each other, perform basic auth,\n and exchange crypt keys.\n\n - For connections on the \"client\" side (initiated locally):\n   We're in the process of trying to establish a connection.\n   Depending on the connection type, we might not know who they are.\n   Note that it is not possible to tell if we are waiting on the\n   network to complete handshake packets, or for the application layer\n   to accept the connection.\n\n - For connections on the \"server\" side (accepted through listen socket):\n   We have completed some basic handshake and the client has presented\n   some proof of identity.  The connection is ready to be accepted\n   using AcceptConnection().\n\n In either case, any unreliable packets sent now are almost certain\n to be dropped.  Attempts to receive packets are guaranteed to fail.\n You may send messages if the send mode allows for them to be queued.\n but if you close the connection before the connection is actually\n established, any queued messages will be discarded immediately.\n (We will not attempt to flush the queue and confirm delivery to the\n remote host, which ordinarily happens when a connection is closed.)"]
    k_ESteamNetworkingConnectionState_Connecting = 1,
    #[doc = " Some connection types use a back channel or trusted 3rd party\n for earliest communication.  If the server accepts the connection,\n then these connections switch into the rendezvous state.  During this\n state, we still have not yet established an end-to-end route (through\n the relay network), and so if you send any messages unreliable, they\n are going to be discarded."]
    k_ESteamNetworkingConnectionState_FindingRoute = 2,
    #[doc = " We've received communications from our peer (and we know\n who they are) and are all good.  If you close the connection now,\n we will make our best effort to flush out any reliable sent data that\n has not been acknowledged by the peer.  (But note that this happens\n from within the application process, so unlike a TCP connection, you are\n not totally handing it off to the operating system to deal with it.)"]
    k_ESteamNetworkingConnectionState_Connected = 3,
    #[doc = " Connection has been closed by our peer, but not closed locally.\n The connection still exists from an API perspective.  You must close the\n handle to free up resources.  If there are any messages in the inbound queue,\n you may retrieve them.  Otherwise, nothing may be done with the connection\n except to close it.\n\n This stats is similar to CLOSE_WAIT in the TCP state machine."]
    k_ESteamNetworkingConnectionState_ClosedByPeer = 4,
    #[doc = " A disruption in the connection has been detected locally.  (E.g. timeout,\n local internet connection disrupted, etc.)\n\n The connection still exists from an API perspective.  You must close the\n handle to free up resources.\n\n Attempts to send further messages will fail.  Any remaining received messages\n in the queue are available."]
    k_ESteamNetworkingConnectionState_ProblemDetectedLocally = 5,
    #[doc = " We've disconnected on our side, and from an API perspective the connection is closed.\n No more data may be sent or received.  All reliable data has been flushed, or else\n we've given up and discarded it.  We do not yet know for sure that the peer knows\n the connection has been closed, however, so we're just hanging around so that if we do\n get a packet from them, we can send them the appropriate packets so that they can\n know why the connection was closed (and not have to rely on a timeout, which makes\n it appear as if something is wrong)."]
    k_ESteamNetworkingConnectionState_FinWait = -1,
    #[doc = " We've disconnected on our side, and from an API perspective the connection is closed.\n No more data may be sent or received.  From a network perspective, however, on the wire,\n we have not yet given any indication to the peer that the connection is closed.\n We are in the process of flushing out the last bit of reliable data.  Once that is done,\n we will inform the peer that the connection has been closed, and transition to the\n FinWait state.\n\n Note that no indication is given to the remote host that we have closed the connection,\n until the data has been flushed.  If the remote host attempts to send us data, we will\n do whatever is necessary to keep the connection alive until it can be closed properly.\n But in fact the data will be discarded, since there is no way for the application to\n read it back.  Typically this is not a problem, as application protocols that utilize\n the lingering functionality are designed for the remote host to wait for the response\n before sending any more data."]
    k_ESteamNetworkingConnectionState_Linger = -2,
    #[doc = " Connection is completely inactive and ready to be destroyed"]
    k_ESteamNetworkingConnectionState_Dead = -3,
    #[doc = " Connection is completely inactive and ready to be destroyed"]
    k_ESteamNetworkingConnectionState__Force32Bit = 2147483647,
}
impl ESteamNetConnectionEnd {
    pub const k_ESteamNetConnectionEnd_App_Generic: ESteamNetConnectionEnd =
        ESteamNetConnectionEnd::k_ESteamNetConnectionEnd_App_Min;
}
impl ESteamNetConnectionEnd {
    pub const k_ESteamNetConnectionEnd_AppException_Generic: ESteamNetConnectionEnd =
        ESteamNetConnectionEnd::k_ESteamNetConnectionEnd_AppException_Min;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Enumerate various causes of connection termination.  These are designed to work similar\n to HTTP error codes: the numeric range gives you a rough classification as to the source\n of the problem."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamNetConnectionEnd {
    k_ESteamNetConnectionEnd_Invalid = 0,
    k_ESteamNetConnectionEnd_App_Min = 1000,
    k_ESteamNetConnectionEnd_App_Max = 1999,
    k_ESteamNetConnectionEnd_AppException_Min = 2000,
    k_ESteamNetConnectionEnd_AppException_Max = 2999,
    k_ESteamNetConnectionEnd_Local_Min = 3000,
    k_ESteamNetConnectionEnd_Local_OfflineMode = 3001,
    k_ESteamNetConnectionEnd_Local_ManyRelayConnectivity = 3002,
    k_ESteamNetConnectionEnd_Local_HostedServerPrimaryRelay = 3003,
    k_ESteamNetConnectionEnd_Local_NetworkConfig = 3004,
    k_ESteamNetConnectionEnd_Local_Rights = 3005,
    k_ESteamNetConnectionEnd_Local_P2P_ICE_NoPublicAddresses = 3006,
    k_ESteamNetConnectionEnd_Local_Max = 3999,
    k_ESteamNetConnectionEnd_Remote_Min = 4000,
    k_ESteamNetConnectionEnd_Remote_Timeout = 4001,
    k_ESteamNetConnectionEnd_Remote_BadCrypt = 4002,
    k_ESteamNetConnectionEnd_Remote_BadCert = 4003,
    k_ESteamNetConnectionEnd_Remote_BadProtocolVersion = 4006,
    k_ESteamNetConnectionEnd_Remote_P2P_ICE_NoPublicAddresses = 4007,
    k_ESteamNetConnectionEnd_Remote_Max = 4999,
    k_ESteamNetConnectionEnd_Misc_Min = 5000,
    k_ESteamNetConnectionEnd_Misc_Generic = 5001,
    k_ESteamNetConnectionEnd_Misc_InternalError = 5002,
    k_ESteamNetConnectionEnd_Misc_Timeout = 5003,
    k_ESteamNetConnectionEnd_Misc_SteamConnectivity = 5005,
    k_ESteamNetConnectionEnd_Misc_NoRelaySessionsToClient = 5006,
    k_ESteamNetConnectionEnd_Misc_P2P_Rendezvous = 5008,
    k_ESteamNetConnectionEnd_Misc_P2P_NAT_Firewall = 5009,
    k_ESteamNetConnectionEnd_Misc_PeerSentNoConnection = 5010,
    k_ESteamNetConnectionEnd_Misc_Max = 5999,
    k_ESteamNetConnectionEnd__Force32Bit = 2147483647,
}
#[doc = " Max length, in bytes (including null terminator) of the reason string\n when a connection is closed."]
pub const k_cchSteamNetworkingMaxConnectionCloseReason: ::std::os::raw::c_int = 128;
#[doc = " Max length, in bytes (include null terminator) of debug description\n of a connection."]
pub const k_cchSteamNetworkingMaxConnectionDescription: ::std::os::raw::c_int = 128;
#[doc = " Max length of the app's part of the description"]
pub const k_cchSteamNetworkingMaxConnectionAppName: ::std::os::raw::c_int = 32;
pub const k_nSteamNetworkConnectionInfoFlags_Unauthenticated: ::std::os::raw::c_int = 1;
pub const k_nSteamNetworkConnectionInfoFlags_Unencrypted: ::std::os::raw::c_int = 2;
pub const k_nSteamNetworkConnectionInfoFlags_LoopbackBuffers: ::std::os::raw::c_int = 4;
pub const k_nSteamNetworkConnectionInfoFlags_Fast: ::std::os::raw::c_int = 8;
pub const k_nSteamNetworkConnectionInfoFlags_Relayed: ::std::os::raw::c_int = 16;
pub const k_nSteamNetworkConnectionInfoFlags_DualWifi: ::std::os::raw::c_int = 32;
#[doc = " Describe the state of a connection."]
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct SteamNetConnectionInfo_t {
    #[doc = " Who is on the other end?  Depending on the connection type and phase of the connection, we might not know"]
    pub m_identityRemote: SteamNetworkingIdentity,
    #[doc = " Arbitrary user data set by the local application code"]
    pub m_nUserData: int64,
    #[doc = " Handle to listen socket this was connected on, or k_HSteamListenSocket_Invalid if we initiated the connection"]
    pub m_hListenSocket: HSteamListenSocket,
    #[doc = " Remote address.  Might be all 0's if we don't know it, or if this is N/A.\n (E.g. Basically everything except direct UDP connection.)"]
    pub m_addrRemote: SteamNetworkingIPAddr,
    pub m__pad1: uint16,
    #[doc = " What data center is the remote host in?  (0 if we don't know.)"]
    pub m_idPOPRemote: SteamNetworkingPOPID,
    #[doc = " What relay are we using to communicate with the remote host?\n (0 if not applicable.)"]
    pub m_idPOPRelay: SteamNetworkingPOPID,
    #[doc = " High level state of the connection"]
    pub m_eState: ESteamNetworkingConnectionState,
    #[doc = " Basic cause of the connection termination or problem.\n See ESteamNetConnectionEnd for the values used"]
    pub m_eEndReason: ::std::os::raw::c_int,
    #[doc = " Human-readable, but non-localized explanation for connection\n termination or problem.  This is intended for debugging /\n diagnostic purposes only, not to display to users.  It might\n have some details specific to the issue."]
    pub m_szEndDebug: [::std::os::raw::c_char; 128usize],
    #[doc = " Debug description.  This includes the internal connection ID,\n connection type (and peer information), and any name\n given to the connection by the app.  This string is used in various\n internal logging messages.\n\n Note that the connection ID *usually* matches the HSteamNetConnection\n handle, but in certain cases with symmetric connections it might not."]
    pub m_szConnectionDescription: [::std::os::raw::c_char; 128usize],
    #[doc = " Misc flags.  Bitmask of k_nSteamNetworkConnectionInfoFlags_Xxxx"]
    pub m_nFlags: ::std::os::raw::c_int,
    #[doc = " Internal stuff, room to change API easily"]
    pub reserved: [uint32; 63usize],
}
#[test]
fn bindgen_test_layout_SteamNetConnectionInfo_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetConnectionInfo_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetConnectionInfo_t>(),
        696usize,
        concat!("Size of: ", stringify!(SteamNetConnectionInfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetConnectionInfo_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamNetConnectionInfo_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_identityRemote) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(m_identityRemote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nUserData) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(m_nUserData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hListenSocket) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(m_hListenSocket)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_addrRemote) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(m_addrRemote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m__pad1) as usize - ptr as usize },
        166usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(m__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_idPOPRemote) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(m_idPOPRemote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_idPOPRelay) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(m_idPOPRelay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eState) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(m_eState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eEndReason) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(m_eEndReason)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szEndDebug) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(m_szEndDebug)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szConnectionDescription) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(m_szConnectionDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nFlags) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(m_nFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        444usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Quick connection state, pared down to something you could call\n more frequently without it being too big of a perf hit."]
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct SteamNetConnectionRealTimeStatus_t {
    #[doc = " High level state of the connection"]
    pub m_eState: ESteamNetworkingConnectionState,
    #[doc = " Current ping (ms)"]
    pub m_nPing: ::std::os::raw::c_int,
    #[doc = " Connection quality measured locally, 0...1.  (Percentage of packets delivered\n end-to-end in order)."]
    pub m_flConnectionQualityLocal: f32,
    #[doc = " Packet delivery success rate as observed from remote host"]
    pub m_flConnectionQualityRemote: f32,
    #[doc = " Current data rates from recent history."]
    pub m_flOutPacketsPerSec: f32,
    pub m_flOutBytesPerSec: f32,
    pub m_flInPacketsPerSec: f32,
    pub m_flInBytesPerSec: f32,
    #[doc = " Estimate rate that we believe that we can send data to our peer.\n Note that this could be significantly higher than m_flOutBytesPerSec,\n meaning the capacity of the channel is higher than you are sending data.\n (That's OK!)"]
    pub m_nSendRateBytesPerSecond: ::std::os::raw::c_int,
    #[doc = " Number of bytes pending to be sent.  This is data that you have recently\n requested to be sent but has not yet actually been put on the wire.  The\n reliable number ALSO includes data that was previously placed on the wire,\n but has now been scheduled for re-transmission.  Thus, it's possible to\n observe m_cbPendingReliable increasing between two checks, even if no\n calls were made to send reliable data between the checks.  Data that is\n awaiting the Nagle delay will appear in these numbers."]
    pub m_cbPendingUnreliable: ::std::os::raw::c_int,
    pub m_cbPendingReliable: ::std::os::raw::c_int,
    #[doc = " Number of bytes of reliable data that has been placed the wire, but\n for which we have not yet received an acknowledgment, and thus we may\n have to re-transmit."]
    pub m_cbSentUnackedReliable: ::std::os::raw::c_int,
    #[doc = " If you queued a message right now, approximately how long would that message\n wait in the queue before we actually started putting its data on the wire in\n a packet?\n\n In general, data that is sent by the application is limited by the bandwidth\n of the channel.  If you send data faster than this, it must be queued and\n put on the wire at a metered rate.  Even sending a small amount of data (e.g.\n a few MTU, say ~3k) will require some of the data to be delayed a bit.\n\n Ignoring multiple lanes, the estimated delay will be approximately equal to\n\n\t\t( m_cbPendingUnreliable+m_cbPendingReliable ) / m_nSendRateBytesPerSecond\n\n plus or minus one MTU.  It depends on how much time has elapsed since the last\n packet was put on the wire.  For example, the queue might have *just* been emptied,\n and the last packet placed on the wire, and we are exactly up against the send\n rate limit.  In that case we might need to wait for one packet's worth of time to\n elapse before we can send again.  On the other extreme, the queue might have data\n in it waiting for Nagle.  (This will always be less than one packet, because as\n soon as we have a complete packet we would send it.)  In that case, we might be\n ready to send data now, and this value will be 0.\n\n This value is only valid if multiple lanes are not used.  If multiple lanes are\n in use, then the queue time will be different for each lane, and you must use\n the value in SteamNetConnectionRealTimeLaneStatus_t.\n\n Nagle delay is ignored for the purposes of this calculation."]
    pub m_usecQueueTime: SteamNetworkingMicroseconds,
    pub reserved: [uint32; 16usize],
}
#[test]
fn bindgen_test_layout_SteamNetConnectionRealTimeStatus_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetConnectionRealTimeStatus_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetConnectionRealTimeStatus_t>(),
        120usize,
        concat!("Size of: ", stringify!(SteamNetConnectionRealTimeStatus_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetConnectionRealTimeStatus_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SteamNetConnectionRealTimeStatus_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_eState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPing) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_nPing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_flConnectionQualityLocal) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_flConnectionQualityLocal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_flConnectionQualityRemote) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_flConnectionQualityRemote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_flOutPacketsPerSec) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_flOutPacketsPerSec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_flOutBytesPerSec) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_flOutBytesPerSec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_flInPacketsPerSec) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_flInPacketsPerSec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_flInBytesPerSec) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_flInBytesPerSec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nSendRateBytesPerSecond) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_nSendRateBytesPerSecond)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cbPendingUnreliable) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_cbPendingUnreliable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cbPendingReliable) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_cbPendingReliable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cbSentUnackedReliable) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_cbSentUnackedReliable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_usecQueueTime) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_usecQueueTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Quick status of a particular lane"]
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct SteamNetConnectionRealTimeLaneStatus_t {
    pub m_cbPendingUnreliable: ::std::os::raw::c_int,
    pub m_cbPendingReliable: ::std::os::raw::c_int,
    pub m_cbSentUnackedReliable: ::std::os::raw::c_int,
    pub _reservePad1: ::std::os::raw::c_int,
    #[doc = " Lane-specific queue time.  This value takes into consideration lane priorities\n and weights, and how much data is queued in each lane, and attempts to predict\n how any data currently queued will be sent out."]
    pub m_usecQueueTime: SteamNetworkingMicroseconds,
    pub reserved: [uint32; 10usize],
}
#[test]
fn bindgen_test_layout_SteamNetConnectionRealTimeLaneStatus_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetConnectionRealTimeLaneStatus_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetConnectionRealTimeLaneStatus_t>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(SteamNetConnectionRealTimeLaneStatus_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetConnectionRealTimeLaneStatus_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SteamNetConnectionRealTimeLaneStatus_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cbPendingUnreliable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeLaneStatus_t),
            "::",
            stringify!(m_cbPendingUnreliable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cbPendingReliable) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeLaneStatus_t),
            "::",
            stringify!(m_cbPendingReliable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cbSentUnackedReliable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeLaneStatus_t),
            "::",
            stringify!(m_cbSentUnackedReliable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._reservePad1) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeLaneStatus_t),
            "::",
            stringify!(_reservePad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_usecQueueTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeLaneStatus_t),
            "::",
            stringify!(m_usecQueueTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeLaneStatus_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Max size of a single message that we can SEND.\n Note: We might be wiling to receive larger messages,\n and our peer might, too."]
pub const k_cbMaxSteamNetworkingSocketsMessageSizeSend: ::std::os::raw::c_int = 524288;
#[doc = " A message that has been received."]
#[repr(C)]
pub struct SteamNetworkingMessage_t {
    #[doc = " Message payload"]
    pub m_pData: *mut ::std::os::raw::c_void,
    #[doc = " Size of the payload."]
    pub m_cbSize: ::std::os::raw::c_int,
    #[doc = " For messages received on connections: what connection did this come from?\n For outgoing messages: what connection to send it to?\n Not used when using the ISteamNetworkingMessages interface"]
    pub m_conn: HSteamNetConnection,
    #[doc = " For inbound messages: Who sent this to us?\n For outbound messages on connections: not used.\n For outbound messages on the ad-hoc ISteamNetworkingMessages interface: who should we send this to?"]
    pub m_identityPeer: SteamNetworkingIdentity,
    #[doc = " For messages received on connections, this is the user data\n associated with the connection.\n\n This is *usually* the same as calling GetConnection() and then\n fetching the user data associated with that connection, but for\n the following subtle differences:\n\n - This user data will match the connection's user data at the time\n   is captured at the time the message is returned by the API.\n   If you subsequently change the userdata on the connection,\n   this won't be updated.\n - This is an inline call, so it's *much* faster.\n - You might have closed the connection, so fetching the user data\n   would not be possible.\n\n Not used when sending messages."]
    pub m_nConnUserData: int64,
    #[doc = " Local timestamp when the message was received\n Not used for outbound messages."]
    pub m_usecTimeReceived: SteamNetworkingMicroseconds,
    #[doc = " Message number assigned by the sender.  This is not used for outbound\n messages.  Note that if multiple lanes are used, each lane has its own\n message numbers, which are assigned sequentially, so messages from\n different lanes will share the same numbers."]
    pub m_nMessageNumber: int64,
    #[doc = " Function used to free up m_pData.  This mechanism exists so that\n apps can create messages with buffers allocated from their own\n heap, and pass them into the library.  This function will\n usually be something like:\n\n free( pMsg->m_pData );"]
    pub m_pfnFreeData:
        ::std::option::Option<unsafe extern "C" fn(pMsg: *mut SteamNetworkingMessage_t)>,
    #[doc = " Function to used to decrement the internal reference count and, if\n it's zero, release the message.  You should not set this function pointer,\n or need to access this directly!  Use the Release() function instead!"]
    pub m_pfnRelease:
        ::std::option::Option<unsafe extern "C" fn(pMsg: *mut SteamNetworkingMessage_t)>,
    #[doc = " When using ISteamNetworkingMessages, the channel number the message was received on\n (Not used for messages sent or received on \"connections\")"]
    pub m_nChannel: ::std::os::raw::c_int,
    #[doc = " Bitmask of k_nSteamNetworkingSend_xxx flags.\n For received messages, only the k_nSteamNetworkingSend_Reliable bit is valid.\n For outbound messages, all bits are relevant"]
    pub m_nFlags: ::std::os::raw::c_int,
    #[doc = " Arbitrary user data that you can use when sending messages using\n ISteamNetworkingUtils::AllocateMessage and ISteamNetworkingSockets::SendMessage.\n (The callback you set in m_pfnFreeData might use this field.)\n\n Not used for received messages."]
    pub m_nUserData: int64,
    #[doc = " For outbound messages, which lane to use?  See ISteamNetworkingSockets::ConfigureConnectionLanes.\n For inbound messages, what lane was the message received on?"]
    pub m_idxLane: uint16,
    pub _pad1__: uint16,
}
#[test]
fn bindgen_test_layout_SteamNetworkingMessage_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingMessage_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingMessage_t>(),
        216usize,
        concat!("Size of: ", stringify!(SteamNetworkingMessage_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingMessage_t>(),
        8usize,
        concat!("Alignment of ", stringify!(SteamNetworkingMessage_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_pData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cbSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_cbSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_conn) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_conn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_identityPeer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_identityPeer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nConnUserData) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_nConnUserData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_usecTimeReceived) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_usecTimeReceived)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nMessageNumber) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_nMessageNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pfnFreeData) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_pfnFreeData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pfnRelease) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_pfnRelease)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nChannel) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_nChannel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nFlags) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_nFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nUserData) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_nUserData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_idxLane) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_idxLane)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._pad1__) as usize - ptr as usize },
        210usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(_pad1__)
        )
    );
}
pub const k_nSteamNetworkingSend_Unreliable: ::std::os::raw::c_int = 0;
pub const k_nSteamNetworkingSend_NoNagle: ::std::os::raw::c_int = 1;
pub const k_nSteamNetworkingSend_UnreliableNoNagle: ::std::os::raw::c_int = 1;
pub const k_nSteamNetworkingSend_NoDelay: ::std::os::raw::c_int = 4;
pub const k_nSteamNetworkingSend_UnreliableNoDelay: ::std::os::raw::c_int = 5;
pub const k_nSteamNetworkingSend_Reliable: ::std::os::raw::c_int = 8;
pub const k_nSteamNetworkingSend_ReliableNoNagle: ::std::os::raw::c_int = 9;
pub const k_nSteamNetworkingSend_UseCurrentThread: ::std::os::raw::c_int = 16;
pub const k_nSteamNetworkingSend_AutoRestartBrokenSession: ::std::os::raw::c_int = 32;
#[doc = " Object that describes a \"location\" on the Internet with sufficient\n detail that we can reasonably estimate an upper bound on the ping between\n the two hosts, even if a direct route between the hosts is not possible,\n and the connection must be routed through the Steam Datagram Relay network.\n This does not contain any information that identifies the host.  Indeed,\n if two hosts are in the same building or otherwise have nearly identical\n networking characteristics, then it's valid to use the same location\n object for both of them.\n\n NOTE: This object should only be used in the same process!  Do not serialize it,\n send it over the wire, or persist it in a file or database!  If you need\n to do that, convert it to a string representation using the methods in\n ISteamNetworkingUtils()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamNetworkPingLocation_t {
    pub m_data: [uint8; 512usize],
}
#[test]
fn bindgen_test_layout_SteamNetworkPingLocation_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkPingLocation_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkPingLocation_t>(),
        512usize,
        concat!("Size of: ", stringify!(SteamNetworkPingLocation_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkPingLocation_t>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamNetworkPingLocation_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkPingLocation_t),
            "::",
            stringify!(m_data)
        )
    );
}
#[doc = " Max possible length of a ping location, in string format.  This is\n an extremely conservative worst case value which leaves room for future\n syntax enhancements.  Most strings in practice are a lot shorter.\n If you are storing many of these, you will very likely benefit from\n using dynamic memory."]
pub const k_cchMaxSteamNetworkingPingLocationString: ::std::os::raw::c_int = 1024;
#[doc = " Special values that are returned by some functions that return a ping."]
pub const k_nSteamNetworkingPing_Failed: ::std::os::raw::c_int = -1;
pub const k_nSteamNetworkingPing_Unknown: ::std::os::raw::c_int = -2;
#[repr(u32)]
#[non_exhaustive]
#[doc = " Configuration values can be applied to different types of objects."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamNetworkingConfigScope {
    #[doc = " Get/set global option, or defaults.  Even options that apply to more specific scopes\n have global scope, and you may be able to just change the global defaults.  If you\n need different settings per connection (for example), then you will need to set those\n options at the more specific scope."]
    k_ESteamNetworkingConfig_Global = 1,
    #[doc = " Some options are specific to a particular interface.  Note that all connection\n and listen socket settings can also be set at the interface level, and they will\n apply to objects created through those interfaces."]
    k_ESteamNetworkingConfig_SocketsInterface = 2,
    #[doc = " Options for a listen socket.  Listen socket options can be set at the interface layer,\n if  you have multiple listen sockets and they all use the same options.\n You can also set connection options on a listen socket, and they set the defaults\n for all connections accepted through this listen socket.  (They will be used if you don't\n set a connection option.)"]
    k_ESteamNetworkingConfig_ListenSocket = 3,
    #[doc = " Options for a specific connection."]
    k_ESteamNetworkingConfig_Connection = 4,
    #[doc = " Options for a specific connection."]
    k_ESteamNetworkingConfigScope__Force32Bit = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamNetworkingConfigDataType {
    k_ESteamNetworkingConfig_Int32 = 1,
    k_ESteamNetworkingConfig_Int64 = 2,
    k_ESteamNetworkingConfig_Float = 3,
    k_ESteamNetworkingConfig_String = 4,
    k_ESteamNetworkingConfig_Ptr = 5,
    k_ESteamNetworkingConfigDataType__Force32Bit = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Configuration options"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamNetworkingConfigValue {
    k_ESteamNetworkingConfig_Invalid = 0,
    #[doc = " [connection int32] Timeout value (in ms) to use when first connecting"]
    k_ESteamNetworkingConfig_TimeoutInitial = 24,
    #[doc = " [connection int32] Timeout value (in ms) to use after connection is established"]
    k_ESteamNetworkingConfig_TimeoutConnected = 25,
    #[doc = " [connection int32] Upper limit of buffered pending bytes to be sent,\n if this is reached SendMessage will return k_EResultLimitExceeded\n Default is 512k (524288 bytes)"]
    k_ESteamNetworkingConfig_SendBufferSize = 9,
    #[doc = " [connection int32] Upper limit on total size (in bytes) of received messages\n that will be buffered waiting to be processed by the application.  If this limit\n is exceeded, packets will be dropped.  This is to protect us from a malicious\n peer flooding us with messages faster than we can process them.\n\n This must be bigger than k_ESteamNetworkingConfig_RecvMaxMessageSize"]
    k_ESteamNetworkingConfig_RecvBufferSize = 47,
    #[doc = " [connection int32] Upper limit on the number of received messages that will\n that will be buffered waiting to be processed by the application.  If this limit\n is exceeded, packets will be dropped.  This is to protect us from a malicious\n peer flooding us with messages faster than we can pull them off the wire."]
    k_ESteamNetworkingConfig_RecvBufferMessages = 48,
    #[doc = " [connection int32] Maximum message size that we are willing to receive.\n if a client attempts to send us a message larger than this, the connection\n will be immediately closed.\n\n Default is 512k (524288 bytes).  Note that the peer needs to be able to\n send a message this big.  (See k_cbMaxSteamNetworkingSocketsMessageSizeSend.)"]
    k_ESteamNetworkingConfig_RecvMaxMessageSize = 49,
    #[doc = " [connection int32] Max number of message segments that can be received\n in a single UDP packet.  While decoding a packet, if the number of segments\n exceeds this, we will abort further packet processing.\n\n The default is effectively unlimited.  If you know that you very rarely\n send small packets, you can protect yourself from malicious senders by\n lowering this number.\n\n In particular, if you are NOT using the reliability layer and are only using\n SteamNetworkingSockets for datagram transport, setting this to a very low\n number may be beneficial.  (We recommend a value of 2.)  Make sure your sender\n disables Nagle!"]
    k_ESteamNetworkingConfig_RecvMaxSegmentsPerPacket = 50,
    #[doc = " [connection int64] Get/set userdata as a configuration option.\n The default value is -1.   You may want to set the user data as\n a config value, instead of using ISteamNetworkingSockets::SetConnectionUserData\n in two specific instances:\n\n - You wish to set the userdata atomically when creating\n   an outbound connection, so that the userdata is filled in properly\n   for any callbacks that happen.  However, note that this trick\n   only works for connections initiated locally!  For incoming\n   connections, multiple state transitions may happen and\n   callbacks be queued, before you are able to service the first\n   callback!  Be careful!\n\n - You can set the default userdata for all newly created connections\n   by setting this value at a higher level (e.g. on the listen\n   socket or at the global level.)  Then this default\n   value will be inherited when the connection is created.\n   This is useful in case -1 is a valid userdata value, and you\n   wish to use something else as the default value so you can\n   tell if it has been set or not.\n\n   HOWEVER: once a connection is created, the effective value is\n   then bound to the connection.  Unlike other connection options,\n   if you change it again at a higher level, the new value will not\n   be inherited by connections.\n\n Using the userdata field in callback structs is not advised because\n of tricky race conditions.  Instead, you might try one of these methods:\n\n - Use a separate map with the HSteamNetConnection as the key.\n - Fetch the userdata from the connection in your callback\n   using ISteamNetworkingSockets::GetConnectionUserData, to"]
    k_ESteamNetworkingConfig_ConnectionUserData = 40,
    #[doc = " [connection int32] Minimum/maximum send rate clamp, in bytes/sec.\n At the time of this writing these two options should always be set to\n the same value, to manually configure a specific send rate.  The default\n value is 256K.  Eventually we hope to have the library estimate the bandwidth\n of the channel and set the send rate to that estimated bandwidth, and these\n values will only set limits on that send rate."]
    k_ESteamNetworkingConfig_SendRateMin = 10,
    #[doc = " [connection int32] Minimum/maximum send rate clamp, in bytes/sec.\n At the time of this writing these two options should always be set to\n the same value, to manually configure a specific send rate.  The default\n value is 256K.  Eventually we hope to have the library estimate the bandwidth\n of the channel and set the send rate to that estimated bandwidth, and these\n values will only set limits on that send rate."]
    k_ESteamNetworkingConfig_SendRateMax = 11,
    #[doc = " [connection int32] Nagle time, in microseconds.  When SendMessage is called, if\n the outgoing message is less than the size of the MTU, it will be\n queued for a delay equal to the Nagle timer value.  This is to ensure\n that if the application sends several small messages rapidly, they are\n coalesced into a single packet.\n See historical RFC 896.  Value is in microseconds.\n Default is 5000us (5ms)."]
    k_ESteamNetworkingConfig_NagleTime = 12,
    #[doc = " [connection int32] Don't automatically fail IP connections that don't have\n strong auth.  On clients, this means we will attempt the connection even if\n we don't know our identity or can't get a cert.  On the server, it means that\n we won't automatically reject a connection due to a failure to authenticate.\n (You can examine the incoming connection and decide whether to accept it.)\n\n 0: Don't attempt or accept unauthorized connections\n 1: Attempt authorization when connecting, and allow unauthorized peers, but emit warnings\n 2: don't attempt authentication, or complain if peer is unauthenticated\n\n This is a dev configuration value, and you should not let users modify it in\n production."]
    k_ESteamNetworkingConfig_IP_AllowWithoutAuth = 23,
    #[doc = " [connection int32] The same as IP_AllowWithoutAuth, but will only apply\n for connections to/from localhost addresses.  Whichever value is larger\n (more permissive) will be used."]
    k_ESteamNetworkingConfig_IPLocalHost_AllowWithoutAuth = 52,
    #[doc = " [connection int32] Do not send UDP packets with a payload of\n larger than N bytes.  If you set this, k_ESteamNetworkingConfig_MTU_DataSize\n is automatically adjusted"]
    k_ESteamNetworkingConfig_MTU_PacketSize = 32,
    #[doc = " [connection int32] (read only) Maximum message size you can send that\n will not fragment, based on k_ESteamNetworkingConfig_MTU_PacketSize"]
    k_ESteamNetworkingConfig_MTU_DataSize = 33,
    #[doc = " [connection int32] Allow unencrypted (and unauthenticated) communication.\n 0: Not allowed (the default)\n 1: Allowed, but prefer encrypted\n 2: Allowed, and preferred\n 3: Required.  (Fail the connection if the peer requires encryption.)\n\n This is a dev configuration value, since its purpose is to disable encryption.\n You should not let users modify it in production.  (But note that it requires\n the peer to also modify their value in order for encryption to be disabled.)"]
    k_ESteamNetworkingConfig_Unencrypted = 34,
    #[doc = " [connection int32] Set this to 1 on outbound connections and listen sockets,\n to enable \"symmetric connect mode\", which is useful in the following\n common peer-to-peer use case:\n\n - The two peers are \"equal\" to each other.  (Neither is clearly the \"client\"\n   or \"server\".)\n - Either peer may initiate the connection, and indeed they may do this\n   at the same time\n - The peers only desire a single connection to each other, and if both\n   peers initiate connections simultaneously, a protocol is needed for them\n   to resolve the conflict, so that we end up with a single connection.\n\n This use case is both common, and involves subtle race conditions and tricky\n pitfalls, which is why the API has support for dealing with it.\n\n If an incoming connection arrives on a listen socket or via custom signaling,\n and the application has not attempted to make a matching outbound connection\n in symmetric mode, then the incoming connection can be accepted as usual.\n A \"matching\" connection means that the relevant endpoint information matches.\n (At the time this comment is being written, this is only supported for P2P\n connections, which means that the peer identities must match, and the virtual\n port must match.  At a later time, symmetric mode may be supported for other\n connection types.)\n\n If connections are initiated by both peers simultaneously, race conditions\n can arise, but fortunately, most of them are handled internally and do not\n require any special awareness from the application.  However, there\n is one important case that application code must be aware of:\n If application code attempts an outbound connection using a ConnectXxx\n function in symmetric mode, and a matching incoming connection is already\n waiting on a listen socket, then instead of forming a new connection,\n the ConnectXxx call will accept the existing incoming connection, and return\n a connection handle to this accepted connection.\n IMPORTANT: in this case, a SteamNetConnectionStatusChangedCallback_t\n has probably *already* been posted to the queue for the incoming connection!\n (Once callbacks are posted to the queue, they are not modified.)  It doesn't\n matter if the callback has not been consumed by the app.  Thus, application\n code that makes use of symmetric connections must be aware that, when processing a\n SteamNetConnectionStatusChangedCallback_t for an incoming connection, the\n m_hConn may refer to a new connection that the app has has not\n seen before (the usual case), but it may also refer to a connection that\n has already been accepted implicitly through a call to Connect()!  In this\n case, AcceptConnection() will return k_EResultDuplicateRequest.\n\n Only one symmetric connection to a given peer (on a given virtual port)\n may exist at any given time.  If client code attempts to create a connection,\n and a (live) connection already exists on the local host, then either the\n existing connection will be accepted as described above, or the attempt\n to create a new connection will fail.  Furthermore, linger mode functionality\n is not supported on symmetric connections.\n\n A more complicated race condition can arise if both peers initiate a connection\n at roughly the same time.  In this situation, each peer will receive an incoming\n connection from the other peer, when the application code has already initiated\n an outgoing connection to that peer.  The peers must resolve this conflict and\n decide who is going to act as the \"server\" and who will act as the \"client\".\n Typically the application does not need to be aware of this case as it is handled\n internally.  On both sides, the will observe their outbound connection being\n \"accepted\", although one of them one have been converted internally to act\n as the \"server\".\n\n In general, symmetric mode should be all-or-nothing: do not mix symmetric\n connections with a non-symmetric connection that it might possible \"match\"\n with.  If you use symmetric mode on any connections, then both peers should\n use it on all connections, and the corresponding listen socket, if any.  The\n behaviour when symmetric and ordinary connections are mixed is not defined by\n this API, and you should not rely on it.  (This advice only applies when connections\n might possibly \"match\".  For example, it's OK to use all symmetric mode\n connections on one virtual port, and all ordinary, non-symmetric connections\n on a different virtual port, as there is no potential for ambiguity.)\n\n When using the feature, you should set it in the following situations on\n applicable objects:\n\n - When creating an outbound connection using ConnectXxx function\n - When creating a listen socket.  (Note that this will automatically cause\n   any accepted connections to inherit the flag.)\n - When using custom signaling, before accepting an incoming connection.\n\n Setting the flag on listen socket and accepted connections will enable the\n API to automatically deal with duplicate incoming connections, even if the\n local host has not made any outbound requests.  (In general, such duplicate\n requests from a peer are ignored internally and will not be visible to the\n application code.  The previous connection must be closed or resolved first.)"]
    k_ESteamNetworkingConfig_SymmetricConnect = 37,
    #[doc = " [connection int32] For connection types that use \"virtual ports\", this can be used\n to assign a local virtual port.  For incoming connections, this will always be the\n virtual port of the listen socket (or the port requested by the remote host if custom\n signaling is used and the connection is accepted), and cannot be changed.  For\n connections initiated locally, the local virtual port will default to the same as the\n requested remote virtual port, if you do not specify a different option when creating\n the connection.  The local port is only relevant for symmetric connections, when\n determining if two connections \"match.\"  In this case, if you need the local and remote\n port to differ, you can set this value.\n\n You can also read back this value on listen sockets.\n\n This value should not be read or written in any other context."]
    k_ESteamNetworkingConfig_LocalVirtualPort = 38,
    #[doc = " [connection int32] Enable Dual wifi band support for this connection\n 0 = no, 1 = yes, 2 = simulate it for debugging, even if dual wifi not available"]
    k_ESteamNetworkingConfig_DualWifi_Enable = 39,
    #[doc = " [connection int32] True to enable diagnostics reporting through\n generic platform UI.  (Only available on Steam.)"]
    k_ESteamNetworkingConfig_EnableDiagnosticsUI = 46,
    #[doc = " [connection int32] Send of time-since-previous-packet values in each UDP packet.\n This add a small amount of packet overhead but allows for detailed jitter measurements\n to be made by the receiver.\n\n -  0: disables the sending\n -  1: enables sending\n - -1: (the default) Use the default for the connection type.  For plain UDP connections,\n       this is disabled, and for relayed connections, it is enabled.  Note that relays\n       always send the value."]
    k_ESteamNetworkingConfig_SendTimeSincePreviousPacket = 59,
    #[doc = " [global float, 0--100] Randomly discard N pct of packets instead of sending/recv\n This is a global option only, since it is applied at a low level\n where we don't have much context"]
    k_ESteamNetworkingConfig_FakePacketLoss_Send = 2,
    #[doc = " [global float, 0--100] Randomly discard N pct of packets instead of sending/recv\n This is a global option only, since it is applied at a low level\n where we don't have much context"]
    k_ESteamNetworkingConfig_FakePacketLoss_Recv = 3,
    #[doc = " [global int32].  Delay all outbound/inbound packets by N ms"]
    k_ESteamNetworkingConfig_FakePacketLag_Send = 4,
    #[doc = " [global int32].  Delay all outbound/inbound packets by N ms"]
    k_ESteamNetworkingConfig_FakePacketLag_Recv = 5,
    #[doc = " Simulated jitter/clumping.\n\n For each packet, a jitter value is determined (which may\n be zero).  This amount is added as extra delay to the\n packet.  When a subsequent packet is queued, it receives its\n own random jitter amount from the current time.  if this would\n result in the packets being delivered out of order, the later\n packet queue time is adjusted to happen after the first packet.\n Thus simulating jitter by itself will not reorder packets, but it\n can \"clump\" them.\n\n\t- Avg: A random jitter time is generated using an exponential\n   distribution using this value as the mean (ms).  The default\n   is zero, which disables random jitter.\n - Max: Limit the random jitter time to this value (ms).\n\t- Pct: odds (0-100) that a random jitter value for the packet\n   will be generated.  Otherwise, a jitter value of zero\n   is used, and the packet will only be delayed by the jitter\n   system if necessary to retain order, due to the jitter of a\n   previous packet.\n\n All values are [global float]\n\n Fake jitter is simulated after fake lag, but before reordering."]
    k_ESteamNetworkingConfig_FakePacketJitter_Send_Avg = 53,
    #[doc = " Simulated jitter/clumping.\n\n For each packet, a jitter value is determined (which may\n be zero).  This amount is added as extra delay to the\n packet.  When a subsequent packet is queued, it receives its\n own random jitter amount from the current time.  if this would\n result in the packets being delivered out of order, the later\n packet queue time is adjusted to happen after the first packet.\n Thus simulating jitter by itself will not reorder packets, but it\n can \"clump\" them.\n\n\t- Avg: A random jitter time is generated using an exponential\n   distribution using this value as the mean (ms).  The default\n   is zero, which disables random jitter.\n - Max: Limit the random jitter time to this value (ms).\n\t- Pct: odds (0-100) that a random jitter value for the packet\n   will be generated.  Otherwise, a jitter value of zero\n   is used, and the packet will only be delayed by the jitter\n   system if necessary to retain order, due to the jitter of a\n   previous packet.\n\n All values are [global float]\n\n Fake jitter is simulated after fake lag, but before reordering."]
    k_ESteamNetworkingConfig_FakePacketJitter_Send_Max = 54,
    #[doc = " Simulated jitter/clumping.\n\n For each packet, a jitter value is determined (which may\n be zero).  This amount is added as extra delay to the\n packet.  When a subsequent packet is queued, it receives its\n own random jitter amount from the current time.  if this would\n result in the packets being delivered out of order, the later\n packet queue time is adjusted to happen after the first packet.\n Thus simulating jitter by itself will not reorder packets, but it\n can \"clump\" them.\n\n\t- Avg: A random jitter time is generated using an exponential\n   distribution using this value as the mean (ms).  The default\n   is zero, which disables random jitter.\n - Max: Limit the random jitter time to this value (ms).\n\t- Pct: odds (0-100) that a random jitter value for the packet\n   will be generated.  Otherwise, a jitter value of zero\n   is used, and the packet will only be delayed by the jitter\n   system if necessary to retain order, due to the jitter of a\n   previous packet.\n\n All values are [global float]\n\n Fake jitter is simulated after fake lag, but before reordering."]
    k_ESteamNetworkingConfig_FakePacketJitter_Send_Pct = 55,
    #[doc = " Simulated jitter/clumping.\n\n For each packet, a jitter value is determined (which may\n be zero).  This amount is added as extra delay to the\n packet.  When a subsequent packet is queued, it receives its\n own random jitter amount from the current time.  if this would\n result in the packets being delivered out of order, the later\n packet queue time is adjusted to happen after the first packet.\n Thus simulating jitter by itself will not reorder packets, but it\n can \"clump\" them.\n\n\t- Avg: A random jitter time is generated using an exponential\n   distribution using this value as the mean (ms).  The default\n   is zero, which disables random jitter.\n - Max: Limit the random jitter time to this value (ms).\n\t- Pct: odds (0-100) that a random jitter value for the packet\n   will be generated.  Otherwise, a jitter value of zero\n   is used, and the packet will only be delayed by the jitter\n   system if necessary to retain order, due to the jitter of a\n   previous packet.\n\n All values are [global float]\n\n Fake jitter is simulated after fake lag, but before reordering."]
    k_ESteamNetworkingConfig_FakePacketJitter_Recv_Avg = 56,
    #[doc = " Simulated jitter/clumping.\n\n For each packet, a jitter value is determined (which may\n be zero).  This amount is added as extra delay to the\n packet.  When a subsequent packet is queued, it receives its\n own random jitter amount from the current time.  if this would\n result in the packets being delivered out of order, the later\n packet queue time is adjusted to happen after the first packet.\n Thus simulating jitter by itself will not reorder packets, but it\n can \"clump\" them.\n\n\t- Avg: A random jitter time is generated using an exponential\n   distribution using this value as the mean (ms).  The default\n   is zero, which disables random jitter.\n - Max: Limit the random jitter time to this value (ms).\n\t- Pct: odds (0-100) that a random jitter value for the packet\n   will be generated.  Otherwise, a jitter value of zero\n   is used, and the packet will only be delayed by the jitter\n   system if necessary to retain order, due to the jitter of a\n   previous packet.\n\n All values are [global float]\n\n Fake jitter is simulated after fake lag, but before reordering."]
    k_ESteamNetworkingConfig_FakePacketJitter_Recv_Max = 57,
    #[doc = " Simulated jitter/clumping.\n\n For each packet, a jitter value is determined (which may\n be zero).  This amount is added as extra delay to the\n packet.  When a subsequent packet is queued, it receives its\n own random jitter amount from the current time.  if this would\n result in the packets being delivered out of order, the later\n packet queue time is adjusted to happen after the first packet.\n Thus simulating jitter by itself will not reorder packets, but it\n can \"clump\" them.\n\n\t- Avg: A random jitter time is generated using an exponential\n   distribution using this value as the mean (ms).  The default\n   is zero, which disables random jitter.\n - Max: Limit the random jitter time to this value (ms).\n\t- Pct: odds (0-100) that a random jitter value for the packet\n   will be generated.  Otherwise, a jitter value of zero\n   is used, and the packet will only be delayed by the jitter\n   system if necessary to retain order, due to the jitter of a\n   previous packet.\n\n All values are [global float]\n\n Fake jitter is simulated after fake lag, but before reordering."]
    k_ESteamNetworkingConfig_FakePacketJitter_Recv_Pct = 58,
    #[doc = " [global float] 0-100 Percentage of packets we will add additional\n delay to.  If other packet(s) are sent/received within this delay\n window (that doesn't also randomly receive the same extra delay),\n then the packets become reordered.\n\n This mechanism is primarily intended to generate out-of-order\n packets.  To simulate random jitter, use the FakePacketJitter.\n Fake packet reordering is applied after fake lag and jitter"]
    k_ESteamNetworkingConfig_FakePacketReorder_Send = 6,
    #[doc = " [global float] 0-100 Percentage of packets we will add additional\n delay to.  If other packet(s) are sent/received within this delay\n window (that doesn't also randomly receive the same extra delay),\n then the packets become reordered.\n\n This mechanism is primarily intended to generate out-of-order\n packets.  To simulate random jitter, use the FakePacketJitter.\n Fake packet reordering is applied after fake lag and jitter"]
    k_ESteamNetworkingConfig_FakePacketReorder_Recv = 7,
    #[doc = " [global int32] Extra delay, in ms, to apply to reordered\n packets.  The same time value is used for sending and receiving."]
    k_ESteamNetworkingConfig_FakePacketReorder_Time = 8,
    #[doc = " [global float 0--100] Globally duplicate some percentage of packets."]
    k_ESteamNetworkingConfig_FakePacketDup_Send = 26,
    #[doc = " [global float 0--100] Globally duplicate some percentage of packets."]
    k_ESteamNetworkingConfig_FakePacketDup_Recv = 27,
    #[doc = " [global int32] Amount of delay, in ms, to delay duplicated packets.\n (We chose a random delay between 0 and this value)"]
    k_ESteamNetworkingConfig_FakePacketDup_TimeMax = 28,
    #[doc = " [global int32] Trace every UDP packet, similar to Wireshark or tcpdump.\n Value is max number of bytes to dump.  -1 disables tracing."]
    k_ESteamNetworkingConfig_PacketTraceMaxBytes = 41,
    k_ESteamNetworkingConfig_FakeRateLimit_Send_Rate = 42,
    k_ESteamNetworkingConfig_FakeRateLimit_Send_Burst = 43,
    k_ESteamNetworkingConfig_FakeRateLimit_Recv_Rate = 44,
    k_ESteamNetworkingConfig_FakeRateLimit_Recv_Burst = 45,
    k_ESteamNetworkingConfig_OutOfOrderCorrectionWindowMicroseconds = 51,
    #[doc = " [connection FnSteamNetConnectionStatusChanged] Callback that will be invoked\n when the state of a connection changes.\n\n IMPORTANT: callbacks are dispatched to the handler that is in effect at the time\n the event occurs, which might be in another thread.  For example, immediately after\n creating a listen socket, you may receive an incoming connection.  And then immediately\n after this, the remote host may close the connection.  All of this could happen\n before the function to create the listen socket has returned.  For this reason,\n callbacks usually must be in effect at the time of object creation.  This means\n you should set them when you are creating the listen socket or connection, or have\n them in effect so they will be inherited at the time of object creation.\n\n For example:\n\n exterm void MyStatusChangedFunc( SteamNetConnectionStatusChangedCallback_t *info );\n SteamNetworkingConfigValue_t opt; opt.SetPtr( k_ESteamNetworkingConfig_Callback_ConnectionStatusChanged, MyStatusChangedFunc );\n SteamNetworkingIPAddr localAddress; localAddress.Clear();\n HSteamListenSocket hListenSock = SteamNetworkingSockets()->CreateListenSocketIP( localAddress, 1, &opt );\n\n When accepting an incoming connection, there is no atomic way to switch the\n callback.  However, if the connection is DOA, AcceptConnection() will fail, and\n you can fetch the state of the connection at that time.\n\n If all connections and listen sockets can use the same callback, the simplest\n method is to set it globally before you create any listen sockets or connections."]
    k_ESteamNetworkingConfig_Callback_ConnectionStatusChanged = 201,
    #[doc = " [global FnSteamNetAuthenticationStatusChanged] Callback that will be invoked\n when our auth state changes.  If you use this, install the callback before creating\n any connections or listen sockets, and don't change it.\n See: ISteamNetworkingUtils::SetGlobalCallback_SteamNetAuthenticationStatusChanged"]
    k_ESteamNetworkingConfig_Callback_AuthStatusChanged = 202,
    #[doc = " [global FnSteamRelayNetworkStatusChanged] Callback that will be invoked\n when our auth state changes.  If you use this, install the callback before creating\n any connections or listen sockets, and don't change it.\n See: ISteamNetworkingUtils::SetGlobalCallback_SteamRelayNetworkStatusChanged"]
    k_ESteamNetworkingConfig_Callback_RelayNetworkStatusChanged = 203,
    #[doc = " [global FnSteamNetworkingMessagesSessionRequest] Callback that will be invoked\n when a peer wants to initiate a SteamNetworkingMessagesSessionRequest.\n See: ISteamNetworkingUtils::SetGlobalCallback_MessagesSessionRequest"]
    k_ESteamNetworkingConfig_Callback_MessagesSessionRequest = 204,
    #[doc = " [global FnSteamNetworkingMessagesSessionFailed] Callback that will be invoked\n when a session you have initiated, or accepted either fails to connect, or loses\n connection in some unexpected way.\n See: ISteamNetworkingUtils::SetGlobalCallback_MessagesSessionFailed"]
    k_ESteamNetworkingConfig_Callback_MessagesSessionFailed = 205,
    #[doc = " [global FnSteamNetworkingSocketsCreateConnectionSignaling] Callback that will\n be invoked when we need to create a signaling object for a connection\n initiated locally.  See: ISteamNetworkingSockets::ConnectP2P,\n ISteamNetworkingMessages."]
    k_ESteamNetworkingConfig_Callback_CreateConnectionSignaling = 206,
    #[doc = " [global FnSteamNetworkingFakeIPResult] Callback that's invoked when\n a FakeIP allocation finishes.  See: ISteamNetworkingSockets::BeginAsyncRequestFakeIP,\n ISteamNetworkingUtils::SetGlobalCallback_FakeIPResult"]
    k_ESteamNetworkingConfig_Callback_FakeIPResult = 207,
    #[doc = " [connection string] Comma-separated list of STUN servers that can be used\n for NAT piercing.  If you set this to an empty string, NAT piercing will\n not be attempted.  Also if \"public\" candidates are not allowed for\n P2P_Transport_ICE_Enable, then this is ignored."]
    k_ESteamNetworkingConfig_P2P_STUN_ServerList = 103,
    #[doc = " [connection int32] What types of ICE candidates to share with the peer.\n See k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_xxx values"]
    k_ESteamNetworkingConfig_P2P_Transport_ICE_Enable = 104,
    #[doc = " [connection int32] When selecting P2P transport, add various\n penalties to the scores for selected transports.  (Route selection\n scores are on a scale of milliseconds.  The score begins with the\n route ping time and is then adjusted.)"]
    k_ESteamNetworkingConfig_P2P_Transport_ICE_Penalty = 105,
    #[doc = " [connection int32] When selecting P2P transport, add various\n penalties to the scores for selected transports.  (Route selection\n scores are on a scale of milliseconds.  The score begins with the\n route ping time and is then adjusted.)"]
    k_ESteamNetworkingConfig_P2P_Transport_SDR_Penalty = 106,
    #[doc = " [connection int32] When selecting P2P transport, add various\n penalties to the scores for selected transports.  (Route selection\n scores are on a scale of milliseconds.  The score begins with the\n route ping time and is then adjusted.)"]
    k_ESteamNetworkingConfig_P2P_TURN_ServerList = 107,
    #[doc = " [connection int32] When selecting P2P transport, add various\n penalties to the scores for selected transports.  (Route selection\n scores are on a scale of milliseconds.  The score begins with the\n route ping time and is then adjusted.)"]
    k_ESteamNetworkingConfig_P2P_TURN_UserList = 108,
    #[doc = " [connection int32] When selecting P2P transport, add various\n penalties to the scores for selected transports.  (Route selection\n scores are on a scale of milliseconds.  The score begins with the\n route ping time and is then adjusted.)"]
    k_ESteamNetworkingConfig_P2P_TURN_PassList = 109,
    #[doc = " [connection int32] When selecting P2P transport, add various\n penalties to the scores for selected transports.  (Route selection\n scores are on a scale of milliseconds.  The score begins with the\n route ping time and is then adjusted.)"]
    k_ESteamNetworkingConfig_P2P_Transport_ICE_Implementation = 110,
    #[doc = " [global int32] If the first N pings to a port all fail, mark that port as unavailable for\n a while, and try a different one.  Some ISPs and routers may drop the first\n packet, so setting this to 1 may greatly disrupt communications."]
    k_ESteamNetworkingConfig_SDRClient_ConsecutitivePingTimeoutsFailInitial = 19,
    #[doc = " [global int32] If N consecutive pings to a port fail, after having received successful\n communication, mark that port as unavailable for a while, and try a\n different one."]
    k_ESteamNetworkingConfig_SDRClient_ConsecutitivePingTimeoutsFail = 20,
    #[doc = " [global int32] Minimum number of lifetime pings we need to send, before we think our estimate\n is solid.  The first ping to each cluster is very often delayed because of NAT,\n routers not having the best route, etc.  Until we've sent a sufficient number\n of pings, our estimate is often inaccurate.  Keep pinging until we get this\n many pings."]
    k_ESteamNetworkingConfig_SDRClient_MinPingsBeforePingAccurate = 21,
    #[doc = " [global int32] Set all steam datagram traffic to originate from the same\n local port. By default, we open up a new UDP socket (on a different local\n port) for each relay.  This is slightly less optimal, but it works around\n some routers that don't implement NAT properly.  If you have intermittent\n problems talking to relays that might be NAT related, try toggling\n this flag"]
    k_ESteamNetworkingConfig_SDRClient_SingleSocket = 22,
    #[doc = " [global string] Code of relay cluster to force use.  If not empty, we will\n only use relays in that cluster.  E.g. 'iad'"]
    k_ESteamNetworkingConfig_SDRClient_ForceRelayCluster = 29,
    #[doc = " [connection string] For development, a base-64 encoded ticket generated\n using the cert tool.  This can be used to connect to a gameserver via SDR\n without a ticket generated using the game coordinator.  (You will still\n need a key that is trusted for your app, however.)\n\n This can also be passed using the SDR_DEVTICKET environment variable"]
    k_ESteamNetworkingConfig_SDRClient_DevTicket = 30,
    #[doc = " [global string] For debugging.  Override list of relays from the config with\n this set (maybe just one).  Comma-separated list."]
    k_ESteamNetworkingConfig_SDRClient_ForceProxyAddr = 31,
    #[doc = " [global string] For debugging.  Force ping times to clusters to be the specified\n values.  A comma separated list of <cluster>=<ms> values.  E.g. \"sto=32,iad=100\"\n\n This is a dev configuration value, you probably should not let users modify it\n in production."]
    k_ESteamNetworkingConfig_SDRClient_FakeClusterPing = 36,
    #[doc = " [global int32] When probing the SteamDatagram network, we limit exploration\n to the closest N POPs, based on our current best approximated ping to that POP."]
    k_ESteamNetworkingConfig_SDRClient_LimitPingProbesToNearestN = 60,
    #[doc = " [global int32] When probing the SteamDatagram network, we limit exploration\n to the closest N POPs, based on our current best approximated ping to that POP."]
    k_ESteamNetworkingConfig_LogLevel_AckRTT = 13,
    #[doc = " [global int32] When probing the SteamDatagram network, we limit exploration\n to the closest N POPs, based on our current best approximated ping to that POP."]
    k_ESteamNetworkingConfig_LogLevel_PacketDecode = 14,
    #[doc = " [global int32] When probing the SteamDatagram network, we limit exploration\n to the closest N POPs, based on our current best approximated ping to that POP."]
    k_ESteamNetworkingConfig_LogLevel_Message = 15,
    #[doc = " [global int32] When probing the SteamDatagram network, we limit exploration\n to the closest N POPs, based on our current best approximated ping to that POP."]
    k_ESteamNetworkingConfig_LogLevel_PacketGaps = 16,
    #[doc = " [global int32] When probing the SteamDatagram network, we limit exploration\n to the closest N POPs, based on our current best approximated ping to that POP."]
    k_ESteamNetworkingConfig_LogLevel_P2PRendezvous = 17,
    #[doc = " [global int32] When probing the SteamDatagram network, we limit exploration\n to the closest N POPs, based on our current best approximated ping to that POP."]
    k_ESteamNetworkingConfig_LogLevel_SDRRelayPings = 18,
    #[doc = " [global int32] When probing the SteamDatagram network, we limit exploration\n to the closest N POPs, based on our current best approximated ping to that POP."]
    k_ESteamNetworkingConfig_ECN = 999,
    #[doc = " [global int32] When probing the SteamDatagram network, we limit exploration\n to the closest N POPs, based on our current best approximated ping to that POP."]
    k_ESteamNetworkingConfig_DELETED_EnumerateDevVars = 35,
    #[doc = " [global int32] When probing the SteamDatagram network, we limit exploration\n to the closest N POPs, based on our current best approximated ping to that POP."]
    k_ESteamNetworkingConfigValue__Force32Bit = 2147483647,
}
pub const k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Default: ::std::os::raw::c_int = -1;
pub const k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Disable: ::std::os::raw::c_int = 0;
pub const k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Relay: ::std::os::raw::c_int = 1;
pub const k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Private: ::std::os::raw::c_int = 2;
pub const k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Public: ::std::os::raw::c_int = 4;
pub const k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_All: ::std::os::raw::c_int = 2147483647;
#[doc = " In a few places we need to set configuration options on listen sockets and connections, and\n have them take effect *before* the listen socket or connection really starts doing anything.\n Creating the object and then setting the options \"immediately\" after creation doesn't work\n completely, because network packets could be received between the time the object is created and\n when the options are applied.  To set options at creation time in a reliable way, they must be\n passed to the creation function.  This structure is used to pass those options.\n\n For the meaning of these fields, see ISteamNetworkingUtils::SetConfigValue.  Basically\n when the object is created, we just iterate over the list of options and call\n ISteamNetworkingUtils::SetConfigValueStruct, where the scope arguments are supplied by the\n object being created."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SteamNetworkingConfigValue_t {
    #[doc = " Which option is being set"]
    pub m_eValue: ESteamNetworkingConfigValue,
    #[doc = " Which field below did you fill in?"]
    pub m_eDataType: ESteamNetworkingConfigDataType,
    pub m_val: SteamNetworkingConfigValue_t__bindgen_ty_1,
}
#[doc = " Option value"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union SteamNetworkingConfigValue_t__bindgen_ty_1 {
    pub m_int32: i32,
    pub m_int64: i64,
    pub m_float: f32,
    pub m_string: *const ::std::os::raw::c_char,
    pub m_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_SteamNetworkingConfigValue_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingConfigValue_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingConfigValue_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(SteamNetworkingConfigValue_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingConfigValue_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SteamNetworkingConfigValue_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_int32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingConfigValue_t__bindgen_ty_1),
            "::",
            stringify!(m_int32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_int64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingConfigValue_t__bindgen_ty_1),
            "::",
            stringify!(m_int64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_float) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingConfigValue_t__bindgen_ty_1),
            "::",
            stringify!(m_float)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_string) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingConfigValue_t__bindgen_ty_1),
            "::",
            stringify!(m_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingConfigValue_t__bindgen_ty_1),
            "::",
            stringify!(m_ptr)
        )
    );
}
#[test]
fn bindgen_test_layout_SteamNetworkingConfigValue_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingConfigValue_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingConfigValue_t>(),
        16usize,
        concat!("Size of: ", stringify!(SteamNetworkingConfigValue_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingConfigValue_t>(),
        8usize,
        concat!("Alignment of ", stringify!(SteamNetworkingConfigValue_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingConfigValue_t),
            "::",
            stringify!(m_eValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eDataType) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingConfigValue_t),
            "::",
            stringify!(m_eDataType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_val) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingConfigValue_t),
            "::",
            stringify!(m_val)
        )
    );
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " Return value of ISteamNetworkintgUtils::GetConfigValue"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamNetworkingGetConfigValueResult {
    k_ESteamNetworkingGetConfigValue_BadValue = -1,
    k_ESteamNetworkingGetConfigValue_BadScopeObj = -2,
    k_ESteamNetworkingGetConfigValue_BufferTooSmall = -3,
    k_ESteamNetworkingGetConfigValue_OK = 1,
    k_ESteamNetworkingGetConfigValue_OKInherited = 2,
    k_ESteamNetworkingGetConfigValueResult__Force32Bit = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Detail level for diagnostic output callback.\n See ISteamNetworkingUtils::SetDebugOutputFunction"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamNetworkingSocketsDebugOutputType {
    k_ESteamNetworkingSocketsDebugOutputType_None = 0,
    k_ESteamNetworkingSocketsDebugOutputType_Bug = 1,
    k_ESteamNetworkingSocketsDebugOutputType_Error = 2,
    k_ESteamNetworkingSocketsDebugOutputType_Important = 3,
    k_ESteamNetworkingSocketsDebugOutputType_Warning = 4,
    k_ESteamNetworkingSocketsDebugOutputType_Msg = 5,
    k_ESteamNetworkingSocketsDebugOutputType_Verbose = 6,
    k_ESteamNetworkingSocketsDebugOutputType_Debug = 7,
    k_ESteamNetworkingSocketsDebugOutputType_Everything = 8,
    k_ESteamNetworkingSocketsDebugOutputType__Force32Bit = 2147483647,
}
#[doc = " Setup callback for debug output, and the desired verbosity you want."]
pub type FSteamNetworkingSocketsDebugOutput = ::std::option::Option<
    unsafe extern "C" fn(
        nType: ESteamNetworkingSocketsDebugOutputType,
        pszMsg: *const ::std::os::raw::c_char,
    ),
>;
#[doc = " The POPID \"dev\" is used in non-production environments for testing."]
pub const k_SteamDatagramPOPID_dev: SteamNetworkingPOPID = 6579574;
#[doc = " Utility class for printing a SteamNetworkingPOPID."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamNetworkingPOPIDRender {
    pub buf: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_SteamNetworkingPOPIDRender() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingPOPIDRender> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingPOPIDRender>(),
        8usize,
        concat!("Size of: ", stringify!(SteamNetworkingPOPIDRender))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingPOPIDRender>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamNetworkingPOPIDRender))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingPOPIDRender),
            "::",
            stringify!(buf)
        )
    );
}
#[doc = " A message that has been received."]
pub type ISteamNetworkingMessage = SteamNetworkingMessage_t;
pub type SteamDatagramErrMsg = SteamNetworkingErrMsg;
#[repr(C)]
pub struct ISteamNetworkingMessages__bindgen_vtable(::std::os::raw::c_void);
#[doc = " The non-connection-oriented interface to send and receive messages\n (whether they be \"clients\" or \"servers\").\n\n ISteamNetworkingSockets is connection-oriented (like TCP), meaning you\n need to listen and connect, and then you send messages using a connection\n handle.  ISteamNetworkingMessages is more like UDP, in that you can just send\n messages to arbitrary peers at any time.  The underlying connections are\n established implicitly.\n\n Under the hood ISteamNetworkingMessages works on top of the ISteamNetworkingSockets\n code, so you get the same routing and messaging efficiency.  The difference is\n mainly in your responsibility to explicitly establish a connection and\n the type of feedback you get about the state of the connection.  Both\n interfaces can do \"P2P\" communications, and both support both unreliable\n and reliable messages, fragmentation and reassembly.\n\n The primary purpose of this interface is to be \"like UDP\", so that UDP-based code\n can be ported easily to take advantage of relayed connections.  If you find\n yourself needing more low level information or control, or to be able to better\n handle failure, then you probably need to use ISteamNetworkingSockets directly.\n Also, note that if your main goal is to obtain a connection between two peers\n without concerning yourself with assigning roles of \"client\" and \"server\",\n you may find the symmetric connection mode of ISteamNetworkingSockets useful.\n (See k_ESteamNetworkingConfig_SymmetricConnect.)\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamNetworkingMessages {
    pub vtable_: *const ISteamNetworkingMessages__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamNetworkingMessages() {
    assert_eq!(
        ::std::mem::size_of::<ISteamNetworkingMessages>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamNetworkingMessages))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamNetworkingMessages>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamNetworkingMessages))
    );
}
#[doc = " Posted when a remote host is sending us a message, and we do not already have a session with them"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SteamNetworkingMessagesSessionRequest_t {
    pub m_identityRemote: SteamNetworkingIdentity,
}
pub const SteamNetworkingMessagesSessionRequest_t_k_iCallback:
    SteamNetworkingMessagesSessionRequest_t__bindgen_ty_1 =
    SteamNetworkingMessagesSessionRequest_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamNetworkingMessagesSessionRequest_t__bindgen_ty_1 {
    k_iCallback = 1251,
}
#[test]
fn bindgen_test_layout_SteamNetworkingMessagesSessionRequest_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingMessagesSessionRequest_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingMessagesSessionRequest_t>(),
        136usize,
        concat!(
            "Size of: ",
            stringify!(SteamNetworkingMessagesSessionRequest_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingMessagesSessionRequest_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SteamNetworkingMessagesSessionRequest_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_identityRemote) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessagesSessionRequest_t),
            "::",
            stringify!(m_identityRemote)
        )
    );
}
#[doc = " Posted when we fail to establish a connection, or we detect that communications\n have been disrupted it an unusual way.  There is no notification when a peer proactively\n closes the session.  (\"Closed by peer\" is not a concept of UDP-style communications, and\n SteamNetworkingMessages is primarily intended to make porting UDP code easy.)\n\n Remember: callbacks are asynchronous.   See notes on SendMessageToUser,\n and k_nSteamNetworkingSend_AutoRestartBrokenSession in particular.\n\n Also, if a session times out due to inactivity, no callbacks will be posted.  The only\n way to detect that this is happening is that querying the session state may return\n none, connecting, and findingroute again."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct SteamNetworkingMessagesSessionFailed_t {
    #[doc = " Detailed info about the session that failed.\n SteamNetConnectionInfo_t::m_identityRemote indicates who this session\n was with."]
    pub m_info: SteamNetConnectionInfo_t,
}
pub const SteamNetworkingMessagesSessionFailed_t_k_iCallback:
    SteamNetworkingMessagesSessionFailed_t__bindgen_ty_1 =
    SteamNetworkingMessagesSessionFailed_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamNetworkingMessagesSessionFailed_t__bindgen_ty_1 {
    k_iCallback = 1252,
}
#[test]
fn bindgen_test_layout_SteamNetworkingMessagesSessionFailed_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingMessagesSessionFailed_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingMessagesSessionFailed_t>(),
        696usize,
        concat!(
            "Size of: ",
            stringify!(SteamNetworkingMessagesSessionFailed_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingMessagesSessionFailed_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SteamNetworkingMessagesSessionFailed_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessagesSessionFailed_t),
            "::",
            stringify!(m_info)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamNetworkingConnectionSignaling {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamNetworkingSignalingRecvContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamNetworkingFakeUDPPort {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct ISteamNetworkingSockets__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Lower level networking API.\n\n - Connection-oriented API (like TCP, not UDP).  When sending and receiving\n   messages, a connection handle is used.  (For a UDP-style interface, where\n   the peer is identified by their address with each send/recv call, see\n   ISteamNetworkingMessages.)  The typical pattern is for a \"server\" to \"listen\"\n   on a \"listen socket.\"  A \"client\" will \"connect\" to the server, and the\n   server will \"accept\" the connection.  If you have a symmetric situation\n   where either peer may initiate the connection and server/client roles are\n   not clearly defined, check out k_ESteamNetworkingConfig_SymmetricConnect.\n - But unlike TCP, it's message-oriented, not stream-oriented.\n - Mix of reliable and unreliable messages\n - Fragmentation and reassembly\n - Supports connectivity over plain UDP\n - Also supports SDR (\"Steam Datagram Relay\") connections, which are\n   addressed by the identity of the peer.  There is a \"P2P\" use case and\n   a \"hosted dedicated server\" use case.\n\n Note that neither of the terms \"connection\" nor \"socket\" necessarily correspond\n one-to-one with an underlying UDP socket.  An attempt has been made to\n keep the semantics as similar to the standard socket model when appropriate,\n but some deviations do exist.\n\n See also: ISteamNetworkingMessages, the UDP-style interface.  This API might be\n easier to use, especially when porting existing UDP code."]
#[repr(C)]
#[derive(Debug)]
pub struct ISteamNetworkingSockets {
    pub vtable_: *const ISteamNetworkingSockets__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamNetworkingSockets() {
    assert_eq!(
        ::std::mem::size_of::<ISteamNetworkingSockets>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamNetworkingSockets))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamNetworkingSockets>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamNetworkingSockets))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN23ISteamNetworkingSocketsD1Ev"]
    pub fn ISteamNetworkingSockets_ISteamNetworkingSockets_destructor(
        this: *mut ISteamNetworkingSockets,
    );
}
impl ISteamNetworkingSockets {
    #[inline]
    pub unsafe fn destruct(&mut self) {
        ISteamNetworkingSockets_ISteamNetworkingSockets_destructor(self)
    }
}
#[doc = " This callback is posted whenever a connection is created, destroyed, or changes state.\n The m_info field will contain a complete description of the connection at the time the\n change occurred and the callback was posted.  In particular, m_eState will have the\n new connection state.\n\n You will usually need to listen for this callback to know when:\n - A new connection arrives on a listen socket.\n   m_info.m_hListenSocket will be set, m_eOldState = k_ESteamNetworkingConnectionState_None,\n   and m_info.m_eState = k_ESteamNetworkingConnectionState_Connecting.\n   See ISteamNetworkigSockets::AcceptConnection.\n - A connection you initiated has been accepted by the remote host.\n   m_eOldState = k_ESteamNetworkingConnectionState_Connecting, and\n   m_info.m_eState = k_ESteamNetworkingConnectionState_Connected.\n   Some connections might transition to k_ESteamNetworkingConnectionState_FindingRoute first.\n - A connection has been actively rejected or closed by the remote host.\n   m_eOldState = k_ESteamNetworkingConnectionState_Connecting or k_ESteamNetworkingConnectionState_Connected,\n   and m_info.m_eState = k_ESteamNetworkingConnectionState_ClosedByPeer.  m_info.m_eEndReason\n   and m_info.m_szEndDebug will have for more details.\n   NOTE: upon receiving this callback, you must still destroy the connection using\n   ISteamNetworkingSockets::CloseConnection to free up local resources.  (The details\n   passed to the function are not used in this case, since the connection is already closed.)\n - A problem was detected with the connection, and it has been closed by the local host.\n   The most common failure is timeout, but other configuration or authentication failures\n   can cause this.  m_eOldState = k_ESteamNetworkingConnectionState_Connecting or\n   k_ESteamNetworkingConnectionState_Connected, and m_info.m_eState = k_ESteamNetworkingConnectionState_ProblemDetectedLocally.\n   m_info.m_eEndReason and m_info.m_szEndDebug will have for more details.\n   NOTE: upon receiving this callback, you must still destroy the connection using\n   ISteamNetworkingSockets::CloseConnection to free up local resources.  (The details\n   passed to the function are not used in this case, since the connection is already closed.)\n\n Remember that callbacks are posted to a queue, and networking connections can\n change at any time.  It is possible that the connection has already changed\n state by the time you process this callback.\n\n Also note that callbacks will be posted when connections are created and destroyed by your own API calls."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SteamNetConnectionStatusChangedCallback_t {
    #[doc = " Connection handle"]
    pub m_hConn: HSteamNetConnection,
    #[doc = " Full connection info"]
    pub m_info: SteamNetConnectionInfo_t,
    #[doc = " Previous state.  (Current state is in m_info.m_eState)"]
    pub m_eOldState: ESteamNetworkingConnectionState,
}
pub const SteamNetConnectionStatusChangedCallback_t_k_iCallback:
    SteamNetConnectionStatusChangedCallback_t__bindgen_ty_1 =
    SteamNetConnectionStatusChangedCallback_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamNetConnectionStatusChangedCallback_t__bindgen_ty_1 {
    k_iCallback = 1221,
}
#[test]
fn bindgen_test_layout_SteamNetConnectionStatusChangedCallback_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetConnectionStatusChangedCallback_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetConnectionStatusChangedCallback_t>(),
        704usize,
        concat!(
            "Size of: ",
            stringify!(SteamNetConnectionStatusChangedCallback_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetConnectionStatusChangedCallback_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SteamNetConnectionStatusChangedCallback_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hConn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionStatusChangedCallback_t),
            "::",
            stringify!(m_hConn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_info) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionStatusChangedCallback_t),
            "::",
            stringify!(m_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eOldState) as usize - ptr as usize },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionStatusChangedCallback_t),
            "::",
            stringify!(m_eOldState)
        )
    );
}
#[doc = " A struct used to describe our readiness to participate in authenticated,\n encrypted communication.  In order to do this we need:\n\n - The list of trusted CA certificates that might be relevant for this\n   app.\n - A valid certificate issued by a CA.\n\n This callback is posted whenever the state of our readiness changes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamNetAuthenticationStatus_t {
    #[doc = " Status"]
    pub m_eAvail: ESteamNetworkingAvailability,
    #[doc = " Non-localized English language status.  For diagnostic/debugging\n purposes only."]
    pub m_debugMsg: [::std::os::raw::c_char; 256usize],
}
pub const SteamNetAuthenticationStatus_t_k_iCallback: SteamNetAuthenticationStatus_t__bindgen_ty_1 =
    SteamNetAuthenticationStatus_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamNetAuthenticationStatus_t__bindgen_ty_1 {
    k_iCallback = 1222,
}
#[test]
fn bindgen_test_layout_SteamNetAuthenticationStatus_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetAuthenticationStatus_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetAuthenticationStatus_t>(),
        260usize,
        concat!("Size of: ", stringify!(SteamNetAuthenticationStatus_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetAuthenticationStatus_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamNetAuthenticationStatus_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eAvail) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetAuthenticationStatus_t),
            "::",
            stringify!(m_eAvail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_debugMsg) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetAuthenticationStatus_t),
            "::",
            stringify!(m_debugMsg)
        )
    );
}
#[repr(C)]
pub struct ISteamNetworkingUtils__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Misc networking utilities for checking the local networking environment\n and estimating pings."]
#[repr(C)]
#[derive(Debug)]
pub struct ISteamNetworkingUtils {
    pub vtable_: *const ISteamNetworkingUtils__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamNetworkingUtils() {
    assert_eq!(
        ::std::mem::size_of::<ISteamNetworkingUtils>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamNetworkingUtils))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamNetworkingUtils>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamNetworkingUtils))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN21ISteamNetworkingUtilsD1Ev"]
    pub fn ISteamNetworkingUtils_ISteamNetworkingUtils_destructor(this: *mut ISteamNetworkingUtils);
}
impl ISteamNetworkingUtils {
    #[inline]
    pub unsafe fn destruct(&mut self) {
        ISteamNetworkingUtils_ISteamNetworkingUtils_destructor(self)
    }
}
#[doc = " A struct used to describe our readiness to use the relay network.\n To do this we first need to fetch the network configuration,\n which describes what POPs are available."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamRelayNetworkStatus_t {
    #[doc = " Summary status.  When this is \"current\", initialization has\n completed.  Anything else means you are not ready yet, or\n there is a significant problem."]
    pub m_eAvail: ESteamNetworkingAvailability,
    #[doc = " Nonzero if latency measurement is in progress (or pending,\n awaiting a prerequisite)."]
    pub m_bPingMeasurementInProgress: ::std::os::raw::c_int,
    #[doc = " Status obtaining the network config.  This is a prerequisite\n for relay network access.\n\n Failure to obtain the network config almost always indicates\n a problem with the local internet connection."]
    pub m_eAvailNetworkConfig: ESteamNetworkingAvailability,
    #[doc = " Current ability to communicate with ANY relay.  Note that\n the complete failure to communicate with any relays almost\n always indicates a problem with the local Internet connection.\n (However, just because you can reach a single relay doesn't\n mean that the local connection is in perfect health.)"]
    pub m_eAvailAnyRelay: ESteamNetworkingAvailability,
    #[doc = " Non-localized English language status.  For diagnostic/debugging\n purposes only."]
    pub m_debugMsg: [::std::os::raw::c_char; 256usize],
}
pub const SteamRelayNetworkStatus_t_k_iCallback: SteamRelayNetworkStatus_t__bindgen_ty_1 =
    SteamRelayNetworkStatus_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamRelayNetworkStatus_t__bindgen_ty_1 {
    k_iCallback = 1281,
}
#[test]
fn bindgen_test_layout_SteamRelayNetworkStatus_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamRelayNetworkStatus_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamRelayNetworkStatus_t>(),
        272usize,
        concat!("Size of: ", stringify!(SteamRelayNetworkStatus_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamRelayNetworkStatus_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamRelayNetworkStatus_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eAvail) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamRelayNetworkStatus_t),
            "::",
            stringify!(m_eAvail)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_bPingMeasurementInProgress) as usize - ptr as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamRelayNetworkStatus_t),
            "::",
            stringify!(m_bPingMeasurementInProgress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eAvailNetworkConfig) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamRelayNetworkStatus_t),
            "::",
            stringify!(m_eAvailNetworkConfig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eAvailAnyRelay) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamRelayNetworkStatus_t),
            "::",
            stringify!(m_eAvailAnyRelay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_debugMsg) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamRelayNetworkStatus_t),
            "::",
            stringify!(m_debugMsg)
        )
    );
}
#[doc = " Utility class for printing a SteamNetworkingIdentity.\n E.g. printf( \"Identity is '%s'\\n\", SteamNetworkingIdentityRender( identity ).c_str() );"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamNetworkingIdentityRender {
    pub buf: [::std::os::raw::c_char; 128usize],
}
#[test]
fn bindgen_test_layout_SteamNetworkingIdentityRender() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingIdentityRender> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingIdentityRender>(),
        128usize,
        concat!("Size of: ", stringify!(SteamNetworkingIdentityRender))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingIdentityRender>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamNetworkingIdentityRender))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIdentityRender),
            "::",
            stringify!(buf)
        )
    );
}
#[doc = " Utility class for printing a SteamNetworkingIPAddrRender."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamNetworkingIPAddrRender {
    pub buf: [::std::os::raw::c_char; 48usize],
}
#[test]
fn bindgen_test_layout_SteamNetworkingIPAddrRender() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingIPAddrRender> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingIPAddrRender>(),
        48usize,
        concat!("Size of: ", stringify!(SteamNetworkingIPAddrRender))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingIPAddrRender>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamNetworkingIPAddrRender))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIPAddrRender),
            "::",
            stringify!(buf)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamAPIInitResult {
    k_ESteamAPIInitResult_OK = 0,
    k_ESteamAPIInitResult_FailedGeneric = 1,
    k_ESteamAPIInitResult_NoSteamClient = 2,
    k_ESteamAPIInitResult_VersionMismatch = 3,
}
extern "C" {
    pub fn SteamAPI_InitFlat(pOutErrMsg: *mut SteamErrMsg) -> ESteamAPIInitResult;
}
extern "C" {
    pub fn SteamAPI_Shutdown();
}
extern "C" {
    pub fn SteamAPI_RestartAppIfNecessary(unOwnAppID: uint32) -> bool;
}
extern "C" {
    pub fn SteamAPI_ReleaseCurrentThreadMemory();
}
extern "C" {
    pub fn SteamAPI_WriteMiniDump(
        uStructuredExceptionCode: uint32,
        pvExceptionInfo: *mut ::std::os::raw::c_void,
        uBuildID: uint32,
    );
}
extern "C" {
    pub fn SteamAPI_SetMiniDumpComment(pchMsg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn SteamAPI_IsSteamRunning() -> bool;
}
extern "C" {
    pub fn SteamAPI_GetSteamInstallPath() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_SetTryCatchCallbacks(bTryCatchCallbacks: bool);
}
extern "C" {
    #[doc = " Inform the API that you wish to use manual event dispatch.  This must be called after SteamAPI_Init, but before\n you use any of the other manual dispatch functions below."]
    pub fn SteamAPI_ManualDispatch_Init();
}
extern "C" {
    #[doc = " Perform certain periodic actions that need to be performed."]
    pub fn SteamAPI_ManualDispatch_RunFrame(hSteamPipe: HSteamPipe);
}
extern "C" {
    #[doc = " Fetch the next pending callback on the given pipe, if any.  If a callback is available, true is returned\n and the structure is populated.  In this case, you MUST call SteamAPI_ManualDispatch_FreeLastCallback\n (after dispatching the callback) before calling SteamAPI_ManualDispatch_GetNextCallback again."]
    pub fn SteamAPI_ManualDispatch_GetNextCallback(
        hSteamPipe: HSteamPipe,
        pCallbackMsg: *mut CallbackMsg_t,
    ) -> bool;
}
extern "C" {
    #[doc = " You must call this after dispatching the callback, if SteamAPI_ManualDispatch_GetNextCallback returns true."]
    pub fn SteamAPI_ManualDispatch_FreeLastCallback(hSteamPipe: HSteamPipe);
}
extern "C" {
    #[doc = " Return the call result for the specified call on the specified pipe.  You really should\n only call this in a handler for SteamAPICallCompleted_t callback."]
    pub fn SteamAPI_ManualDispatch_GetAPICallResult(
        hSteamPipe: HSteamPipe,
        hSteamAPICall: SteamAPICall_t,
        pCallback: *mut ::std::os::raw::c_void,
        cubCallback: ::std::os::raw::c_int,
        iCallbackExpected: ::std::os::raw::c_int,
        pbFailed: *mut bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamInternal_SteamAPI_Init(
        pszInternalCheckInterfaceVersions: *const ::std::os::raw::c_char,
        pOutErrMsg: *mut SteamErrMsg,
    ) -> ESteamAPIInitResult;
}
#[repr(C)]
pub struct ISteamGameServer__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamGameServer {
    pub vtable_: *const ISteamGameServer__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamGameServer() {
    assert_eq!(
        ::std::mem::size_of::<ISteamGameServer>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamGameServer))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamGameServer>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamGameServer))
    );
}
#[repr(C)]
pub struct ISteamGameServerStats__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamGameServerStats {
    pub vtable_: *const ISteamGameServerStats__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamGameServerStats() {
    assert_eq!(
        ::std::mem::size_of::<ISteamGameServerStats>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamGameServerStats))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamGameServerStats>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamGameServerStats))
    );
}
pub type uint64_steamid = uint64;
pub type uint64_gameid = uint64;
extern "C" {
    pub fn SteamAPI_ISteamClient_CreateSteamPipe(self_: *mut ISteamClient) -> HSteamPipe;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_BReleaseSteamPipe(
        self_: *mut ISteamClient,
        hSteamPipe: HSteamPipe,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_ConnectToGlobalUser(
        self_: *mut ISteamClient,
        hSteamPipe: HSteamPipe,
    ) -> HSteamUser;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_CreateLocalUser(
        self_: *mut ISteamClient,
        phSteamPipe: *mut HSteamPipe,
        eAccountType: EAccountType,
    ) -> HSteamUser;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_ReleaseUser(
        self_: *mut ISteamClient,
        hSteamPipe: HSteamPipe,
        hUser: HSteamUser,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamUser(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamUser;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamGameServer(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamGameServer;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_SetLocalIPBinding(
        self_: *mut ISteamClient,
        unIP: *const SteamIPAddress_t,
        usPort: uint16,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamFriends(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamFriends;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamUtils(
        self_: *mut ISteamClient,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamUtils;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamMatchmaking(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamMatchmaking;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamMatchmakingServers(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamMatchmakingServers;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamGenericInterface(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamUserStats(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamUserStats;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamGameServerStats(
        self_: *mut ISteamClient,
        hSteamuser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamGameServerStats;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamApps(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamApps;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamNetworking(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamNetworking;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamRemoteStorage(
        self_: *mut ISteamClient,
        hSteamuser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamRemoteStorage;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamScreenshots(
        self_: *mut ISteamClient,
        hSteamuser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamScreenshots;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamGameSearch(
        self_: *mut ISteamClient,
        hSteamuser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamGameSearch;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetIPCCallCount(self_: *mut ISteamClient) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_SetWarningMessageHook(
        self_: *mut ISteamClient,
        pFunction: SteamAPIWarningMessageHook_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamClient_BShutdownIfAllPipesClosed(self_: *mut ISteamClient) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamHTTP(
        self_: *mut ISteamClient,
        hSteamuser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamHTTP;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamController(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamController;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamUGC(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamUGC;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamMusic(
        self_: *mut ISteamClient,
        hSteamuser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamMusic;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamMusicRemote(
        self_: *mut ISteamClient,
        hSteamuser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamMusicRemote;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamHTMLSurface(
        self_: *mut ISteamClient,
        hSteamuser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamHTMLSurface;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamInventory(
        self_: *mut ISteamClient,
        hSteamuser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamInventory;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamVideo(
        self_: *mut ISteamClient,
        hSteamuser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamVideo;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamParentalSettings(
        self_: *mut ISteamClient,
        hSteamuser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamParentalSettings;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamInput(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamInput;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamParties(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamParties;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamRemotePlay(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamRemotePlay;
}
extern "C" {
    pub fn SteamAPI_SteamUser_v023() -> *mut ISteamUser;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetHSteamUser(self_: *mut ISteamUser) -> HSteamUser;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_BLoggedOn(self_: *mut ISteamUser) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetSteamID(self_: *mut ISteamUser) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_InitiateGameConnection_DEPRECATED(
        self_: *mut ISteamUser,
        pAuthBlob: *mut ::std::os::raw::c_void,
        cbMaxAuthBlob: ::std::os::raw::c_int,
        steamIDGameServer: uint64_steamid,
        unIPServer: uint32,
        usPortServer: uint16,
        bSecure: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_TerminateGameConnection_DEPRECATED(
        self_: *mut ISteamUser,
        unIPServer: uint32,
        usPortServer: uint16,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamUser_TrackAppUsageEvent(
        self_: *mut ISteamUser,
        gameID: uint64_gameid,
        eAppUsageEvent: ::std::os::raw::c_int,
        pchExtraInfo: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetUserDataFolder(
        self_: *mut ISteamUser,
        pchBuffer: *mut ::std::os::raw::c_char,
        cubBuffer: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_StartVoiceRecording(self_: *mut ISteamUser);
}
extern "C" {
    pub fn SteamAPI_ISteamUser_StopVoiceRecording(self_: *mut ISteamUser);
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetAvailableVoice(
        self_: *mut ISteamUser,
        pcbCompressed: *mut uint32,
        pcbUncompressed_Deprecated: *mut uint32,
        nUncompressedVoiceDesiredSampleRate_Deprecated: uint32,
    ) -> EVoiceResult;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetVoice(
        self_: *mut ISteamUser,
        bWantCompressed: bool,
        pDestBuffer: *mut ::std::os::raw::c_void,
        cbDestBufferSize: uint32,
        nBytesWritten: *mut uint32,
        bWantUncompressed_Deprecated: bool,
        pUncompressedDestBuffer_Deprecated: *mut ::std::os::raw::c_void,
        cbUncompressedDestBufferSize_Deprecated: uint32,
        nUncompressBytesWritten_Deprecated: *mut uint32,
        nUncompressedVoiceDesiredSampleRate_Deprecated: uint32,
    ) -> EVoiceResult;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_DecompressVoice(
        self_: *mut ISteamUser,
        pCompressed: *const ::std::os::raw::c_void,
        cbCompressed: uint32,
        pDestBuffer: *mut ::std::os::raw::c_void,
        cbDestBufferSize: uint32,
        nBytesWritten: *mut uint32,
        nDesiredSampleRate: uint32,
    ) -> EVoiceResult;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetVoiceOptimalSampleRate(self_: *mut ISteamUser) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetAuthSessionTicket(
        self_: *mut ISteamUser,
        pTicket: *mut ::std::os::raw::c_void,
        cbMaxTicket: ::std::os::raw::c_int,
        pcbTicket: *mut uint32,
        pSteamNetworkingIdentity: *const SteamNetworkingIdentity,
    ) -> HAuthTicket;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetAuthTicketForWebApi(
        self_: *mut ISteamUser,
        pchIdentity: *const ::std::os::raw::c_char,
    ) -> HAuthTicket;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_BeginAuthSession(
        self_: *mut ISteamUser,
        pAuthTicket: *const ::std::os::raw::c_void,
        cbAuthTicket: ::std::os::raw::c_int,
        steamID: uint64_steamid,
    ) -> EBeginAuthSessionResult;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_EndAuthSession(self_: *mut ISteamUser, steamID: uint64_steamid);
}
extern "C" {
    pub fn SteamAPI_ISteamUser_CancelAuthTicket(self_: *mut ISteamUser, hAuthTicket: HAuthTicket);
}
extern "C" {
    pub fn SteamAPI_ISteamUser_UserHasLicenseForApp(
        self_: *mut ISteamUser,
        steamID: uint64_steamid,
        appID: AppId_t,
    ) -> EUserHasLicenseForAppResult;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_BIsBehindNAT(self_: *mut ISteamUser) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_AdvertiseGame(
        self_: *mut ISteamUser,
        steamIDGameServer: uint64_steamid,
        unIPServer: uint32,
        usPortServer: uint16,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamUser_RequestEncryptedAppTicket(
        self_: *mut ISteamUser,
        pDataToInclude: *mut ::std::os::raw::c_void,
        cbDataToInclude: ::std::os::raw::c_int,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetEncryptedAppTicket(
        self_: *mut ISteamUser,
        pTicket: *mut ::std::os::raw::c_void,
        cbMaxTicket: ::std::os::raw::c_int,
        pcbTicket: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetGameBadgeLevel(
        self_: *mut ISteamUser,
        nSeries: ::std::os::raw::c_int,
        bFoil: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetPlayerSteamLevel(self_: *mut ISteamUser)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_RequestStoreAuthURL(
        self_: *mut ISteamUser,
        pchRedirectURL: *const ::std::os::raw::c_char,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_BIsPhoneVerified(self_: *mut ISteamUser) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_BIsTwoFactorEnabled(self_: *mut ISteamUser) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_BIsPhoneIdentifying(self_: *mut ISteamUser) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_BIsPhoneRequiringVerification(self_: *mut ISteamUser) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetMarketEligibility(self_: *mut ISteamUser) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetDurationControl(self_: *mut ISteamUser) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_BSetDurationControlOnlineState(
        self_: *mut ISteamUser,
        eNewState: EDurationControlOnlineState,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamFriends_v018() -> *mut ISteamFriends;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetPersonaName(
        self_: *mut ISteamFriends,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetPersonaState(self_: *mut ISteamFriends) -> EPersonaState;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendCount(
        self_: *mut ISteamFriends,
        iFriendFlags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendByIndex(
        self_: *mut ISteamFriends,
        iFriend: ::std::os::raw::c_int,
        iFriendFlags: ::std::os::raw::c_int,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendRelationship(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
    ) -> EFriendRelationship;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendPersonaState(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
    ) -> EPersonaState;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendPersonaName(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendGamePlayed(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
        pFriendGameInfo: *mut FriendGameInfo_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendPersonaNameHistory(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
        iPersonaName: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendSteamLevel(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetPlayerNickname(
        self_: *mut ISteamFriends,
        steamIDPlayer: uint64_steamid,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendsGroupCount(
        self_: *mut ISteamFriends,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendsGroupIDByIndex(
        self_: *mut ISteamFriends,
        iFG: ::std::os::raw::c_int,
    ) -> FriendsGroupID_t;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendsGroupName(
        self_: *mut ISteamFriends,
        friendsGroupID: FriendsGroupID_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendsGroupMembersCount(
        self_: *mut ISteamFriends,
        friendsGroupID: FriendsGroupID_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendsGroupMembersList(
        self_: *mut ISteamFriends,
        friendsGroupID: FriendsGroupID_t,
        pOutSteamIDMembers: *mut CSteamID,
        nMembersCount: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_HasFriend(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
        iFriendFlags: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetClanCount(self_: *mut ISteamFriends) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetClanByIndex(
        self_: *mut ISteamFriends,
        iClan: ::std::os::raw::c_int,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetClanName(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetClanTag(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetClanActivityCounts(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
        pnOnline: *mut ::std::os::raw::c_int,
        pnInGame: *mut ::std::os::raw::c_int,
        pnChatting: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_DownloadClanActivityCounts(
        self_: *mut ISteamFriends,
        psteamIDClans: *mut CSteamID,
        cClansToRequest: ::std::os::raw::c_int,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendCountFromSource(
        self_: *mut ISteamFriends,
        steamIDSource: uint64_steamid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendFromSourceByIndex(
        self_: *mut ISteamFriends,
        steamIDSource: uint64_steamid,
        iFriend: ::std::os::raw::c_int,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_IsUserInSource(
        self_: *mut ISteamFriends,
        steamIDUser: uint64_steamid,
        steamIDSource: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_SetInGameVoiceSpeaking(
        self_: *mut ISteamFriends,
        steamIDUser: uint64_steamid,
        bSpeaking: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_ActivateGameOverlay(
        self_: *mut ISteamFriends,
        pchDialog: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_ActivateGameOverlayToUser(
        self_: *mut ISteamFriends,
        pchDialog: *const ::std::os::raw::c_char,
        steamID: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_ActivateGameOverlayToWebPage(
        self_: *mut ISteamFriends,
        pchURL: *const ::std::os::raw::c_char,
        eMode: EActivateGameOverlayToWebPageMode,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_ActivateGameOverlayToStore(
        self_: *mut ISteamFriends,
        nAppID: AppId_t,
        eFlag: EOverlayToStoreFlag,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_SetPlayedWith(
        self_: *mut ISteamFriends,
        steamIDUserPlayedWith: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_ActivateGameOverlayInviteDialog(
        self_: *mut ISteamFriends,
        steamIDLobby: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetSmallFriendAvatar(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetMediumFriendAvatar(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetLargeFriendAvatar(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_RequestUserInformation(
        self_: *mut ISteamFriends,
        steamIDUser: uint64_steamid,
        bRequireNameOnly: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_RequestClanOfficerList(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetClanOwner(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetClanOfficerCount(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetClanOfficerByIndex(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
        iOfficer: ::std::os::raw::c_int,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_SetRichPresence(
        self_: *mut ISteamFriends,
        pchKey: *const ::std::os::raw::c_char,
        pchValue: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_ClearRichPresence(self_: *mut ISteamFriends);
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendRichPresence(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
        pchKey: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendRichPresenceKeyCount(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendRichPresenceKeyByIndex(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
        iKey: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_RequestFriendRichPresence(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_InviteUserToGame(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
        pchConnectString: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetCoplayFriendCount(
        self_: *mut ISteamFriends,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetCoplayFriend(
        self_: *mut ISteamFriends,
        iCoplayFriend: ::std::os::raw::c_int,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendCoplayTime(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendCoplayGame(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
    ) -> AppId_t;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_JoinClanChatRoom(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_LeaveClanChatRoom(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetClanChatMemberCount(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetChatMemberByIndex(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
        iUser: ::std::os::raw::c_int,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_SendClanChatMessage(
        self_: *mut ISteamFriends,
        steamIDClanChat: uint64_steamid,
        pchText: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetClanChatMessage(
        self_: *mut ISteamFriends,
        steamIDClanChat: uint64_steamid,
        iMessage: ::std::os::raw::c_int,
        prgchText: *mut ::std::os::raw::c_void,
        cchTextMax: ::std::os::raw::c_int,
        peChatEntryType: *mut EChatEntryType,
        psteamidChatter: *mut CSteamID,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_IsClanChatAdmin(
        self_: *mut ISteamFriends,
        steamIDClanChat: uint64_steamid,
        steamIDUser: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_IsClanChatWindowOpenInSteam(
        self_: *mut ISteamFriends,
        steamIDClanChat: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_OpenClanChatWindowInSteam(
        self_: *mut ISteamFriends,
        steamIDClanChat: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_CloseClanChatWindowInSteam(
        self_: *mut ISteamFriends,
        steamIDClanChat: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_SetListenForFriendsMessages(
        self_: *mut ISteamFriends,
        bInterceptEnabled: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_ReplyToFriendMessage(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
        pchMsgToSend: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendMessage(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
        iMessageID: ::std::os::raw::c_int,
        pvData: *mut ::std::os::raw::c_void,
        cubData: ::std::os::raw::c_int,
        peChatEntryType: *mut EChatEntryType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFollowerCount(
        self_: *mut ISteamFriends,
        steamID: uint64_steamid,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_IsFollowing(
        self_: *mut ISteamFriends,
        steamID: uint64_steamid,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_EnumerateFollowingList(
        self_: *mut ISteamFriends,
        unStartIndex: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_IsClanPublic(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_IsClanOfficialGameGroup(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetNumChatsWithUnreadPriorityMessages(
        self_: *mut ISteamFriends,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_ActivateGameOverlayRemotePlayTogetherInviteDialog(
        self_: *mut ISteamFriends,
        steamIDLobby: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_RegisterProtocolInOverlayBrowser(
        self_: *mut ISteamFriends,
        pchProtocol: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_ActivateGameOverlayInviteDialogConnectString(
        self_: *mut ISteamFriends,
        pchConnectString: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_RequestEquippedProfileItems(
        self_: *mut ISteamFriends,
        steamID: uint64_steamid,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_BHasEquippedProfileItem(
        self_: *mut ISteamFriends,
        steamID: uint64_steamid,
        itemType: ECommunityProfileItemType,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetProfileItemPropertyString(
        self_: *mut ISteamFriends,
        steamID: uint64_steamid,
        itemType: ECommunityProfileItemType,
        prop: ECommunityProfileItemProperty,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetProfileItemPropertyUint(
        self_: *mut ISteamFriends,
        steamID: uint64_steamid,
        itemType: ECommunityProfileItemType,
        prop: ECommunityProfileItemProperty,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_SteamUtils_v010() -> *mut ISteamUtils;
}
extern "C" {
    pub fn SteamAPI_SteamGameServerUtils_v010() -> *mut ISteamUtils;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetSecondsSinceAppActive(self_: *mut ISteamUtils) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetSecondsSinceComputerActive(self_: *mut ISteamUtils) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetConnectedUniverse(self_: *mut ISteamUtils) -> EUniverse;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetServerRealTime(self_: *mut ISteamUtils) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetIPCountry(
        self_: *mut ISteamUtils,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetImageSize(
        self_: *mut ISteamUtils,
        iImage: ::std::os::raw::c_int,
        pnWidth: *mut uint32,
        pnHeight: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetImageRGBA(
        self_: *mut ISteamUtils,
        iImage: ::std::os::raw::c_int,
        pubDest: *mut uint8,
        nDestBufferSize: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetCurrentBatteryPower(self_: *mut ISteamUtils) -> uint8;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetAppID(self_: *mut ISteamUtils) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_SetOverlayNotificationPosition(
        self_: *mut ISteamUtils,
        eNotificationPosition: ENotificationPosition,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_IsAPICallCompleted(
        self_: *mut ISteamUtils,
        hSteamAPICall: SteamAPICall_t,
        pbFailed: *mut bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetAPICallFailureReason(
        self_: *mut ISteamUtils,
        hSteamAPICall: SteamAPICall_t,
    ) -> ESteamAPICallFailure;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetAPICallResult(
        self_: *mut ISteamUtils,
        hSteamAPICall: SteamAPICall_t,
        pCallback: *mut ::std::os::raw::c_void,
        cubCallback: ::std::os::raw::c_int,
        iCallbackExpected: ::std::os::raw::c_int,
        pbFailed: *mut bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetIPCCallCount(self_: *mut ISteamUtils) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_SetWarningMessageHook(
        self_: *mut ISteamUtils,
        pFunction: SteamAPIWarningMessageHook_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_IsOverlayEnabled(self_: *mut ISteamUtils) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_BOverlayNeedsPresent(self_: *mut ISteamUtils) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_CheckFileSignature(
        self_: *mut ISteamUtils,
        szFileName: *const ::std::os::raw::c_char,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_ShowGamepadTextInput(
        self_: *mut ISteamUtils,
        eInputMode: EGamepadTextInputMode,
        eLineInputMode: EGamepadTextInputLineMode,
        pchDescription: *const ::std::os::raw::c_char,
        unCharMax: uint32,
        pchExistingText: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetEnteredGamepadTextLength(self_: *mut ISteamUtils) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetEnteredGamepadTextInput(
        self_: *mut ISteamUtils,
        pchText: *mut ::std::os::raw::c_char,
        cchText: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetSteamUILanguage(
        self_: *mut ISteamUtils,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_IsSteamRunningInVR(self_: *mut ISteamUtils) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_SetOverlayNotificationInset(
        self_: *mut ISteamUtils,
        nHorizontalInset: ::std::os::raw::c_int,
        nVerticalInset: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_IsSteamInBigPictureMode(self_: *mut ISteamUtils) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_StartVRDashboard(self_: *mut ISteamUtils);
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_IsVRHeadsetStreamingEnabled(self_: *mut ISteamUtils) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_SetVRHeadsetStreamingEnabled(
        self_: *mut ISteamUtils,
        bEnabled: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_IsSteamChinaLauncher(self_: *mut ISteamUtils) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_InitFilterText(
        self_: *mut ISteamUtils,
        unFilterOptions: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_FilterText(
        self_: *mut ISteamUtils,
        eContext: ETextFilteringContext,
        sourceSteamID: uint64_steamid,
        pchInputMessage: *const ::std::os::raw::c_char,
        pchOutFilteredText: *mut ::std::os::raw::c_char,
        nByteSizeOutFilteredText: uint32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetIPv6ConnectivityState(
        self_: *mut ISteamUtils,
        eProtocol: ESteamIPv6ConnectivityProtocol,
    ) -> ESteamIPv6ConnectivityState;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_IsSteamRunningOnSteamDeck(self_: *mut ISteamUtils) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_ShowFloatingGamepadTextInput(
        self_: *mut ISteamUtils,
        eKeyboardMode: EFloatingGamepadTextInputMode,
        nTextFieldXPosition: ::std::os::raw::c_int,
        nTextFieldYPosition: ::std::os::raw::c_int,
        nTextFieldWidth: ::std::os::raw::c_int,
        nTextFieldHeight: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_SetGameLauncherMode(self_: *mut ISteamUtils, bLauncherMode: bool);
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_DismissFloatingGamepadTextInput(self_: *mut ISteamUtils) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_DismissGamepadTextInput(self_: *mut ISteamUtils) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamMatchmaking_v009() -> *mut ISteamMatchmaking;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetFavoriteGameCount(
        self_: *mut ISteamMatchmaking,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetFavoriteGame(
        self_: *mut ISteamMatchmaking,
        iGame: ::std::os::raw::c_int,
        pnAppID: *mut AppId_t,
        pnIP: *mut uint32,
        pnConnPort: *mut uint16,
        pnQueryPort: *mut uint16,
        punFlags: *mut uint32,
        pRTime32LastPlayedOnServer: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_AddFavoriteGame(
        self_: *mut ISteamMatchmaking,
        nAppID: AppId_t,
        nIP: uint32,
        nConnPort: uint16,
        nQueryPort: uint16,
        unFlags: uint32,
        rTime32LastPlayedOnServer: uint32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_RemoveFavoriteGame(
        self_: *mut ISteamMatchmaking,
        nAppID: AppId_t,
        nIP: uint32,
        nConnPort: uint16,
        nQueryPort: uint16,
        unFlags: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_RequestLobbyList(
        self_: *mut ISteamMatchmaking,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_AddRequestLobbyListStringFilter(
        self_: *mut ISteamMatchmaking,
        pchKeyToMatch: *const ::std::os::raw::c_char,
        pchValueToMatch: *const ::std::os::raw::c_char,
        eComparisonType: ELobbyComparison,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_AddRequestLobbyListNumericalFilter(
        self_: *mut ISteamMatchmaking,
        pchKeyToMatch: *const ::std::os::raw::c_char,
        nValueToMatch: ::std::os::raw::c_int,
        eComparisonType: ELobbyComparison,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_AddRequestLobbyListNearValueFilter(
        self_: *mut ISteamMatchmaking,
        pchKeyToMatch: *const ::std::os::raw::c_char,
        nValueToBeCloseTo: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_AddRequestLobbyListFilterSlotsAvailable(
        self_: *mut ISteamMatchmaking,
        nSlotsAvailable: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_AddRequestLobbyListDistanceFilter(
        self_: *mut ISteamMatchmaking,
        eLobbyDistanceFilter: ELobbyDistanceFilter,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_AddRequestLobbyListResultCountFilter(
        self_: *mut ISteamMatchmaking,
        cMaxResults: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_AddRequestLobbyListCompatibleMembersFilter(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetLobbyByIndex(
        self_: *mut ISteamMatchmaking,
        iLobby: ::std::os::raw::c_int,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_CreateLobby(
        self_: *mut ISteamMatchmaking,
        eLobbyType: ELobbyType,
        cMaxMembers: ::std::os::raw::c_int,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_JoinLobby(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_LeaveLobby(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_InviteUserToLobby(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        steamIDInvitee: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetNumLobbyMembers(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetLobbyMemberByIndex(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        iMember: ::std::os::raw::c_int,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetLobbyData(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        pchKey: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_SetLobbyData(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        pchKey: *const ::std::os::raw::c_char,
        pchValue: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetLobbyDataCount(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetLobbyDataByIndex(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        iLobbyData: ::std::os::raw::c_int,
        pchKey: *mut ::std::os::raw::c_char,
        cchKeyBufferSize: ::std::os::raw::c_int,
        pchValue: *mut ::std::os::raw::c_char,
        cchValueBufferSize: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_DeleteLobbyData(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        pchKey: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetLobbyMemberData(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        steamIDUser: uint64_steamid,
        pchKey: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_SetLobbyMemberData(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        pchKey: *const ::std::os::raw::c_char,
        pchValue: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_SendLobbyChatMsg(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        pvMsgBody: *const ::std::os::raw::c_void,
        cubMsgBody: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetLobbyChatEntry(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        iChatID: ::std::os::raw::c_int,
        pSteamIDUser: *mut CSteamID,
        pvData: *mut ::std::os::raw::c_void,
        cubData: ::std::os::raw::c_int,
        peChatEntryType: *mut EChatEntryType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_RequestLobbyData(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_SetLobbyGameServer(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        unGameServerIP: uint32,
        unGameServerPort: uint16,
        steamIDGameServer: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetLobbyGameServer(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        punGameServerIP: *mut uint32,
        punGameServerPort: *mut uint16,
        psteamIDGameServer: *mut CSteamID,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_SetLobbyMemberLimit(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        cMaxMembers: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetLobbyMemberLimit(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_SetLobbyType(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        eLobbyType: ELobbyType,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_SetLobbyJoinable(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        bLobbyJoinable: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetLobbyOwner(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_SetLobbyOwner(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        steamIDNewOwner: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_SetLinkedLobby(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        steamIDLobbyDependent: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServerListResponse_ServerResponded(
        self_: *mut ISteamMatchmakingServerListResponse,
        hRequest: HServerListRequest,
        iServer: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServerListResponse_ServerFailedToRespond(
        self_: *mut ISteamMatchmakingServerListResponse,
        hRequest: HServerListRequest,
        iServer: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServerListResponse_RefreshComplete(
        self_: *mut ISteamMatchmakingServerListResponse,
        hRequest: HServerListRequest,
        response: EMatchMakingServerResponse,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingPingResponse_ServerResponded(
        self_: *mut ISteamMatchmakingPingResponse,
        server: *mut gameserveritem_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingPingResponse_ServerFailedToRespond(
        self_: *mut ISteamMatchmakingPingResponse,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingPlayersResponse_AddPlayerToList(
        self_: *mut ISteamMatchmakingPlayersResponse,
        pchName: *const ::std::os::raw::c_char,
        nScore: ::std::os::raw::c_int,
        flTimePlayed: f32,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingPlayersResponse_PlayersFailedToRespond(
        self_: *mut ISteamMatchmakingPlayersResponse,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingPlayersResponse_PlayersRefreshComplete(
        self_: *mut ISteamMatchmakingPlayersResponse,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingRulesResponse_RulesResponded(
        self_: *mut ISteamMatchmakingRulesResponse,
        pchRule: *const ::std::os::raw::c_char,
        pchValue: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingRulesResponse_RulesFailedToRespond(
        self_: *mut ISteamMatchmakingRulesResponse,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingRulesResponse_RulesRefreshComplete(
        self_: *mut ISteamMatchmakingRulesResponse,
    );
}
extern "C" {
    pub fn SteamAPI_SteamMatchmakingServers_v002() -> *mut ISteamMatchmakingServers;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_RequestInternetServerList(
        self_: *mut ISteamMatchmakingServers,
        iApp: AppId_t,
        ppchFilters: *mut *mut MatchMakingKeyValuePair_t,
        nFilters: uint32,
        pRequestServersResponse: *mut ISteamMatchmakingServerListResponse,
    ) -> HServerListRequest;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_RequestLANServerList(
        self_: *mut ISteamMatchmakingServers,
        iApp: AppId_t,
        pRequestServersResponse: *mut ISteamMatchmakingServerListResponse,
    ) -> HServerListRequest;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_RequestFriendsServerList(
        self_: *mut ISteamMatchmakingServers,
        iApp: AppId_t,
        ppchFilters: *mut *mut MatchMakingKeyValuePair_t,
        nFilters: uint32,
        pRequestServersResponse: *mut ISteamMatchmakingServerListResponse,
    ) -> HServerListRequest;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_RequestFavoritesServerList(
        self_: *mut ISteamMatchmakingServers,
        iApp: AppId_t,
        ppchFilters: *mut *mut MatchMakingKeyValuePair_t,
        nFilters: uint32,
        pRequestServersResponse: *mut ISteamMatchmakingServerListResponse,
    ) -> HServerListRequest;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_RequestHistoryServerList(
        self_: *mut ISteamMatchmakingServers,
        iApp: AppId_t,
        ppchFilters: *mut *mut MatchMakingKeyValuePair_t,
        nFilters: uint32,
        pRequestServersResponse: *mut ISteamMatchmakingServerListResponse,
    ) -> HServerListRequest;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_RequestSpectatorServerList(
        self_: *mut ISteamMatchmakingServers,
        iApp: AppId_t,
        ppchFilters: *mut *mut MatchMakingKeyValuePair_t,
        nFilters: uint32,
        pRequestServersResponse: *mut ISteamMatchmakingServerListResponse,
    ) -> HServerListRequest;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_ReleaseRequest(
        self_: *mut ISteamMatchmakingServers,
        hServerListRequest: HServerListRequest,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_GetServerDetails(
        self_: *mut ISteamMatchmakingServers,
        hRequest: HServerListRequest,
        iServer: ::std::os::raw::c_int,
    ) -> *mut gameserveritem_t;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_CancelQuery(
        self_: *mut ISteamMatchmakingServers,
        hRequest: HServerListRequest,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_RefreshQuery(
        self_: *mut ISteamMatchmakingServers,
        hRequest: HServerListRequest,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_IsRefreshing(
        self_: *mut ISteamMatchmakingServers,
        hRequest: HServerListRequest,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_GetServerCount(
        self_: *mut ISteamMatchmakingServers,
        hRequest: HServerListRequest,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_RefreshServer(
        self_: *mut ISteamMatchmakingServers,
        hRequest: HServerListRequest,
        iServer: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_PingServer(
        self_: *mut ISteamMatchmakingServers,
        unIP: uint32,
        usPort: uint16,
        pRequestServersResponse: *mut ISteamMatchmakingPingResponse,
    ) -> HServerQuery;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_PlayerDetails(
        self_: *mut ISteamMatchmakingServers,
        unIP: uint32,
        usPort: uint16,
        pRequestServersResponse: *mut ISteamMatchmakingPlayersResponse,
    ) -> HServerQuery;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_ServerRules(
        self_: *mut ISteamMatchmakingServers,
        unIP: uint32,
        usPort: uint16,
        pRequestServersResponse: *mut ISteamMatchmakingRulesResponse,
    ) -> HServerQuery;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_CancelServerQuery(
        self_: *mut ISteamMatchmakingServers,
        hServerQuery: HServerQuery,
    );
}
extern "C" {
    pub fn SteamAPI_SteamGameSearch_v001() -> *mut ISteamGameSearch;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_AddGameSearchParams(
        self_: *mut ISteamGameSearch,
        pchKeyToFind: *const ::std::os::raw::c_char,
        pchValuesToFind: *const ::std::os::raw::c_char,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_SearchForGameWithLobby(
        self_: *mut ISteamGameSearch,
        steamIDLobby: uint64_steamid,
        nPlayerMin: ::std::os::raw::c_int,
        nPlayerMax: ::std::os::raw::c_int,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_SearchForGameSolo(
        self_: *mut ISteamGameSearch,
        nPlayerMin: ::std::os::raw::c_int,
        nPlayerMax: ::std::os::raw::c_int,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_AcceptGame(
        self_: *mut ISteamGameSearch,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_DeclineGame(
        self_: *mut ISteamGameSearch,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_RetrieveConnectionDetails(
        self_: *mut ISteamGameSearch,
        steamIDHost: uint64_steamid,
        pchConnectionDetails: *mut ::std::os::raw::c_char,
        cubConnectionDetails: ::std::os::raw::c_int,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_EndGameSearch(
        self_: *mut ISteamGameSearch,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_SetGameHostParams(
        self_: *mut ISteamGameSearch,
        pchKey: *const ::std::os::raw::c_char,
        pchValue: *const ::std::os::raw::c_char,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_SetConnectionDetails(
        self_: *mut ISteamGameSearch,
        pchConnectionDetails: *const ::std::os::raw::c_char,
        cubConnectionDetails: ::std::os::raw::c_int,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_RequestPlayersForGame(
        self_: *mut ISteamGameSearch,
        nPlayerMin: ::std::os::raw::c_int,
        nPlayerMax: ::std::os::raw::c_int,
        nMaxTeamSize: ::std::os::raw::c_int,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_HostConfirmGameStart(
        self_: *mut ISteamGameSearch,
        ullUniqueGameID: uint64,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_CancelRequestPlayersForGame(
        self_: *mut ISteamGameSearch,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_SubmitPlayerResult(
        self_: *mut ISteamGameSearch,
        ullUniqueGameID: uint64,
        steamIDPlayer: uint64_steamid,
        EPlayerResult: EPlayerResult_t,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_EndGame(
        self_: *mut ISteamGameSearch,
        ullUniqueGameID: uint64,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_SteamParties_v002() -> *mut ISteamParties;
}
extern "C" {
    pub fn SteamAPI_ISteamParties_GetNumActiveBeacons(self_: *mut ISteamParties) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamParties_GetBeaconByIndex(
        self_: *mut ISteamParties,
        unIndex: uint32,
    ) -> PartyBeaconID_t;
}
extern "C" {
    pub fn SteamAPI_ISteamParties_GetBeaconDetails(
        self_: *mut ISteamParties,
        ulBeaconID: PartyBeaconID_t,
        pSteamIDBeaconOwner: *mut CSteamID,
        pLocation: *mut SteamPartyBeaconLocation_t,
        pchMetadata: *mut ::std::os::raw::c_char,
        cchMetadata: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamParties_JoinParty(
        self_: *mut ISteamParties,
        ulBeaconID: PartyBeaconID_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamParties_GetNumAvailableBeaconLocations(
        self_: *mut ISteamParties,
        puNumLocations: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamParties_GetAvailableBeaconLocations(
        self_: *mut ISteamParties,
        pLocationList: *mut SteamPartyBeaconLocation_t,
        uMaxNumLocations: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamParties_CreateBeacon(
        self_: *mut ISteamParties,
        unOpenSlots: uint32,
        pBeaconLocation: *mut SteamPartyBeaconLocation_t,
        pchConnectString: *const ::std::os::raw::c_char,
        pchMetadata: *const ::std::os::raw::c_char,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamParties_OnReservationCompleted(
        self_: *mut ISteamParties,
        ulBeacon: PartyBeaconID_t,
        steamIDUser: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamParties_CancelReservation(
        self_: *mut ISteamParties,
        ulBeacon: PartyBeaconID_t,
        steamIDUser: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamParties_ChangeNumOpenSlots(
        self_: *mut ISteamParties,
        ulBeacon: PartyBeaconID_t,
        unOpenSlots: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamParties_DestroyBeacon(
        self_: *mut ISteamParties,
        ulBeacon: PartyBeaconID_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamParties_GetBeaconLocationData(
        self_: *mut ISteamParties,
        BeaconLocation: SteamPartyBeaconLocation_t,
        eData: ESteamPartyBeaconLocationData,
        pchDataStringOut: *mut ::std::os::raw::c_char,
        cchDataStringOut: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamRemoteStorage_v016() -> *mut ISteamRemoteStorage;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileWrite(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
        pvData: *const ::std::os::raw::c_void,
        cubData: int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileRead(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
        pvData: *mut ::std::os::raw::c_void,
        cubDataToRead: int32,
    ) -> int32;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileWriteAsync(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
        pvData: *const ::std::os::raw::c_void,
        cubData: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileReadAsync(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
        nOffset: uint32,
        cubToRead: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileReadAsyncComplete(
        self_: *mut ISteamRemoteStorage,
        hReadCall: SteamAPICall_t,
        pvBuffer: *mut ::std::os::raw::c_void,
        cubToRead: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileForget(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileDelete(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileShare(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_SetSyncPlatforms(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
        eRemoteStoragePlatform: ERemoteStoragePlatform,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileWriteStreamOpen(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
    ) -> UGCFileWriteStreamHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileWriteStreamWriteChunk(
        self_: *mut ISteamRemoteStorage,
        writeHandle: UGCFileWriteStreamHandle_t,
        pvData: *const ::std::os::raw::c_void,
        cubData: int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileWriteStreamClose(
        self_: *mut ISteamRemoteStorage,
        writeHandle: UGCFileWriteStreamHandle_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileWriteStreamCancel(
        self_: *mut ISteamRemoteStorage,
        writeHandle: UGCFileWriteStreamHandle_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileExists(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FilePersisted(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetFileSize(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
    ) -> int32;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetFileTimestamp(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
    ) -> int64;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetSyncPlatforms(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
    ) -> ERemoteStoragePlatform;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetFileCount(self_: *mut ISteamRemoteStorage) -> int32;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetFileNameAndSize(
        self_: *mut ISteamRemoteStorage,
        iFile: ::std::os::raw::c_int,
        pnFileSizeInBytes: *mut int32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetQuota(
        self_: *mut ISteamRemoteStorage,
        pnTotalBytes: *mut uint64,
        puAvailableBytes: *mut uint64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_IsCloudEnabledForAccount(
        self_: *mut ISteamRemoteStorage,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_IsCloudEnabledForApp(
        self_: *mut ISteamRemoteStorage,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_SetCloudEnabledForApp(
        self_: *mut ISteamRemoteStorage,
        bEnabled: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_UGCDownload(
        self_: *mut ISteamRemoteStorage,
        hContent: UGCHandle_t,
        unPriority: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetUGCDownloadProgress(
        self_: *mut ISteamRemoteStorage,
        hContent: UGCHandle_t,
        pnBytesDownloaded: *mut int32,
        pnBytesExpected: *mut int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetUGCDetails(
        self_: *mut ISteamRemoteStorage,
        hContent: UGCHandle_t,
        pnAppID: *mut AppId_t,
        ppchName: *mut *mut ::std::os::raw::c_char,
        pnFileSizeInBytes: *mut int32,
        pSteamIDOwner: *mut CSteamID,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_UGCRead(
        self_: *mut ISteamRemoteStorage,
        hContent: UGCHandle_t,
        pvData: *mut ::std::os::raw::c_void,
        cubDataToRead: int32,
        cOffset: uint32,
        eAction: EUGCReadAction,
    ) -> int32;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetCachedUGCCount(self_: *mut ISteamRemoteStorage)
        -> int32;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetCachedUGCHandle(
        self_: *mut ISteamRemoteStorage,
        iCachedContent: int32,
    ) -> UGCHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_PublishWorkshopFile(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
        pchPreviewFile: *const ::std::os::raw::c_char,
        nConsumerAppId: AppId_t,
        pchTitle: *const ::std::os::raw::c_char,
        pchDescription: *const ::std::os::raw::c_char,
        eVisibility: ERemoteStoragePublishedFileVisibility,
        pTags: *mut SteamParamStringArray_t,
        eWorkshopFileType: EWorkshopFileType,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_CreatePublishedFileUpdateRequest(
        self_: *mut ISteamRemoteStorage,
        unPublishedFileId: PublishedFileId_t,
    ) -> PublishedFileUpdateHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_UpdatePublishedFileFile(
        self_: *mut ISteamRemoteStorage,
        updateHandle: PublishedFileUpdateHandle_t,
        pchFile: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_UpdatePublishedFilePreviewFile(
        self_: *mut ISteamRemoteStorage,
        updateHandle: PublishedFileUpdateHandle_t,
        pchPreviewFile: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_UpdatePublishedFileTitle(
        self_: *mut ISteamRemoteStorage,
        updateHandle: PublishedFileUpdateHandle_t,
        pchTitle: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_UpdatePublishedFileDescription(
        self_: *mut ISteamRemoteStorage,
        updateHandle: PublishedFileUpdateHandle_t,
        pchDescription: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_UpdatePublishedFileVisibility(
        self_: *mut ISteamRemoteStorage,
        updateHandle: PublishedFileUpdateHandle_t,
        eVisibility: ERemoteStoragePublishedFileVisibility,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_UpdatePublishedFileTags(
        self_: *mut ISteamRemoteStorage,
        updateHandle: PublishedFileUpdateHandle_t,
        pTags: *mut SteamParamStringArray_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_CommitPublishedFileUpdate(
        self_: *mut ISteamRemoteStorage,
        updateHandle: PublishedFileUpdateHandle_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetPublishedFileDetails(
        self_: *mut ISteamRemoteStorage,
        unPublishedFileId: PublishedFileId_t,
        unMaxSecondsOld: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_DeletePublishedFile(
        self_: *mut ISteamRemoteStorage,
        unPublishedFileId: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_EnumerateUserPublishedFiles(
        self_: *mut ISteamRemoteStorage,
        unStartIndex: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_SubscribePublishedFile(
        self_: *mut ISteamRemoteStorage,
        unPublishedFileId: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_EnumerateUserSubscribedFiles(
        self_: *mut ISteamRemoteStorage,
        unStartIndex: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_UnsubscribePublishedFile(
        self_: *mut ISteamRemoteStorage,
        unPublishedFileId: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_UpdatePublishedFileSetChangeDescription(
        self_: *mut ISteamRemoteStorage,
        updateHandle: PublishedFileUpdateHandle_t,
        pchChangeDescription: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetPublishedItemVoteDetails(
        self_: *mut ISteamRemoteStorage,
        unPublishedFileId: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_UpdateUserPublishedItemVote(
        self_: *mut ISteamRemoteStorage,
        unPublishedFileId: PublishedFileId_t,
        bVoteUp: bool,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetUserPublishedItemVoteDetails(
        self_: *mut ISteamRemoteStorage,
        unPublishedFileId: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_EnumerateUserSharedWorkshopFiles(
        self_: *mut ISteamRemoteStorage,
        steamId: uint64_steamid,
        unStartIndex: uint32,
        pRequiredTags: *mut SteamParamStringArray_t,
        pExcludedTags: *mut SteamParamStringArray_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_PublishVideo(
        self_: *mut ISteamRemoteStorage,
        eVideoProvider: EWorkshopVideoProvider,
        pchVideoAccount: *const ::std::os::raw::c_char,
        pchVideoIdentifier: *const ::std::os::raw::c_char,
        pchPreviewFile: *const ::std::os::raw::c_char,
        nConsumerAppId: AppId_t,
        pchTitle: *const ::std::os::raw::c_char,
        pchDescription: *const ::std::os::raw::c_char,
        eVisibility: ERemoteStoragePublishedFileVisibility,
        pTags: *mut SteamParamStringArray_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_SetUserPublishedFileAction(
        self_: *mut ISteamRemoteStorage,
        unPublishedFileId: PublishedFileId_t,
        eAction: EWorkshopFileAction,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_EnumeratePublishedFilesByUserAction(
        self_: *mut ISteamRemoteStorage,
        eAction: EWorkshopFileAction,
        unStartIndex: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_EnumeratePublishedWorkshopFiles(
        self_: *mut ISteamRemoteStorage,
        eEnumerationType: EWorkshopEnumerationType,
        unStartIndex: uint32,
        unCount: uint32,
        unDays: uint32,
        pTags: *mut SteamParamStringArray_t,
        pUserTags: *mut SteamParamStringArray_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_UGCDownloadToLocation(
        self_: *mut ISteamRemoteStorage,
        hContent: UGCHandle_t,
        pchLocation: *const ::std::os::raw::c_char,
        unPriority: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetLocalFileChangeCount(
        self_: *mut ISteamRemoteStorage,
    ) -> int32;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetLocalFileChange(
        self_: *mut ISteamRemoteStorage,
        iFile: ::std::os::raw::c_int,
        pEChangeType: *mut ERemoteStorageLocalFileChange,
        pEFilePathType: *mut ERemoteStorageFilePathType,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_BeginFileWriteBatch(
        self_: *mut ISteamRemoteStorage,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_EndFileWriteBatch(self_: *mut ISteamRemoteStorage) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamUserStats_v013() -> *mut ISteamUserStats;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetStatInt32(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
        pData: *mut int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetStatFloat(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
        pData: *mut f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_SetStatInt32(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
        nData: int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_SetStatFloat(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
        fData: f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_UpdateAvgRateStat(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
        flCountThisSession: f32,
        dSessionLength: f64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetAchievement(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
        pbAchieved: *mut bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_SetAchievement(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_ClearAchievement(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetAchievementAndUnlockTime(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
        pbAchieved: *mut bool,
        punUnlockTime: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_StoreStats(self_: *mut ISteamUserStats) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetAchievementIcon(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetAchievementDisplayAttribute(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
        pchKey: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_IndicateAchievementProgress(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
        nCurProgress: uint32,
        nMaxProgress: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetNumAchievements(self_: *mut ISteamUserStats) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetAchievementName(
        self_: *mut ISteamUserStats,
        iAchievement: uint32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_RequestUserStats(
        self_: *mut ISteamUserStats,
        steamIDUser: uint64_steamid,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetUserStatInt32(
        self_: *mut ISteamUserStats,
        steamIDUser: uint64_steamid,
        pchName: *const ::std::os::raw::c_char,
        pData: *mut int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetUserStatFloat(
        self_: *mut ISteamUserStats,
        steamIDUser: uint64_steamid,
        pchName: *const ::std::os::raw::c_char,
        pData: *mut f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetUserAchievement(
        self_: *mut ISteamUserStats,
        steamIDUser: uint64_steamid,
        pchName: *const ::std::os::raw::c_char,
        pbAchieved: *mut bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetUserAchievementAndUnlockTime(
        self_: *mut ISteamUserStats,
        steamIDUser: uint64_steamid,
        pchName: *const ::std::os::raw::c_char,
        pbAchieved: *mut bool,
        punUnlockTime: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_ResetAllStats(
        self_: *mut ISteamUserStats,
        bAchievementsToo: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_FindOrCreateLeaderboard(
        self_: *mut ISteamUserStats,
        pchLeaderboardName: *const ::std::os::raw::c_char,
        eLeaderboardSortMethod: ELeaderboardSortMethod,
        eLeaderboardDisplayType: ELeaderboardDisplayType,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_FindLeaderboard(
        self_: *mut ISteamUserStats,
        pchLeaderboardName: *const ::std::os::raw::c_char,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetLeaderboardName(
        self_: *mut ISteamUserStats,
        hSteamLeaderboard: SteamLeaderboard_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetLeaderboardEntryCount(
        self_: *mut ISteamUserStats,
        hSteamLeaderboard: SteamLeaderboard_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetLeaderboardSortMethod(
        self_: *mut ISteamUserStats,
        hSteamLeaderboard: SteamLeaderboard_t,
    ) -> ELeaderboardSortMethod;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetLeaderboardDisplayType(
        self_: *mut ISteamUserStats,
        hSteamLeaderboard: SteamLeaderboard_t,
    ) -> ELeaderboardDisplayType;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_DownloadLeaderboardEntries(
        self_: *mut ISteamUserStats,
        hSteamLeaderboard: SteamLeaderboard_t,
        eLeaderboardDataRequest: ELeaderboardDataRequest,
        nRangeStart: ::std::os::raw::c_int,
        nRangeEnd: ::std::os::raw::c_int,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_DownloadLeaderboardEntriesForUsers(
        self_: *mut ISteamUserStats,
        hSteamLeaderboard: SteamLeaderboard_t,
        prgUsers: *mut CSteamID,
        cUsers: ::std::os::raw::c_int,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetDownloadedLeaderboardEntry(
        self_: *mut ISteamUserStats,
        hSteamLeaderboardEntries: SteamLeaderboardEntries_t,
        index: ::std::os::raw::c_int,
        pLeaderboardEntry: *mut LeaderboardEntry_t,
        pDetails: *mut int32,
        cDetailsMax: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_UploadLeaderboardScore(
        self_: *mut ISteamUserStats,
        hSteamLeaderboard: SteamLeaderboard_t,
        eLeaderboardUploadScoreMethod: ELeaderboardUploadScoreMethod,
        nScore: int32,
        pScoreDetails: *const int32,
        cScoreDetailsCount: ::std::os::raw::c_int,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_AttachLeaderboardUGC(
        self_: *mut ISteamUserStats,
        hSteamLeaderboard: SteamLeaderboard_t,
        hUGC: UGCHandle_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetNumberOfCurrentPlayers(
        self_: *mut ISteamUserStats,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_RequestGlobalAchievementPercentages(
        self_: *mut ISteamUserStats,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetMostAchievedAchievementInfo(
        self_: *mut ISteamUserStats,
        pchName: *mut ::std::os::raw::c_char,
        unNameBufLen: uint32,
        pflPercent: *mut f32,
        pbAchieved: *mut bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetNextMostAchievedAchievementInfo(
        self_: *mut ISteamUserStats,
        iIteratorPrevious: ::std::os::raw::c_int,
        pchName: *mut ::std::os::raw::c_char,
        unNameBufLen: uint32,
        pflPercent: *mut f32,
        pbAchieved: *mut bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetAchievementAchievedPercent(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
        pflPercent: *mut f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_RequestGlobalStats(
        self_: *mut ISteamUserStats,
        nHistoryDays: ::std::os::raw::c_int,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetGlobalStatInt64(
        self_: *mut ISteamUserStats,
        pchStatName: *const ::std::os::raw::c_char,
        pData: *mut int64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetGlobalStatDouble(
        self_: *mut ISteamUserStats,
        pchStatName: *const ::std::os::raw::c_char,
        pData: *mut f64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetGlobalStatHistoryInt64(
        self_: *mut ISteamUserStats,
        pchStatName: *const ::std::os::raw::c_char,
        pData: *mut int64,
        cubData: uint32,
    ) -> int32;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetGlobalStatHistoryDouble(
        self_: *mut ISteamUserStats,
        pchStatName: *const ::std::os::raw::c_char,
        pData: *mut f64,
        cubData: uint32,
    ) -> int32;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetAchievementProgressLimitsInt32(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
        pnMinProgress: *mut int32,
        pnMaxProgress: *mut int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetAchievementProgressLimitsFloat(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
        pfMinProgress: *mut f32,
        pfMaxProgress: *mut f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamApps_v008() -> *mut ISteamApps;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_BIsSubscribed(self_: *mut ISteamApps) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_BIsLowViolence(self_: *mut ISteamApps) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_BIsCybercafe(self_: *mut ISteamApps) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_BIsVACBanned(self_: *mut ISteamApps) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetCurrentGameLanguage(
        self_: *mut ISteamApps,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetAvailableGameLanguages(
        self_: *mut ISteamApps,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_BIsSubscribedApp(self_: *mut ISteamApps, appID: AppId_t) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_BIsDlcInstalled(self_: *mut ISteamApps, appID: AppId_t) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetEarliestPurchaseUnixTime(
        self_: *mut ISteamApps,
        nAppID: AppId_t,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_BIsSubscribedFromFreeWeekend(self_: *mut ISteamApps) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetDLCCount(self_: *mut ISteamApps) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_BGetDLCDataByIndex(
        self_: *mut ISteamApps,
        iDLC: ::std::os::raw::c_int,
        pAppID: *mut AppId_t,
        pbAvailable: *mut bool,
        pchName: *mut ::std::os::raw::c_char,
        cchNameBufferSize: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_InstallDLC(self_: *mut ISteamApps, nAppID: AppId_t);
}
extern "C" {
    pub fn SteamAPI_ISteamApps_UninstallDLC(self_: *mut ISteamApps, nAppID: AppId_t);
}
extern "C" {
    pub fn SteamAPI_ISteamApps_RequestAppProofOfPurchaseKey(
        self_: *mut ISteamApps,
        nAppID: AppId_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetCurrentBetaName(
        self_: *mut ISteamApps,
        pchName: *mut ::std::os::raw::c_char,
        cchNameBufferSize: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_MarkContentCorrupt(
        self_: *mut ISteamApps,
        bMissingFilesOnly: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetInstalledDepots(
        self_: *mut ISteamApps,
        appID: AppId_t,
        pvecDepots: *mut DepotId_t,
        cMaxDepots: uint32,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetAppInstallDir(
        self_: *mut ISteamApps,
        appID: AppId_t,
        pchFolder: *mut ::std::os::raw::c_char,
        cchFolderBufferSize: uint32,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_BIsAppInstalled(self_: *mut ISteamApps, appID: AppId_t) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetAppOwner(self_: *mut ISteamApps) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetLaunchQueryParam(
        self_: *mut ISteamApps,
        pchKey: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetDlcDownloadProgress(
        self_: *mut ISteamApps,
        nAppID: AppId_t,
        punBytesDownloaded: *mut uint64,
        punBytesTotal: *mut uint64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetAppBuildId(self_: *mut ISteamApps) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_RequestAllProofOfPurchaseKeys(self_: *mut ISteamApps);
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetFileDetails(
        self_: *mut ISteamApps,
        pszFileName: *const ::std::os::raw::c_char,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetLaunchCommandLine(
        self_: *mut ISteamApps,
        pszCommandLine: *mut ::std::os::raw::c_char,
        cubCommandLine: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_BIsSubscribedFromFamilySharing(self_: *mut ISteamApps) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_BIsTimedTrial(
        self_: *mut ISteamApps,
        punSecondsAllowed: *mut uint32,
        punSecondsPlayed: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_SetDlcContext(self_: *mut ISteamApps, nAppID: AppId_t) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetNumBetas(
        self_: *mut ISteamApps,
        pnAvailable: *mut ::std::os::raw::c_int,
        pnPrivate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetBetaInfo(
        self_: *mut ISteamApps,
        iBetaIndex: ::std::os::raw::c_int,
        punFlags: *mut uint32,
        punBuildID: *mut uint32,
        pchBetaName: *mut ::std::os::raw::c_char,
        cchBetaName: ::std::os::raw::c_int,
        pchDescription: *mut ::std::os::raw::c_char,
        cchDescription: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_SetActiveBeta(
        self_: *mut ISteamApps,
        pchBetaName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworking_v006() -> *mut ISteamNetworking;
}
extern "C" {
    pub fn SteamAPI_SteamGameServerNetworking_v006() -> *mut ISteamNetworking;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_SendP2PPacket(
        self_: *mut ISteamNetworking,
        steamIDRemote: uint64_steamid,
        pubData: *const ::std::os::raw::c_void,
        cubData: uint32,
        eP2PSendType: EP2PSend,
        nChannel: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_IsP2PPacketAvailable(
        self_: *mut ISteamNetworking,
        pcubMsgSize: *mut uint32,
        nChannel: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_ReadP2PPacket(
        self_: *mut ISteamNetworking,
        pubDest: *mut ::std::os::raw::c_void,
        cubDest: uint32,
        pcubMsgSize: *mut uint32,
        psteamIDRemote: *mut CSteamID,
        nChannel: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_AcceptP2PSessionWithUser(
        self_: *mut ISteamNetworking,
        steamIDRemote: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_CloseP2PSessionWithUser(
        self_: *mut ISteamNetworking,
        steamIDRemote: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_CloseP2PChannelWithUser(
        self_: *mut ISteamNetworking,
        steamIDRemote: uint64_steamid,
        nChannel: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_GetP2PSessionState(
        self_: *mut ISteamNetworking,
        steamIDRemote: uint64_steamid,
        pConnectionState: *mut P2PSessionState_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_AllowP2PPacketRelay(
        self_: *mut ISteamNetworking,
        bAllow: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_CreateListenSocket(
        self_: *mut ISteamNetworking,
        nVirtualP2PPort: ::std::os::raw::c_int,
        nIP: SteamIPAddress_t,
        nPort: uint16,
        bAllowUseOfPacketRelay: bool,
    ) -> SNetListenSocket_t;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_CreateP2PConnectionSocket(
        self_: *mut ISteamNetworking,
        steamIDTarget: uint64_steamid,
        nVirtualPort: ::std::os::raw::c_int,
        nTimeoutSec: ::std::os::raw::c_int,
        bAllowUseOfPacketRelay: bool,
    ) -> SNetSocket_t;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_CreateConnectionSocket(
        self_: *mut ISteamNetworking,
        nIP: SteamIPAddress_t,
        nPort: uint16,
        nTimeoutSec: ::std::os::raw::c_int,
    ) -> SNetSocket_t;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_DestroySocket(
        self_: *mut ISteamNetworking,
        hSocket: SNetSocket_t,
        bNotifyRemoteEnd: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_DestroyListenSocket(
        self_: *mut ISteamNetworking,
        hSocket: SNetListenSocket_t,
        bNotifyRemoteEnd: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_SendDataOnSocket(
        self_: *mut ISteamNetworking,
        hSocket: SNetSocket_t,
        pubData: *mut ::std::os::raw::c_void,
        cubData: uint32,
        bReliable: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_IsDataAvailableOnSocket(
        self_: *mut ISteamNetworking,
        hSocket: SNetSocket_t,
        pcubMsgSize: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_RetrieveDataFromSocket(
        self_: *mut ISteamNetworking,
        hSocket: SNetSocket_t,
        pubDest: *mut ::std::os::raw::c_void,
        cubDest: uint32,
        pcubMsgSize: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_IsDataAvailable(
        self_: *mut ISteamNetworking,
        hListenSocket: SNetListenSocket_t,
        pcubMsgSize: *mut uint32,
        phSocket: *mut SNetSocket_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_RetrieveData(
        self_: *mut ISteamNetworking,
        hListenSocket: SNetListenSocket_t,
        pubDest: *mut ::std::os::raw::c_void,
        cubDest: uint32,
        pcubMsgSize: *mut uint32,
        phSocket: *mut SNetSocket_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_GetSocketInfo(
        self_: *mut ISteamNetworking,
        hSocket: SNetSocket_t,
        pSteamIDRemote: *mut CSteamID,
        peSocketStatus: *mut ::std::os::raw::c_int,
        punIPRemote: *mut SteamIPAddress_t,
        punPortRemote: *mut uint16,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_GetListenSocketInfo(
        self_: *mut ISteamNetworking,
        hListenSocket: SNetListenSocket_t,
        pnIP: *mut SteamIPAddress_t,
        pnPort: *mut uint16,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_GetSocketConnectionType(
        self_: *mut ISteamNetworking,
        hSocket: SNetSocket_t,
    ) -> ESNetSocketConnectionType;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_GetMaxPacketSize(
        self_: *mut ISteamNetworking,
        hSocket: SNetSocket_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_SteamScreenshots_v003() -> *mut ISteamScreenshots;
}
extern "C" {
    pub fn SteamAPI_ISteamScreenshots_WriteScreenshot(
        self_: *mut ISteamScreenshots,
        pubRGB: *mut ::std::os::raw::c_void,
        cubRGB: uint32,
        nWidth: ::std::os::raw::c_int,
        nHeight: ::std::os::raw::c_int,
    ) -> ScreenshotHandle;
}
extern "C" {
    pub fn SteamAPI_ISteamScreenshots_AddScreenshotToLibrary(
        self_: *mut ISteamScreenshots,
        pchFilename: *const ::std::os::raw::c_char,
        pchThumbnailFilename: *const ::std::os::raw::c_char,
        nWidth: ::std::os::raw::c_int,
        nHeight: ::std::os::raw::c_int,
    ) -> ScreenshotHandle;
}
extern "C" {
    pub fn SteamAPI_ISteamScreenshots_TriggerScreenshot(self_: *mut ISteamScreenshots);
}
extern "C" {
    pub fn SteamAPI_ISteamScreenshots_HookScreenshots(self_: *mut ISteamScreenshots, bHook: bool);
}
extern "C" {
    pub fn SteamAPI_ISteamScreenshots_SetLocation(
        self_: *mut ISteamScreenshots,
        hScreenshot: ScreenshotHandle,
        pchLocation: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamScreenshots_TagUser(
        self_: *mut ISteamScreenshots,
        hScreenshot: ScreenshotHandle,
        steamID: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamScreenshots_TagPublishedFile(
        self_: *mut ISteamScreenshots,
        hScreenshot: ScreenshotHandle,
        unPublishedFileID: PublishedFileId_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamScreenshots_IsScreenshotsHooked(self_: *mut ISteamScreenshots) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamScreenshots_AddVRScreenshotToLibrary(
        self_: *mut ISteamScreenshots,
        eType: EVRScreenshotType,
        pchFilename: *const ::std::os::raw::c_char,
        pchVRFilename: *const ::std::os::raw::c_char,
    ) -> ScreenshotHandle;
}
extern "C" {
    pub fn SteamAPI_SteamMusic_v001() -> *mut ISteamMusic;
}
extern "C" {
    pub fn SteamAPI_ISteamMusic_BIsEnabled(self_: *mut ISteamMusic) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusic_BIsPlaying(self_: *mut ISteamMusic) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusic_GetPlaybackStatus(self_: *mut ISteamMusic) -> AudioPlayback_Status;
}
extern "C" {
    pub fn SteamAPI_ISteamMusic_Play(self_: *mut ISteamMusic);
}
extern "C" {
    pub fn SteamAPI_ISteamMusic_Pause(self_: *mut ISteamMusic);
}
extern "C" {
    pub fn SteamAPI_ISteamMusic_PlayPrevious(self_: *mut ISteamMusic);
}
extern "C" {
    pub fn SteamAPI_ISteamMusic_PlayNext(self_: *mut ISteamMusic);
}
extern "C" {
    pub fn SteamAPI_ISteamMusic_SetVolume(self_: *mut ISteamMusic, flVolume: f32);
}
extern "C" {
    pub fn SteamAPI_ISteamMusic_GetVolume(self_: *mut ISteamMusic) -> f32;
}
extern "C" {
    pub fn SteamAPI_SteamMusicRemote_v001() -> *mut ISteamMusicRemote;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_RegisterSteamMusicRemote(
        self_: *mut ISteamMusicRemote,
        pchName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_DeregisterSteamMusicRemote(
        self_: *mut ISteamMusicRemote,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_BIsCurrentMusicRemote(self_: *mut ISteamMusicRemote) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_BActivationSuccess(
        self_: *mut ISteamMusicRemote,
        bValue: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_SetDisplayName(
        self_: *mut ISteamMusicRemote,
        pchDisplayName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_SetPNGIcon_64x64(
        self_: *mut ISteamMusicRemote,
        pvBuffer: *mut ::std::os::raw::c_void,
        cbBufferLength: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_EnablePlayPrevious(
        self_: *mut ISteamMusicRemote,
        bValue: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_EnablePlayNext(
        self_: *mut ISteamMusicRemote,
        bValue: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_EnableShuffled(
        self_: *mut ISteamMusicRemote,
        bValue: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_EnableLooped(
        self_: *mut ISteamMusicRemote,
        bValue: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_EnableQueue(
        self_: *mut ISteamMusicRemote,
        bValue: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_EnablePlaylists(
        self_: *mut ISteamMusicRemote,
        bValue: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_UpdatePlaybackStatus(
        self_: *mut ISteamMusicRemote,
        nStatus: AudioPlayback_Status,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_UpdateShuffled(
        self_: *mut ISteamMusicRemote,
        bValue: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_UpdateLooped(
        self_: *mut ISteamMusicRemote,
        bValue: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_UpdateVolume(
        self_: *mut ISteamMusicRemote,
        flValue: f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_CurrentEntryWillChange(self_: *mut ISteamMusicRemote)
        -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_CurrentEntryIsAvailable(
        self_: *mut ISteamMusicRemote,
        bAvailable: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_UpdateCurrentEntryText(
        self_: *mut ISteamMusicRemote,
        pchText: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_UpdateCurrentEntryElapsedSeconds(
        self_: *mut ISteamMusicRemote,
        nValue: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_UpdateCurrentEntryCoverArt(
        self_: *mut ISteamMusicRemote,
        pvBuffer: *mut ::std::os::raw::c_void,
        cbBufferLength: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_CurrentEntryDidChange(self_: *mut ISteamMusicRemote) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_QueueWillChange(self_: *mut ISteamMusicRemote) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_ResetQueueEntries(self_: *mut ISteamMusicRemote) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_SetQueueEntry(
        self_: *mut ISteamMusicRemote,
        nID: ::std::os::raw::c_int,
        nPosition: ::std::os::raw::c_int,
        pchEntryText: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_SetCurrentQueueEntry(
        self_: *mut ISteamMusicRemote,
        nID: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_QueueDidChange(self_: *mut ISteamMusicRemote) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_PlaylistWillChange(self_: *mut ISteamMusicRemote) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_ResetPlaylistEntries(self_: *mut ISteamMusicRemote) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_SetPlaylistEntry(
        self_: *mut ISteamMusicRemote,
        nID: ::std::os::raw::c_int,
        nPosition: ::std::os::raw::c_int,
        pchEntryText: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_SetCurrentPlaylistEntry(
        self_: *mut ISteamMusicRemote,
        nID: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_PlaylistDidChange(self_: *mut ISteamMusicRemote) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamHTTP_v003() -> *mut ISteamHTTP;
}
extern "C" {
    pub fn SteamAPI_SteamGameServerHTTP_v003() -> *mut ISteamHTTP;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_CreateHTTPRequest(
        self_: *mut ISteamHTTP,
        eHTTPRequestMethod: EHTTPMethod,
        pchAbsoluteURL: *const ::std::os::raw::c_char,
    ) -> HTTPRequestHandle;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_SetHTTPRequestContextValue(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        ulContextValue: uint64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_SetHTTPRequestNetworkActivityTimeout(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        unTimeoutSeconds: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_SetHTTPRequestHeaderValue(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        pchHeaderName: *const ::std::os::raw::c_char,
        pchHeaderValue: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_SetHTTPRequestGetOrPostParameter(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        pchParamName: *const ::std::os::raw::c_char,
        pchParamValue: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_SendHTTPRequest(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        pCallHandle: *mut SteamAPICall_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_SendHTTPRequestAndStreamResponse(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        pCallHandle: *mut SteamAPICall_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_DeferHTTPRequest(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_PrioritizeHTTPRequest(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_GetHTTPResponseHeaderSize(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        pchHeaderName: *const ::std::os::raw::c_char,
        unResponseHeaderSize: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_GetHTTPResponseHeaderValue(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        pchHeaderName: *const ::std::os::raw::c_char,
        pHeaderValueBuffer: *mut uint8,
        unBufferSize: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_GetHTTPResponseBodySize(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        unBodySize: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_GetHTTPResponseBodyData(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        pBodyDataBuffer: *mut uint8,
        unBufferSize: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_GetHTTPStreamingResponseBodyData(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        cOffset: uint32,
        pBodyDataBuffer: *mut uint8,
        unBufferSize: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_ReleaseHTTPRequest(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_GetHTTPDownloadProgressPct(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        pflPercentOut: *mut f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_SetHTTPRequestRawPostBody(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        pchContentType: *const ::std::os::raw::c_char,
        pubBody: *mut uint8,
        unBodyLen: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_CreateCookieContainer(
        self_: *mut ISteamHTTP,
        bAllowResponsesToModify: bool,
    ) -> HTTPCookieContainerHandle;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_ReleaseCookieContainer(
        self_: *mut ISteamHTTP,
        hCookieContainer: HTTPCookieContainerHandle,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_SetCookie(
        self_: *mut ISteamHTTP,
        hCookieContainer: HTTPCookieContainerHandle,
        pchHost: *const ::std::os::raw::c_char,
        pchUrl: *const ::std::os::raw::c_char,
        pchCookie: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_SetHTTPRequestCookieContainer(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        hCookieContainer: HTTPCookieContainerHandle,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_SetHTTPRequestUserAgentInfo(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        pchUserAgentInfo: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_SetHTTPRequestRequiresVerifiedCertificate(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        bRequireVerifiedCertificate: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_SetHTTPRequestAbsoluteTimeoutMS(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        unMilliseconds: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_GetHTTPRequestWasTimedOut(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        pbWasTimedOut: *mut bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamInput_v006() -> *mut ISteamInput;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_Init(
        self_: *mut ISteamInput,
        bExplicitlyCallRunFrame: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_Shutdown(self_: *mut ISteamInput) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_SetInputActionManifestFilePath(
        self_: *mut ISteamInput,
        pchInputActionManifestAbsolutePath: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_RunFrame(self_: *mut ISteamInput, bReservedValue: bool);
}
extern "C" {
    pub fn SteamAPI_ISteamInput_BWaitForData(
        self_: *mut ISteamInput,
        bWaitForever: bool,
        unTimeout: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_BNewDataAvailable(self_: *mut ISteamInput) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetConnectedControllers(
        self_: *mut ISteamInput,
        handlesOut: *mut InputHandle_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_EnableDeviceCallbacks(self_: *mut ISteamInput);
}
extern "C" {
    pub fn SteamAPI_ISteamInput_EnableActionEventCallbacks(
        self_: *mut ISteamInput,
        pCallback: SteamInputActionEventCallbackPointer,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetActionSetHandle(
        self_: *mut ISteamInput,
        pszActionSetName: *const ::std::os::raw::c_char,
    ) -> InputActionSetHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_ActivateActionSet(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        actionSetHandle: InputActionSetHandle_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetCurrentActionSet(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
    ) -> InputActionSetHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_ActivateActionSetLayer(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        actionSetLayerHandle: InputActionSetHandle_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInput_DeactivateActionSetLayer(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        actionSetLayerHandle: InputActionSetHandle_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInput_DeactivateAllActionSetLayers(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetActiveActionSetLayers(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        handlesOut: *mut InputActionSetHandle_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetDigitalActionHandle(
        self_: *mut ISteamInput,
        pszActionName: *const ::std::os::raw::c_char,
    ) -> InputDigitalActionHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetDigitalActionData(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        digitalActionHandle: InputDigitalActionHandle_t,
    ) -> InputDigitalActionData_t;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetDigitalActionOrigins(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        actionSetHandle: InputActionSetHandle_t,
        digitalActionHandle: InputDigitalActionHandle_t,
        originsOut: *mut EInputActionOrigin,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetStringForDigitalActionName(
        self_: *mut ISteamInput,
        eActionHandle: InputDigitalActionHandle_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetAnalogActionHandle(
        self_: *mut ISteamInput,
        pszActionName: *const ::std::os::raw::c_char,
    ) -> InputAnalogActionHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetAnalogActionData(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        analogActionHandle: InputAnalogActionHandle_t,
    ) -> InputAnalogActionData_t;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetAnalogActionOrigins(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        actionSetHandle: InputActionSetHandle_t,
        analogActionHandle: InputAnalogActionHandle_t,
        originsOut: *mut EInputActionOrigin,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetGlyphPNGForActionOrigin(
        self_: *mut ISteamInput,
        eOrigin: EInputActionOrigin,
        eSize: ESteamInputGlyphSize,
        unFlags: uint32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetGlyphSVGForActionOrigin(
        self_: *mut ISteamInput,
        eOrigin: EInputActionOrigin,
        unFlags: uint32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetGlyphForActionOrigin_Legacy(
        self_: *mut ISteamInput,
        eOrigin: EInputActionOrigin,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetStringForActionOrigin(
        self_: *mut ISteamInput,
        eOrigin: EInputActionOrigin,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetStringForAnalogActionName(
        self_: *mut ISteamInput,
        eActionHandle: InputAnalogActionHandle_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_StopAnalogActionMomentum(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        eAction: InputAnalogActionHandle_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetMotionData(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
    ) -> InputMotionData_t;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_TriggerVibration(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        usLeftSpeed: ::std::os::raw::c_ushort,
        usRightSpeed: ::std::os::raw::c_ushort,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInput_TriggerVibrationExtended(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        usLeftSpeed: ::std::os::raw::c_ushort,
        usRightSpeed: ::std::os::raw::c_ushort,
        usLeftTriggerSpeed: ::std::os::raw::c_ushort,
        usRightTriggerSpeed: ::std::os::raw::c_ushort,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInput_TriggerSimpleHapticEvent(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        eHapticLocation: EControllerHapticLocation,
        nIntensity: uint8,
        nGainDB: ::std::os::raw::c_char,
        nOtherIntensity: uint8,
        nOtherGainDB: ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInput_SetLEDColor(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        nColorR: uint8,
        nColorG: uint8,
        nColorB: uint8,
        nFlags: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInput_Legacy_TriggerHapticPulse(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        eTargetPad: ESteamControllerPad,
        usDurationMicroSec: ::std::os::raw::c_ushort,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInput_Legacy_TriggerRepeatedHapticPulse(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        eTargetPad: ESteamControllerPad,
        usDurationMicroSec: ::std::os::raw::c_ushort,
        usOffMicroSec: ::std::os::raw::c_ushort,
        unRepeat: ::std::os::raw::c_ushort,
        nFlags: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInput_ShowBindingPanel(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetInputTypeForHandle(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
    ) -> ESteamInputType;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetControllerForGamepadIndex(
        self_: *mut ISteamInput,
        nIndex: ::std::os::raw::c_int,
    ) -> InputHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetGamepadIndexForController(
        self_: *mut ISteamInput,
        ulinputHandle: InputHandle_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetStringForXboxOrigin(
        self_: *mut ISteamInput,
        eOrigin: EXboxOrigin,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetGlyphForXboxOrigin(
        self_: *mut ISteamInput,
        eOrigin: EXboxOrigin,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetActionOriginFromXboxOrigin(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        eOrigin: EXboxOrigin,
    ) -> EInputActionOrigin;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_TranslateActionOrigin(
        self_: *mut ISteamInput,
        eDestinationInputType: ESteamInputType,
        eSourceOrigin: EInputActionOrigin,
    ) -> EInputActionOrigin;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetDeviceBindingRevision(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        pMajor: *mut ::std::os::raw::c_int,
        pMinor: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetRemotePlaySessionID(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetSessionInputConfigurationSettings(
        self_: *mut ISteamInput,
    ) -> uint16;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_SetDualSenseTriggerEffect(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        pParam: *const ScePadTriggerEffectParam,
    );
}
extern "C" {
    pub fn SteamAPI_SteamController_v008() -> *mut ISteamController;
}
extern "C" {
    pub fn SteamAPI_ISteamController_Init(self_: *mut ISteamController) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamController_Shutdown(self_: *mut ISteamController) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamController_RunFrame(self_: *mut ISteamController);
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetConnectedControllers(
        self_: *mut ISteamController,
        handlesOut: *mut ControllerHandle_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetActionSetHandle(
        self_: *mut ISteamController,
        pszActionSetName: *const ::std::os::raw::c_char,
    ) -> ControllerActionSetHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamController_ActivateActionSet(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        actionSetHandle: ControllerActionSetHandle_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetCurrentActionSet(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
    ) -> ControllerActionSetHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamController_ActivateActionSetLayer(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        actionSetLayerHandle: ControllerActionSetHandle_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamController_DeactivateActionSetLayer(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        actionSetLayerHandle: ControllerActionSetHandle_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamController_DeactivateAllActionSetLayers(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetActiveActionSetLayers(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        handlesOut: *mut ControllerActionSetHandle_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetDigitalActionHandle(
        self_: *mut ISteamController,
        pszActionName: *const ::std::os::raw::c_char,
    ) -> ControllerDigitalActionHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetDigitalActionData(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        digitalActionHandle: ControllerDigitalActionHandle_t,
    ) -> InputDigitalActionData_t;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetDigitalActionOrigins(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        actionSetHandle: ControllerActionSetHandle_t,
        digitalActionHandle: ControllerDigitalActionHandle_t,
        originsOut: *mut EControllerActionOrigin,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetAnalogActionHandle(
        self_: *mut ISteamController,
        pszActionName: *const ::std::os::raw::c_char,
    ) -> ControllerAnalogActionHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetAnalogActionData(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        analogActionHandle: ControllerAnalogActionHandle_t,
    ) -> InputAnalogActionData_t;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetAnalogActionOrigins(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        actionSetHandle: ControllerActionSetHandle_t,
        analogActionHandle: ControllerAnalogActionHandle_t,
        originsOut: *mut EControllerActionOrigin,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetGlyphForActionOrigin(
        self_: *mut ISteamController,
        eOrigin: EControllerActionOrigin,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetStringForActionOrigin(
        self_: *mut ISteamController,
        eOrigin: EControllerActionOrigin,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamController_StopAnalogActionMomentum(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        eAction: ControllerAnalogActionHandle_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetMotionData(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
    ) -> InputMotionData_t;
}
extern "C" {
    pub fn SteamAPI_ISteamController_TriggerHapticPulse(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        eTargetPad: ESteamControllerPad,
        usDurationMicroSec: ::std::os::raw::c_ushort,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamController_TriggerRepeatedHapticPulse(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        eTargetPad: ESteamControllerPad,
        usDurationMicroSec: ::std::os::raw::c_ushort,
        usOffMicroSec: ::std::os::raw::c_ushort,
        unRepeat: ::std::os::raw::c_ushort,
        nFlags: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamController_TriggerVibration(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        usLeftSpeed: ::std::os::raw::c_ushort,
        usRightSpeed: ::std::os::raw::c_ushort,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamController_SetLEDColor(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        nColorR: uint8,
        nColorG: uint8,
        nColorB: uint8,
        nFlags: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamController_ShowBindingPanel(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetInputTypeForHandle(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
    ) -> ESteamInputType;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetControllerForGamepadIndex(
        self_: *mut ISteamController,
        nIndex: ::std::os::raw::c_int,
    ) -> ControllerHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetGamepadIndexForController(
        self_: *mut ISteamController,
        ulControllerHandle: ControllerHandle_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetStringForXboxOrigin(
        self_: *mut ISteamController,
        eOrigin: EXboxOrigin,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetGlyphForXboxOrigin(
        self_: *mut ISteamController,
        eOrigin: EXboxOrigin,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetActionOriginFromXboxOrigin(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        eOrigin: EXboxOrigin,
    ) -> EControllerActionOrigin;
}
extern "C" {
    pub fn SteamAPI_ISteamController_TranslateActionOrigin(
        self_: *mut ISteamController,
        eDestinationInputType: ESteamInputType,
        eSourceOrigin: EControllerActionOrigin,
    ) -> EControllerActionOrigin;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetControllerBindingRevision(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        pMajor: *mut ::std::os::raw::c_int,
        pMinor: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamUGC_v021() -> *mut ISteamUGC;
}
extern "C" {
    pub fn SteamAPI_SteamGameServerUGC_v021() -> *mut ISteamUGC;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_CreateQueryUserUGCRequest(
        self_: *mut ISteamUGC,
        unAccountID: AccountID_t,
        eListType: EUserUGCList,
        eMatchingUGCType: EUGCMatchingUGCType,
        eSortOrder: EUserUGCListSortOrder,
        nCreatorAppID: AppId_t,
        nConsumerAppID: AppId_t,
        unPage: uint32,
    ) -> UGCQueryHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_CreateQueryAllUGCRequestPage(
        self_: *mut ISteamUGC,
        eQueryType: EUGCQuery,
        eMatchingeMatchingUGCTypeFileType: EUGCMatchingUGCType,
        nCreatorAppID: AppId_t,
        nConsumerAppID: AppId_t,
        unPage: uint32,
    ) -> UGCQueryHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_CreateQueryAllUGCRequestCursor(
        self_: *mut ISteamUGC,
        eQueryType: EUGCQuery,
        eMatchingeMatchingUGCTypeFileType: EUGCMatchingUGCType,
        nCreatorAppID: AppId_t,
        nConsumerAppID: AppId_t,
        pchCursor: *const ::std::os::raw::c_char,
    ) -> UGCQueryHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_CreateQueryUGCDetailsRequest(
        self_: *mut ISteamUGC,
        pvecPublishedFileID: *mut PublishedFileId_t,
        unNumPublishedFileIDs: uint32,
    ) -> UGCQueryHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SendQueryUGCRequest(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCResult(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
        pDetails: *mut SteamUGCDetails_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCNumTags(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCTag(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
        indexTag: uint32,
        pchValue: *mut ::std::os::raw::c_char,
        cchValueSize: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCTagDisplayName(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
        indexTag: uint32,
        pchValue: *mut ::std::os::raw::c_char,
        cchValueSize: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCPreviewURL(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
        pchURL: *mut ::std::os::raw::c_char,
        cchURLSize: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCMetadata(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
        pchMetadata: *mut ::std::os::raw::c_char,
        cchMetadatasize: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCChildren(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
        pvecPublishedFileID: *mut PublishedFileId_t,
        cMaxEntries: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCStatistic(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
        eStatType: EItemStatistic,
        pStatValue: *mut uint64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCNumAdditionalPreviews(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCAdditionalPreview(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
        previewIndex: uint32,
        pchURLOrVideoID: *mut ::std::os::raw::c_char,
        cchURLSize: uint32,
        pchOriginalFileName: *mut ::std::os::raw::c_char,
        cchOriginalFileNameSize: uint32,
        pPreviewType: *mut EItemPreviewType,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCNumKeyValueTags(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCKeyValueTag(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
        keyValueTagIndex: uint32,
        pchKey: *mut ::std::os::raw::c_char,
        cchKeySize: uint32,
        pchValue: *mut ::std::os::raw::c_char,
        cchValueSize: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryFirstUGCKeyValueTag(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
        pchKey: *const ::std::os::raw::c_char,
        pchValue: *mut ::std::os::raw::c_char,
        cchValueSize: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetNumSupportedGameVersions(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetSupportedGameVersionData(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
        versionIndex: uint32,
        pchGameBranchMin: *mut ::std::os::raw::c_char,
        pchGameBranchMax: *mut ::std::os::raw::c_char,
        cchGameBranchSize: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCContentDescriptors(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
        pvecDescriptors: *mut EUGCContentDescriptorID,
        cMaxEntries: uint32,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_ReleaseQueryUGCRequest(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_AddRequiredTag(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        pTagName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_AddRequiredTagGroup(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        pTagGroups: *const SteamParamStringArray_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_AddExcludedTag(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        pTagName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetReturnOnlyIDs(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        bReturnOnlyIDs: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetReturnKeyValueTags(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        bReturnKeyValueTags: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetReturnLongDescription(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        bReturnLongDescription: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetReturnMetadata(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        bReturnMetadata: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetReturnChildren(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        bReturnChildren: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetReturnAdditionalPreviews(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        bReturnAdditionalPreviews: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetReturnTotalOnly(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        bReturnTotalOnly: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetReturnPlaytimeStats(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        unDays: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetLanguage(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        pchLanguage: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetAllowCachedResponse(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        unMaxAgeSeconds: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetAdminQuery(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        bAdminQuery: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetCloudFileNameFilter(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        pMatchCloudFileName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetMatchAnyTag(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        bMatchAnyTag: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetSearchText(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        pSearchText: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetRankedByTrendDays(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        unDays: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetTimeCreatedDateRange(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        rtStart: RTime32,
        rtEnd: RTime32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetTimeUpdatedDateRange(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        rtStart: RTime32,
        rtEnd: RTime32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_AddRequiredKeyValueTag(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        pKey: *const ::std::os::raw::c_char,
        pValue: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_RequestUGCDetails(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
        unMaxAgeSeconds: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_CreateItem(
        self_: *mut ISteamUGC,
        nConsumerAppId: AppId_t,
        eFileType: EWorkshopFileType,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_StartItemUpdate(
        self_: *mut ISteamUGC,
        nConsumerAppId: AppId_t,
        nPublishedFileID: PublishedFileId_t,
    ) -> UGCUpdateHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetItemTitle(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        pchTitle: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetItemDescription(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        pchDescription: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetItemUpdateLanguage(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        pchLanguage: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetItemMetadata(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        pchMetaData: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetItemVisibility(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        eVisibility: ERemoteStoragePublishedFileVisibility,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetItemTags(
        self_: *mut ISteamUGC,
        updateHandle: UGCUpdateHandle_t,
        pTags: *const SteamParamStringArray_t,
        bAllowAdminTags: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetItemContent(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        pszContentFolder: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetItemPreview(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        pszPreviewFile: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetAllowLegacyUpload(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        bAllowLegacyUpload: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_RemoveAllItemKeyValueTags(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_RemoveItemKeyValueTags(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        pchKey: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_AddItemKeyValueTag(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        pchKey: *const ::std::os::raw::c_char,
        pchValue: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_AddItemPreviewFile(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        pszPreviewFile: *const ::std::os::raw::c_char,
        type_: EItemPreviewType,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_AddItemPreviewVideo(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        pszVideoID: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_UpdateItemPreviewFile(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        index: uint32,
        pszPreviewFile: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_UpdateItemPreviewVideo(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        index: uint32,
        pszVideoID: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_RemoveItemPreview(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        index: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_AddContentDescriptor(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        descid: EUGCContentDescriptorID,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_RemoveContentDescriptor(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        descid: EUGCContentDescriptorID,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetRequiredGameVersions(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        pszGameBranchMin: *const ::std::os::raw::c_char,
        pszGameBranchMax: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SubmitItemUpdate(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        pchChangeNote: *const ::std::os::raw::c_char,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetItemUpdateProgress(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        punBytesProcessed: *mut uint64,
        punBytesTotal: *mut uint64,
    ) -> EItemUpdateStatus;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetUserItemVote(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
        bVoteUp: bool,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetUserItemVote(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_AddItemToFavorites(
        self_: *mut ISteamUGC,
        nAppId: AppId_t,
        nPublishedFileID: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_RemoveItemFromFavorites(
        self_: *mut ISteamUGC,
        nAppId: AppId_t,
        nPublishedFileID: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SubscribeItem(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_UnsubscribeItem(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetNumSubscribedItems(
        self_: *mut ISteamUGC,
        bIncludeLocallyDisabled: bool,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetSubscribedItems(
        self_: *mut ISteamUGC,
        pvecPublishedFileID: *mut PublishedFileId_t,
        cMaxEntries: uint32,
        bIncludeLocallyDisabled: bool,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetItemState(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetItemInstallInfo(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
        punSizeOnDisk: *mut uint64,
        pchFolder: *mut ::std::os::raw::c_char,
        cchFolderSize: uint32,
        punTimeStamp: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetItemDownloadInfo(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
        punBytesDownloaded: *mut uint64,
        punBytesTotal: *mut uint64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_DownloadItem(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
        bHighPriority: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_BInitWorkshopForGameServer(
        self_: *mut ISteamUGC,
        unWorkshopDepotID: DepotId_t,
        pszFolder: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SuspendDownloads(self_: *mut ISteamUGC, bSuspend: bool);
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_StartPlaytimeTracking(
        self_: *mut ISteamUGC,
        pvecPublishedFileID: *mut PublishedFileId_t,
        unNumPublishedFileIDs: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_StopPlaytimeTracking(
        self_: *mut ISteamUGC,
        pvecPublishedFileID: *mut PublishedFileId_t,
        unNumPublishedFileIDs: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_StopPlaytimeTrackingForAllItems(
        self_: *mut ISteamUGC,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_AddDependency(
        self_: *mut ISteamUGC,
        nParentPublishedFileID: PublishedFileId_t,
        nChildPublishedFileID: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_RemoveDependency(
        self_: *mut ISteamUGC,
        nParentPublishedFileID: PublishedFileId_t,
        nChildPublishedFileID: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_AddAppDependency(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
        nAppID: AppId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_RemoveAppDependency(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
        nAppID: AppId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetAppDependencies(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_DeleteItem(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_ShowWorkshopEULA(self_: *mut ISteamUGC) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetWorkshopEULAStatus(self_: *mut ISteamUGC) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetUserContentDescriptorPreferences(
        self_: *mut ISteamUGC,
        pvecDescriptors: *mut EUGCContentDescriptorID,
        cMaxEntries: uint32,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetItemsDisabledLocally(
        self_: *mut ISteamUGC,
        pvecPublishedFileIDs: *mut PublishedFileId_t,
        unNumPublishedFileIDs: uint32,
        bDisabledLocally: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetSubscriptionsLoadOrder(
        self_: *mut ISteamUGC,
        pvecPublishedFileIDs: *mut PublishedFileId_t,
        unNumPublishedFileIDs: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamHTMLSurface_v005() -> *mut ISteamHTMLSurface;
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_Init(self_: *mut ISteamHTMLSurface) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_Shutdown(self_: *mut ISteamHTMLSurface) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_CreateBrowser(
        self_: *mut ISteamHTMLSurface,
        pchUserAgent: *const ::std::os::raw::c_char,
        pchUserCSS: *const ::std::os::raw::c_char,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_RemoveBrowser(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_LoadURL(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        pchURL: *const ::std::os::raw::c_char,
        pchPostData: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_SetSize(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        unWidth: uint32,
        unHeight: uint32,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_StopLoad(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_Reload(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_GoBack(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_GoForward(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_AddHeader(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        pchKey: *const ::std::os::raw::c_char,
        pchValue: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_ExecuteJavascript(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        pchScript: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_MouseUp(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        eMouseButton: ISteamHTMLSurface_EHTMLMouseButton,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_MouseDown(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        eMouseButton: ISteamHTMLSurface_EHTMLMouseButton,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_MouseDoubleClick(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        eMouseButton: ISteamHTMLSurface_EHTMLMouseButton,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_MouseMove(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_MouseWheel(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        nDelta: int32,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_KeyDown(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        nNativeKeyCode: uint32,
        eHTMLKeyModifiers: ISteamHTMLSurface_EHTMLKeyModifiers,
        bIsSystemKey: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_KeyUp(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        nNativeKeyCode: uint32,
        eHTMLKeyModifiers: ISteamHTMLSurface_EHTMLKeyModifiers,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_KeyChar(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        cUnicodeChar: uint32,
        eHTMLKeyModifiers: ISteamHTMLSurface_EHTMLKeyModifiers,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_SetHorizontalScroll(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        nAbsolutePixelScroll: uint32,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_SetVerticalScroll(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        nAbsolutePixelScroll: uint32,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_SetKeyFocus(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        bHasKeyFocus: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_ViewSource(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_CopyToClipboard(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_PasteFromClipboard(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_Find(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        pchSearchStr: *const ::std::os::raw::c_char,
        bCurrentlyInFind: bool,
        bReverse: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_StopFind(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_GetLinkAtPosition(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_SetCookie(
        self_: *mut ISteamHTMLSurface,
        pchHostname: *const ::std::os::raw::c_char,
        pchKey: *const ::std::os::raw::c_char,
        pchValue: *const ::std::os::raw::c_char,
        pchPath: *const ::std::os::raw::c_char,
        nExpires: RTime32,
        bSecure: bool,
        bHTTPOnly: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_SetPageScaleFactor(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        flZoom: f32,
        nPointX: ::std::os::raw::c_int,
        nPointY: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_SetBackgroundMode(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        bBackgroundMode: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_SetDPIScalingFactor(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        flDPIScaling: f32,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_OpenDeveloperTools(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_AllowStartRequest(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        bAllowed: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_JSDialogResponse(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        bResult: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_FileLoadDialogResponse(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        pchSelectedFiles: *mut *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_SteamInventory_v003() -> *mut ISteamInventory;
}
extern "C" {
    pub fn SteamAPI_SteamGameServerInventory_v003() -> *mut ISteamInventory;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GetResultStatus(
        self_: *mut ISteamInventory,
        resultHandle: SteamInventoryResult_t,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GetResultItems(
        self_: *mut ISteamInventory,
        resultHandle: SteamInventoryResult_t,
        pOutItemsArray: *mut SteamItemDetails_t,
        punOutItemsArraySize: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GetResultItemProperty(
        self_: *mut ISteamInventory,
        resultHandle: SteamInventoryResult_t,
        unItemIndex: uint32,
        pchPropertyName: *const ::std::os::raw::c_char,
        pchValueBuffer: *mut ::std::os::raw::c_char,
        punValueBufferSizeOut: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GetResultTimestamp(
        self_: *mut ISteamInventory,
        resultHandle: SteamInventoryResult_t,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_CheckResultSteamID(
        self_: *mut ISteamInventory,
        resultHandle: SteamInventoryResult_t,
        steamIDExpected: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_DestroyResult(
        self_: *mut ISteamInventory,
        resultHandle: SteamInventoryResult_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GetAllItems(
        self_: *mut ISteamInventory,
        pResultHandle: *mut SteamInventoryResult_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GetItemsByID(
        self_: *mut ISteamInventory,
        pResultHandle: *mut SteamInventoryResult_t,
        pInstanceIDs: *const SteamItemInstanceID_t,
        unCountInstanceIDs: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_SerializeResult(
        self_: *mut ISteamInventory,
        resultHandle: SteamInventoryResult_t,
        pOutBuffer: *mut ::std::os::raw::c_void,
        punOutBufferSize: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_DeserializeResult(
        self_: *mut ISteamInventory,
        pOutResultHandle: *mut SteamInventoryResult_t,
        pBuffer: *const ::std::os::raw::c_void,
        unBufferSize: uint32,
        bRESERVED_MUST_BE_FALSE: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GenerateItems(
        self_: *mut ISteamInventory,
        pResultHandle: *mut SteamInventoryResult_t,
        pArrayItemDefs: *const SteamItemDef_t,
        punArrayQuantity: *const uint32,
        unArrayLength: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GrantPromoItems(
        self_: *mut ISteamInventory,
        pResultHandle: *mut SteamInventoryResult_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_AddPromoItem(
        self_: *mut ISteamInventory,
        pResultHandle: *mut SteamInventoryResult_t,
        itemDef: SteamItemDef_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_AddPromoItems(
        self_: *mut ISteamInventory,
        pResultHandle: *mut SteamInventoryResult_t,
        pArrayItemDefs: *const SteamItemDef_t,
        unArrayLength: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_ConsumeItem(
        self_: *mut ISteamInventory,
        pResultHandle: *mut SteamInventoryResult_t,
        itemConsume: SteamItemInstanceID_t,
        unQuantity: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_ExchangeItems(
        self_: *mut ISteamInventory,
        pResultHandle: *mut SteamInventoryResult_t,
        pArrayGenerate: *const SteamItemDef_t,
        punArrayGenerateQuantity: *const uint32,
        unArrayGenerateLength: uint32,
        pArrayDestroy: *const SteamItemInstanceID_t,
        punArrayDestroyQuantity: *const uint32,
        unArrayDestroyLength: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_TransferItemQuantity(
        self_: *mut ISteamInventory,
        pResultHandle: *mut SteamInventoryResult_t,
        itemIdSource: SteamItemInstanceID_t,
        unQuantity: uint32,
        itemIdDest: SteamItemInstanceID_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_SendItemDropHeartbeat(self_: *mut ISteamInventory);
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_TriggerItemDrop(
        self_: *mut ISteamInventory,
        pResultHandle: *mut SteamInventoryResult_t,
        dropListDefinition: SteamItemDef_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_TradeItems(
        self_: *mut ISteamInventory,
        pResultHandle: *mut SteamInventoryResult_t,
        steamIDTradePartner: uint64_steamid,
        pArrayGive: *const SteamItemInstanceID_t,
        pArrayGiveQuantity: *const uint32,
        nArrayGiveLength: uint32,
        pArrayGet: *const SteamItemInstanceID_t,
        pArrayGetQuantity: *const uint32,
        nArrayGetLength: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_LoadItemDefinitions(self_: *mut ISteamInventory) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GetItemDefinitionIDs(
        self_: *mut ISteamInventory,
        pItemDefIDs: *mut SteamItemDef_t,
        punItemDefIDsArraySize: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GetItemDefinitionProperty(
        self_: *mut ISteamInventory,
        iDefinition: SteamItemDef_t,
        pchPropertyName: *const ::std::os::raw::c_char,
        pchValueBuffer: *mut ::std::os::raw::c_char,
        punValueBufferSizeOut: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_RequestEligiblePromoItemDefinitionsIDs(
        self_: *mut ISteamInventory,
        steamID: uint64_steamid,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GetEligiblePromoItemDefinitionIDs(
        self_: *mut ISteamInventory,
        steamID: uint64_steamid,
        pItemDefIDs: *mut SteamItemDef_t,
        punItemDefIDsArraySize: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_StartPurchase(
        self_: *mut ISteamInventory,
        pArrayItemDefs: *const SteamItemDef_t,
        punArrayQuantity: *const uint32,
        unArrayLength: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_RequestPrices(self_: *mut ISteamInventory) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GetNumItemsWithPrices(self_: *mut ISteamInventory) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GetItemsWithPrices(
        self_: *mut ISteamInventory,
        pArrayItemDefs: *mut SteamItemDef_t,
        pCurrentPrices: *mut uint64,
        pBasePrices: *mut uint64,
        unArrayLength: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GetItemPrice(
        self_: *mut ISteamInventory,
        iDefinition: SteamItemDef_t,
        pCurrentPrice: *mut uint64,
        pBasePrice: *mut uint64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_StartUpdateProperties(
        self_: *mut ISteamInventory,
    ) -> SteamInventoryUpdateHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_RemoveProperty(
        self_: *mut ISteamInventory,
        handle: SteamInventoryUpdateHandle_t,
        nItemID: SteamItemInstanceID_t,
        pchPropertyName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_SetPropertyString(
        self_: *mut ISteamInventory,
        handle: SteamInventoryUpdateHandle_t,
        nItemID: SteamItemInstanceID_t,
        pchPropertyName: *const ::std::os::raw::c_char,
        pchPropertyValue: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_SetPropertyBool(
        self_: *mut ISteamInventory,
        handle: SteamInventoryUpdateHandle_t,
        nItemID: SteamItemInstanceID_t,
        pchPropertyName: *const ::std::os::raw::c_char,
        bValue: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_SetPropertyInt64(
        self_: *mut ISteamInventory,
        handle: SteamInventoryUpdateHandle_t,
        nItemID: SteamItemInstanceID_t,
        pchPropertyName: *const ::std::os::raw::c_char,
        nValue: int64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_SetPropertyFloat(
        self_: *mut ISteamInventory,
        handle: SteamInventoryUpdateHandle_t,
        nItemID: SteamItemInstanceID_t,
        pchPropertyName: *const ::std::os::raw::c_char,
        flValue: f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_SubmitUpdateProperties(
        self_: *mut ISteamInventory,
        handle: SteamInventoryUpdateHandle_t,
        pResultHandle: *mut SteamInventoryResult_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_InspectItem(
        self_: *mut ISteamInventory,
        pResultHandle: *mut SteamInventoryResult_t,
        pchItemToken: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamTimeline_v004() -> *mut ISteamTimeline;
}
extern "C" {
    pub fn SteamAPI_ISteamTimeline_SetTimelineTooltip(
        self_: *mut ISteamTimeline,
        pchDescription: *const ::std::os::raw::c_char,
        flTimeDelta: f32,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamTimeline_ClearTimelineTooltip(
        self_: *mut ISteamTimeline,
        flTimeDelta: f32,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamTimeline_SetTimelineGameMode(
        self_: *mut ISteamTimeline,
        eMode: ETimelineGameMode,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamTimeline_AddInstantaneousTimelineEvent(
        self_: *mut ISteamTimeline,
        pchTitle: *const ::std::os::raw::c_char,
        pchDescription: *const ::std::os::raw::c_char,
        pchIcon: *const ::std::os::raw::c_char,
        unIconPriority: uint32,
        flStartOffsetSeconds: f32,
        ePossibleClip: ETimelineEventClipPriority,
    ) -> TimelineEventHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamTimeline_AddRangeTimelineEvent(
        self_: *mut ISteamTimeline,
        pchTitle: *const ::std::os::raw::c_char,
        pchDescription: *const ::std::os::raw::c_char,
        pchIcon: *const ::std::os::raw::c_char,
        unIconPriority: uint32,
        flStartOffsetSeconds: f32,
        flDuration: f32,
        ePossibleClip: ETimelineEventClipPriority,
    ) -> TimelineEventHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamTimeline_StartRangeTimelineEvent(
        self_: *mut ISteamTimeline,
        pchTitle: *const ::std::os::raw::c_char,
        pchDescription: *const ::std::os::raw::c_char,
        pchIcon: *const ::std::os::raw::c_char,
        unPriority: uint32,
        flStartOffsetSeconds: f32,
        ePossibleClip: ETimelineEventClipPriority,
    ) -> TimelineEventHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamTimeline_UpdateRangeTimelineEvent(
        self_: *mut ISteamTimeline,
        ulEvent: TimelineEventHandle_t,
        pchTitle: *const ::std::os::raw::c_char,
        pchDescription: *const ::std::os::raw::c_char,
        pchIcon: *const ::std::os::raw::c_char,
        unPriority: uint32,
        ePossibleClip: ETimelineEventClipPriority,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamTimeline_EndRangeTimelineEvent(
        self_: *mut ISteamTimeline,
        ulEvent: TimelineEventHandle_t,
        flEndOffsetSeconds: f32,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamTimeline_RemoveTimelineEvent(
        self_: *mut ISteamTimeline,
        ulEvent: TimelineEventHandle_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamTimeline_DoesEventRecordingExist(
        self_: *mut ISteamTimeline,
        ulEvent: TimelineEventHandle_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamTimeline_StartGamePhase(self_: *mut ISteamTimeline);
}
extern "C" {
    pub fn SteamAPI_ISteamTimeline_EndGamePhase(self_: *mut ISteamTimeline);
}
extern "C" {
    pub fn SteamAPI_ISteamTimeline_SetGamePhaseID(
        self_: *mut ISteamTimeline,
        pchPhaseID: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamTimeline_DoesGamePhaseRecordingExist(
        self_: *mut ISteamTimeline,
        pchPhaseID: *const ::std::os::raw::c_char,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamTimeline_AddGamePhaseTag(
        self_: *mut ISteamTimeline,
        pchTagName: *const ::std::os::raw::c_char,
        pchTagIcon: *const ::std::os::raw::c_char,
        pchTagGroup: *const ::std::os::raw::c_char,
        unPriority: uint32,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamTimeline_SetGamePhaseAttribute(
        self_: *mut ISteamTimeline,
        pchAttributeGroup: *const ::std::os::raw::c_char,
        pchAttributeValue: *const ::std::os::raw::c_char,
        unPriority: uint32,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamTimeline_OpenOverlayToGamePhase(
        self_: *mut ISteamTimeline,
        pchPhaseID: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamTimeline_OpenOverlayToTimelineEvent(
        self_: *mut ISteamTimeline,
        ulEvent: TimelineEventHandle_t,
    );
}
extern "C" {
    pub fn SteamAPI_SteamVideo_v007() -> *mut ISteamVideo;
}
extern "C" {
    pub fn SteamAPI_ISteamVideo_GetVideoURL(self_: *mut ISteamVideo, unVideoAppID: AppId_t);
}
extern "C" {
    pub fn SteamAPI_ISteamVideo_IsBroadcasting(
        self_: *mut ISteamVideo,
        pnNumViewers: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamVideo_GetOPFSettings(self_: *mut ISteamVideo, unVideoAppID: AppId_t);
}
extern "C" {
    pub fn SteamAPI_ISteamVideo_GetOPFStringForApp(
        self_: *mut ISteamVideo,
        unVideoAppID: AppId_t,
        pchBuffer: *mut ::std::os::raw::c_char,
        pnBufferSize: *mut int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamParentalSettings_v001() -> *mut ISteamParentalSettings;
}
extern "C" {
    pub fn SteamAPI_ISteamParentalSettings_BIsParentalLockEnabled(
        self_: *mut ISteamParentalSettings,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamParentalSettings_BIsParentalLockLocked(
        self_: *mut ISteamParentalSettings,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamParentalSettings_BIsAppBlocked(
        self_: *mut ISteamParentalSettings,
        nAppID: AppId_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamParentalSettings_BIsAppInBlockList(
        self_: *mut ISteamParentalSettings,
        nAppID: AppId_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamParentalSettings_BIsFeatureBlocked(
        self_: *mut ISteamParentalSettings,
        eFeature: EParentalFeature,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamParentalSettings_BIsFeatureInBlockList(
        self_: *mut ISteamParentalSettings,
        eFeature: EParentalFeature,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamRemotePlay_v003() -> *mut ISteamRemotePlay;
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_GetSessionCount(self_: *mut ISteamRemotePlay) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_GetSessionID(
        self_: *mut ISteamRemotePlay,
        iSessionIndex: ::std::os::raw::c_int,
    ) -> RemotePlaySessionID_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_GetSessionSteamID(
        self_: *mut ISteamRemotePlay,
        unSessionID: RemotePlaySessionID_t,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_GetSessionClientName(
        self_: *mut ISteamRemotePlay,
        unSessionID: RemotePlaySessionID_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_GetSessionClientFormFactor(
        self_: *mut ISteamRemotePlay,
        unSessionID: RemotePlaySessionID_t,
    ) -> ESteamDeviceFormFactor;
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_BGetSessionClientResolution(
        self_: *mut ISteamRemotePlay,
        unSessionID: RemotePlaySessionID_t,
        pnResolutionX: *mut ::std::os::raw::c_int,
        pnResolutionY: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_ShowRemotePlayTogetherUI(self_: *mut ISteamRemotePlay)
        -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_BSendRemotePlayTogetherInvite(
        self_: *mut ISteamRemotePlay,
        steamIDFriend: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_BEnableRemotePlayTogetherDirectInput(
        self_: *mut ISteamRemotePlay,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_DisableRemotePlayTogetherDirectInput(
        self_: *mut ISteamRemotePlay,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_GetInput(
        self_: *mut ISteamRemotePlay,
        pInput: *mut RemotePlayInput_t,
        unMaxEvents: uint32,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_SetMouseVisibility(
        self_: *mut ISteamRemotePlay,
        unSessionID: RemotePlaySessionID_t,
        bVisible: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_SetMousePosition(
        self_: *mut ISteamRemotePlay,
        unSessionID: RemotePlaySessionID_t,
        flNormalizedX: f32,
        flNormalizedY: f32,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_CreateMouseCursor(
        self_: *mut ISteamRemotePlay,
        nWidth: ::std::os::raw::c_int,
        nHeight: ::std::os::raw::c_int,
        nHotX: ::std::os::raw::c_int,
        nHotY: ::std::os::raw::c_int,
        pBGRA: *const ::std::os::raw::c_void,
        nPitch: ::std::os::raw::c_int,
    ) -> RemotePlayCursorID_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_SetMouseCursor(
        self_: *mut ISteamRemotePlay,
        unSessionID: RemotePlaySessionID_t,
        unCursorID: RemotePlayCursorID_t,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingMessages_SteamAPI_v002() -> *mut ISteamNetworkingMessages;
}
extern "C" {
    pub fn SteamAPI_SteamGameServerNetworkingMessages_SteamAPI_v002(
    ) -> *mut ISteamNetworkingMessages;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingMessages_SendMessageToUser(
        self_: *mut ISteamNetworkingMessages,
        identityRemote: *const SteamNetworkingIdentity,
        pubData: *const ::std::os::raw::c_void,
        cubData: uint32,
        nSendFlags: ::std::os::raw::c_int,
        nRemoteChannel: ::std::os::raw::c_int,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingMessages_ReceiveMessagesOnChannel(
        self_: *mut ISteamNetworkingMessages,
        nLocalChannel: ::std::os::raw::c_int,
        ppOutMessages: *mut *mut SteamNetworkingMessage_t,
        nMaxMessages: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingMessages_AcceptSessionWithUser(
        self_: *mut ISteamNetworkingMessages,
        identityRemote: *const SteamNetworkingIdentity,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingMessages_CloseSessionWithUser(
        self_: *mut ISteamNetworkingMessages,
        identityRemote: *const SteamNetworkingIdentity,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingMessages_CloseChannelWithUser(
        self_: *mut ISteamNetworkingMessages,
        identityRemote: *const SteamNetworkingIdentity,
        nLocalChannel: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingMessages_GetSessionConnectionInfo(
        self_: *mut ISteamNetworkingMessages,
        identityRemote: *const SteamNetworkingIdentity,
        pConnectionInfo: *mut SteamNetConnectionInfo_t,
        pQuickStatus: *mut SteamNetConnectionRealTimeStatus_t,
    ) -> ESteamNetworkingConnectionState;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingSockets_SteamAPI_v012() -> *mut ISteamNetworkingSockets;
}
extern "C" {
    pub fn SteamAPI_SteamGameServerNetworkingSockets_SteamAPI_v012() -> *mut ISteamNetworkingSockets;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_CreateListenSocketIP(
        self_: *mut ISteamNetworkingSockets,
        localAddress: *const SteamNetworkingIPAddr,
        nOptions: ::std::os::raw::c_int,
        pOptions: *const SteamNetworkingConfigValue_t,
    ) -> HSteamListenSocket;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ConnectByIPAddress(
        self_: *mut ISteamNetworkingSockets,
        address: *const SteamNetworkingIPAddr,
        nOptions: ::std::os::raw::c_int,
        pOptions: *const SteamNetworkingConfigValue_t,
    ) -> HSteamNetConnection;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_CreateListenSocketP2P(
        self_: *mut ISteamNetworkingSockets,
        nLocalVirtualPort: ::std::os::raw::c_int,
        nOptions: ::std::os::raw::c_int,
        pOptions: *const SteamNetworkingConfigValue_t,
    ) -> HSteamListenSocket;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ConnectP2P(
        self_: *mut ISteamNetworkingSockets,
        identityRemote: *const SteamNetworkingIdentity,
        nRemoteVirtualPort: ::std::os::raw::c_int,
        nOptions: ::std::os::raw::c_int,
        pOptions: *const SteamNetworkingConfigValue_t,
    ) -> HSteamNetConnection;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_AcceptConnection(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_CloseConnection(
        self_: *mut ISteamNetworkingSockets,
        hPeer: HSteamNetConnection,
        nReason: ::std::os::raw::c_int,
        pszDebug: *const ::std::os::raw::c_char,
        bEnableLinger: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_CloseListenSocket(
        self_: *mut ISteamNetworkingSockets,
        hSocket: HSteamListenSocket,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_SetConnectionUserData(
        self_: *mut ISteamNetworkingSockets,
        hPeer: HSteamNetConnection,
        nUserData: int64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetConnectionUserData(
        self_: *mut ISteamNetworkingSockets,
        hPeer: HSteamNetConnection,
    ) -> int64;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_SetConnectionName(
        self_: *mut ISteamNetworkingSockets,
        hPeer: HSteamNetConnection,
        pszName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetConnectionName(
        self_: *mut ISteamNetworkingSockets,
        hPeer: HSteamNetConnection,
        pszName: *mut ::std::os::raw::c_char,
        nMaxLen: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_SendMessageToConnection(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
        pData: *const ::std::os::raw::c_void,
        cbData: uint32,
        nSendFlags: ::std::os::raw::c_int,
        pOutMessageNumber: *mut int64,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_SendMessages(
        self_: *mut ISteamNetworkingSockets,
        nMessages: ::std::os::raw::c_int,
        pMessages: *const *mut SteamNetworkingMessage_t,
        pOutMessageNumberOrResult: *mut int64,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_FlushMessagesOnConnection(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ReceiveMessagesOnConnection(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
        ppOutMessages: *mut *mut SteamNetworkingMessage_t,
        nMaxMessages: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetConnectionInfo(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
        pInfo: *mut SteamNetConnectionInfo_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetConnectionRealTimeStatus(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
        pStatus: *mut SteamNetConnectionRealTimeStatus_t,
        nLanes: ::std::os::raw::c_int,
        pLanes: *mut SteamNetConnectionRealTimeLaneStatus_t,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetDetailedConnectionStatus(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
        pszBuf: *mut ::std::os::raw::c_char,
        cbBuf: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetListenSocketAddress(
        self_: *mut ISteamNetworkingSockets,
        hSocket: HSteamListenSocket,
        address: *mut SteamNetworkingIPAddr,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_CreateSocketPair(
        self_: *mut ISteamNetworkingSockets,
        pOutConnection1: *mut HSteamNetConnection,
        pOutConnection2: *mut HSteamNetConnection,
        bUseNetworkLoopback: bool,
        pIdentity1: *const SteamNetworkingIdentity,
        pIdentity2: *const SteamNetworkingIdentity,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ConfigureConnectionLanes(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
        nNumLanes: ::std::os::raw::c_int,
        pLanePriorities: *const ::std::os::raw::c_int,
        pLaneWeights: *const uint16,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetIdentity(
        self_: *mut ISteamNetworkingSockets,
        pIdentity: *mut SteamNetworkingIdentity,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_InitAuthentication(
        self_: *mut ISteamNetworkingSockets,
    ) -> ESteamNetworkingAvailability;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetAuthenticationStatus(
        self_: *mut ISteamNetworkingSockets,
        pDetails: *mut SteamNetAuthenticationStatus_t,
    ) -> ESteamNetworkingAvailability;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_CreatePollGroup(
        self_: *mut ISteamNetworkingSockets,
    ) -> HSteamNetPollGroup;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_DestroyPollGroup(
        self_: *mut ISteamNetworkingSockets,
        hPollGroup: HSteamNetPollGroup,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_SetConnectionPollGroup(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
        hPollGroup: HSteamNetPollGroup,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ReceiveMessagesOnPollGroup(
        self_: *mut ISteamNetworkingSockets,
        hPollGroup: HSteamNetPollGroup,
        ppOutMessages: *mut *mut SteamNetworkingMessage_t,
        nMaxMessages: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ReceivedRelayAuthTicket(
        self_: *mut ISteamNetworkingSockets,
        pvTicket: *const ::std::os::raw::c_void,
        cbTicket: ::std::os::raw::c_int,
        pOutParsedTicket: *mut SteamDatagramRelayAuthTicket,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_FindRelayAuthTicketForServer(
        self_: *mut ISteamNetworkingSockets,
        identityGameServer: *const SteamNetworkingIdentity,
        nRemoteVirtualPort: ::std::os::raw::c_int,
        pOutParsedTicket: *mut SteamDatagramRelayAuthTicket,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ConnectToHostedDedicatedServer(
        self_: *mut ISteamNetworkingSockets,
        identityTarget: *const SteamNetworkingIdentity,
        nRemoteVirtualPort: ::std::os::raw::c_int,
        nOptions: ::std::os::raw::c_int,
        pOptions: *const SteamNetworkingConfigValue_t,
    ) -> HSteamNetConnection;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerPort(
        self_: *mut ISteamNetworkingSockets,
    ) -> uint16;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerPOPID(
        self_: *mut ISteamNetworkingSockets,
    ) -> SteamNetworkingPOPID;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerAddress(
        self_: *mut ISteamNetworkingSockets,
        pRouting: *mut SteamDatagramHostedAddress,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_CreateHostedDedicatedServerListenSocket(
        self_: *mut ISteamNetworkingSockets,
        nLocalVirtualPort: ::std::os::raw::c_int,
        nOptions: ::std::os::raw::c_int,
        pOptions: *const SteamNetworkingConfigValue_t,
    ) -> HSteamListenSocket;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetGameCoordinatorServerLogin(
        self_: *mut ISteamNetworkingSockets,
        pLoginInfo: *mut SteamDatagramGameCoordinatorServerLogin,
        pcbSignedBlob: *mut ::std::os::raw::c_int,
        pBlob: *mut ::std::os::raw::c_void,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ConnectP2PCustomSignaling(
        self_: *mut ISteamNetworkingSockets,
        pSignaling: *mut ISteamNetworkingConnectionSignaling,
        pPeerIdentity: *const SteamNetworkingIdentity,
        nRemoteVirtualPort: ::std::os::raw::c_int,
        nOptions: ::std::os::raw::c_int,
        pOptions: *const SteamNetworkingConfigValue_t,
    ) -> HSteamNetConnection;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ReceivedP2PCustomSignal(
        self_: *mut ISteamNetworkingSockets,
        pMsg: *const ::std::os::raw::c_void,
        cbMsg: ::std::os::raw::c_int,
        pContext: *mut ISteamNetworkingSignalingRecvContext,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetCertificateRequest(
        self_: *mut ISteamNetworkingSockets,
        pcbBlob: *mut ::std::os::raw::c_int,
        pBlob: *mut ::std::os::raw::c_void,
        errMsg: *mut SteamNetworkingErrMsg,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_SetCertificate(
        self_: *mut ISteamNetworkingSockets,
        pCertificate: *const ::std::os::raw::c_void,
        cbCertificate: ::std::os::raw::c_int,
        errMsg: *mut SteamNetworkingErrMsg,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ResetIdentity(
        self_: *mut ISteamNetworkingSockets,
        pIdentity: *const SteamNetworkingIdentity,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_RunCallbacks(self_: *mut ISteamNetworkingSockets);
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_BeginAsyncRequestFakeIP(
        self_: *mut ISteamNetworkingSockets,
        nNumPorts: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetFakeIP(
        self_: *mut ISteamNetworkingSockets,
        idxFirstPort: ::std::os::raw::c_int,
        pInfo: *mut SteamNetworkingFakeIPResult_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_CreateListenSocketP2PFakeIP(
        self_: *mut ISteamNetworkingSockets,
        idxFakePort: ::std::os::raw::c_int,
        nOptions: ::std::os::raw::c_int,
        pOptions: *const SteamNetworkingConfigValue_t,
    ) -> HSteamListenSocket;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetRemoteFakeIPForConnection(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
        pOutAddr: *mut SteamNetworkingIPAddr,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_CreateFakeUDPPort(
        self_: *mut ISteamNetworkingSockets,
        idxFakeServerPort: ::std::os::raw::c_int,
    ) -> *mut ISteamNetworkingFakeUDPPort;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingUtils_SteamAPI_v004() -> *mut ISteamNetworkingUtils;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_AllocateMessage(
        self_: *mut ISteamNetworkingUtils,
        cbAllocateBuffer: ::std::os::raw::c_int,
    ) -> *mut SteamNetworkingMessage_t;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_InitRelayNetworkAccess(self_: *mut ISteamNetworkingUtils);
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetRelayNetworkStatus(
        self_: *mut ISteamNetworkingUtils,
        pDetails: *mut SteamRelayNetworkStatus_t,
    ) -> ESteamNetworkingAvailability;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetLocalPingLocation(
        self_: *mut ISteamNetworkingUtils,
        result: *mut SteamNetworkPingLocation_t,
    ) -> f32;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_EstimatePingTimeBetweenTwoLocations(
        self_: *mut ISteamNetworkingUtils,
        location1: *const SteamNetworkPingLocation_t,
        location2: *const SteamNetworkPingLocation_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_EstimatePingTimeFromLocalHost(
        self_: *mut ISteamNetworkingUtils,
        remoteLocation: *const SteamNetworkPingLocation_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_ConvertPingLocationToString(
        self_: *mut ISteamNetworkingUtils,
        location: *const SteamNetworkPingLocation_t,
        pszBuf: *mut ::std::os::raw::c_char,
        cchBufSize: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_ParsePingLocationString(
        self_: *mut ISteamNetworkingUtils,
        pszString: *const ::std::os::raw::c_char,
        result: *mut SteamNetworkPingLocation_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_CheckPingDataUpToDate(
        self_: *mut ISteamNetworkingUtils,
        flMaxAgeSeconds: f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetPingToDataCenter(
        self_: *mut ISteamNetworkingUtils,
        popID: SteamNetworkingPOPID,
        pViaRelayPoP: *mut SteamNetworkingPOPID,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetDirectPingToPOP(
        self_: *mut ISteamNetworkingUtils,
        popID: SteamNetworkingPOPID,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetPOPCount(
        self_: *mut ISteamNetworkingUtils,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetPOPList(
        self_: *mut ISteamNetworkingUtils,
        list: *mut SteamNetworkingPOPID,
        nListSz: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetLocalTimestamp(
        self_: *mut ISteamNetworkingUtils,
    ) -> SteamNetworkingMicroseconds;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetDebugOutputFunction(
        self_: *mut ISteamNetworkingUtils,
        eDetailLevel: ESteamNetworkingSocketsDebugOutputType,
        pfnFunc: FSteamNetworkingSocketsDebugOutput,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_IsFakeIPv4(
        self_: *mut ISteamNetworkingUtils,
        nIPv4: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetIPv4FakeIPType(
        self_: *mut ISteamNetworkingUtils,
        nIPv4: uint32,
    ) -> ESteamNetworkingFakeIPType;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetRealIdentityForFakeIP(
        self_: *mut ISteamNetworkingUtils,
        fakeIP: *const SteamNetworkingIPAddr,
        pOutRealIdentity: *mut SteamNetworkingIdentity,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueInt32(
        self_: *mut ISteamNetworkingUtils,
        eValue: ESteamNetworkingConfigValue,
        val: int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueFloat(
        self_: *mut ISteamNetworkingUtils,
        eValue: ESteamNetworkingConfigValue,
        val: f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueString(
        self_: *mut ISteamNetworkingUtils,
        eValue: ESteamNetworkingConfigValue,
        val: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValuePtr(
        self_: *mut ISteamNetworkingUtils,
        eValue: ESteamNetworkingConfigValue,
        val: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueInt32(
        self_: *mut ISteamNetworkingUtils,
        hConn: HSteamNetConnection,
        eValue: ESteamNetworkingConfigValue,
        val: int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueFloat(
        self_: *mut ISteamNetworkingUtils,
        hConn: HSteamNetConnection,
        eValue: ESteamNetworkingConfigValue,
        val: f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueString(
        self_: *mut ISteamNetworkingUtils,
        hConn: HSteamNetConnection,
        eValue: ESteamNetworkingConfigValue,
        val: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamNetConnectionStatusChanged(
        self_: *mut ISteamNetworkingUtils,
        fnCallback: FnSteamNetConnectionStatusChanged,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamNetAuthenticationStatusChanged(
        self_: *mut ISteamNetworkingUtils,
        fnCallback: FnSteamNetAuthenticationStatusChanged,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamRelayNetworkStatusChanged(
        self_: *mut ISteamNetworkingUtils,
        fnCallback: FnSteamRelayNetworkStatusChanged,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_FakeIPResult(
        self_: *mut ISteamNetworkingUtils,
        fnCallback: FnSteamNetworkingFakeIPResult,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_MessagesSessionRequest(
        self_: *mut ISteamNetworkingUtils,
        fnCallback: FnSteamNetworkingMessagesSessionRequest,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_MessagesSessionFailed(
        self_: *mut ISteamNetworkingUtils,
        fnCallback: FnSteamNetworkingMessagesSessionFailed,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetConfigValue(
        self_: *mut ISteamNetworkingUtils,
        eValue: ESteamNetworkingConfigValue,
        eScopeType: ESteamNetworkingConfigScope,
        scopeObj: isize,
        eDataType: ESteamNetworkingConfigDataType,
        pArg: *const ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetConfigValueStruct(
        self_: *mut ISteamNetworkingUtils,
        opt: *const SteamNetworkingConfigValue_t,
        eScopeType: ESteamNetworkingConfigScope,
        scopeObj: isize,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetConfigValue(
        self_: *mut ISteamNetworkingUtils,
        eValue: ESteamNetworkingConfigValue,
        eScopeType: ESteamNetworkingConfigScope,
        scopeObj: isize,
        pOutDataType: *mut ESteamNetworkingConfigDataType,
        pResult: *mut ::std::os::raw::c_void,
        cbResult: *mut usize,
    ) -> ESteamNetworkingGetConfigValueResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetConfigValueInfo(
        self_: *mut ISteamNetworkingUtils,
        eValue: ESteamNetworkingConfigValue,
        pOutDataType: *mut ESteamNetworkingConfigDataType,
        pOutScope: *mut ESteamNetworkingConfigScope,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_IterateGenericEditableConfigValues(
        self_: *mut ISteamNetworkingUtils,
        eCurrent: ESteamNetworkingConfigValue,
        bEnumerateDevVars: bool,
    ) -> ESteamNetworkingConfigValue;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_ToString(
        self_: *mut ISteamNetworkingUtils,
        addr: *const SteamNetworkingIPAddr,
        buf: *mut ::std::os::raw::c_char,
        cbBuf: uint32,
        bWithPort: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_ParseString(
        self_: *mut ISteamNetworkingUtils,
        pAddr: *mut SteamNetworkingIPAddr,
        pszStr: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_GetFakeIPType(
        self_: *mut ISteamNetworkingUtils,
        addr: *const SteamNetworkingIPAddr,
    ) -> ESteamNetworkingFakeIPType;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SteamNetworkingIdentity_ToString(
        self_: *mut ISteamNetworkingUtils,
        identity: *const SteamNetworkingIdentity,
        buf: *mut ::std::os::raw::c_char,
        cbBuf: uint32,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SteamNetworkingIdentity_ParseString(
        self_: *mut ISteamNetworkingUtils,
        pIdentity: *mut SteamNetworkingIdentity,
        pszStr: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamGameServer_v015() -> *mut ISteamGameServer;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetProduct(
        self_: *mut ISteamGameServer,
        pszProduct: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetGameDescription(
        self_: *mut ISteamGameServer,
        pszGameDescription: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetModDir(
        self_: *mut ISteamGameServer,
        pszModDir: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetDedicatedServer(
        self_: *mut ISteamGameServer,
        bDedicated: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_LogOn(
        self_: *mut ISteamGameServer,
        pszToken: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_LogOnAnonymous(self_: *mut ISteamGameServer);
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_LogOff(self_: *mut ISteamGameServer);
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_BLoggedOn(self_: *mut ISteamGameServer) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_BSecure(self_: *mut ISteamGameServer) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_GetSteamID(self_: *mut ISteamGameServer) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_WasRestartRequested(self_: *mut ISteamGameServer) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetMaxPlayerCount(
        self_: *mut ISteamGameServer,
        cPlayersMax: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetBotPlayerCount(
        self_: *mut ISteamGameServer,
        cBotplayers: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetServerName(
        self_: *mut ISteamGameServer,
        pszServerName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetMapName(
        self_: *mut ISteamGameServer,
        pszMapName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetPasswordProtected(
        self_: *mut ISteamGameServer,
        bPasswordProtected: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetSpectatorPort(
        self_: *mut ISteamGameServer,
        unSpectatorPort: uint16,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetSpectatorServerName(
        self_: *mut ISteamGameServer,
        pszSpectatorServerName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_ClearAllKeyValues(self_: *mut ISteamGameServer);
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetKeyValue(
        self_: *mut ISteamGameServer,
        pKey: *const ::std::os::raw::c_char,
        pValue: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetGameTags(
        self_: *mut ISteamGameServer,
        pchGameTags: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetGameData(
        self_: *mut ISteamGameServer,
        pchGameData: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetRegion(
        self_: *mut ISteamGameServer,
        pszRegion: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetAdvertiseServerActive(
        self_: *mut ISteamGameServer,
        bActive: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_GetAuthSessionTicket(
        self_: *mut ISteamGameServer,
        pTicket: *mut ::std::os::raw::c_void,
        cbMaxTicket: ::std::os::raw::c_int,
        pcbTicket: *mut uint32,
        pSnid: *const SteamNetworkingIdentity,
    ) -> HAuthTicket;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_BeginAuthSession(
        self_: *mut ISteamGameServer,
        pAuthTicket: *const ::std::os::raw::c_void,
        cbAuthTicket: ::std::os::raw::c_int,
        steamID: uint64_steamid,
    ) -> EBeginAuthSessionResult;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_EndAuthSession(
        self_: *mut ISteamGameServer,
        steamID: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_CancelAuthTicket(
        self_: *mut ISteamGameServer,
        hAuthTicket: HAuthTicket,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_UserHasLicenseForApp(
        self_: *mut ISteamGameServer,
        steamID: uint64_steamid,
        appID: AppId_t,
    ) -> EUserHasLicenseForAppResult;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_RequestUserGroupStatus(
        self_: *mut ISteamGameServer,
        steamIDUser: uint64_steamid,
        steamIDGroup: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_GetGameplayStats(self_: *mut ISteamGameServer);
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_GetServerReputation(
        self_: *mut ISteamGameServer,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_GetPublicIP(self_: *mut ISteamGameServer) -> SteamIPAddress_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_HandleIncomingPacket(
        self_: *mut ISteamGameServer,
        pData: *const ::std::os::raw::c_void,
        cbData: ::std::os::raw::c_int,
        srcIP: uint32,
        srcPort: uint16,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_GetNextOutgoingPacket(
        self_: *mut ISteamGameServer,
        pOut: *mut ::std::os::raw::c_void,
        cbMaxOut: ::std::os::raw::c_int,
        pNetAdr: *mut uint32,
        pPort: *mut uint16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_AssociateWithClan(
        self_: *mut ISteamGameServer,
        steamIDClan: uint64_steamid,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_ComputeNewPlayerCompatibility(
        self_: *mut ISteamGameServer,
        steamIDNewPlayer: uint64_steamid,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SendUserConnectAndAuthenticate_DEPRECATED(
        self_: *mut ISteamGameServer,
        unIPClient: uint32,
        pvAuthBlob: *const ::std::os::raw::c_void,
        cubAuthBlobSize: uint32,
        pSteamIDUser: *mut CSteamID,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_CreateUnauthenticatedUserConnection(
        self_: *mut ISteamGameServer,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SendUserDisconnect_DEPRECATED(
        self_: *mut ISteamGameServer,
        steamIDUser: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_BUpdateUserData(
        self_: *mut ISteamGameServer,
        steamIDUser: uint64_steamid,
        pchPlayerName: *const ::std::os::raw::c_char,
        uScore: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamGameServerStats_v001() -> *mut ISteamGameServerStats;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServerStats_RequestUserStats(
        self_: *mut ISteamGameServerStats,
        steamIDUser: uint64_steamid,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServerStats_GetUserStatInt32(
        self_: *mut ISteamGameServerStats,
        steamIDUser: uint64_steamid,
        pchName: *const ::std::os::raw::c_char,
        pData: *mut int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServerStats_GetUserStatFloat(
        self_: *mut ISteamGameServerStats,
        steamIDUser: uint64_steamid,
        pchName: *const ::std::os::raw::c_char,
        pData: *mut f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServerStats_GetUserAchievement(
        self_: *mut ISteamGameServerStats,
        steamIDUser: uint64_steamid,
        pchName: *const ::std::os::raw::c_char,
        pbAchieved: *mut bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServerStats_SetUserStatInt32(
        self_: *mut ISteamGameServerStats,
        steamIDUser: uint64_steamid,
        pchName: *const ::std::os::raw::c_char,
        nData: int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServerStats_SetUserStatFloat(
        self_: *mut ISteamGameServerStats,
        steamIDUser: uint64_steamid,
        pchName: *const ::std::os::raw::c_char,
        fData: f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServerStats_UpdateUserAvgRateStat(
        self_: *mut ISteamGameServerStats,
        steamIDUser: uint64_steamid,
        pchName: *const ::std::os::raw::c_char,
        flCountThisSession: f32,
        dSessionLength: f64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServerStats_SetUserAchievement(
        self_: *mut ISteamGameServerStats,
        steamIDUser: uint64_steamid,
        pchName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServerStats_ClearUserAchievement(
        self_: *mut ISteamGameServerStats,
        steamIDUser: uint64_steamid,
        pchName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServerStats_StoreUserStats(
        self_: *mut ISteamGameServerStats,
        steamIDUser: uint64_steamid,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingFakeUDPPort_DestroyFakeUDPPort(
        self_: *mut ISteamNetworkingFakeUDPPort,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingFakeUDPPort_SendMessageToFakeIP(
        self_: *mut ISteamNetworkingFakeUDPPort,
        remoteAddress: *const SteamNetworkingIPAddr,
        pData: *const ::std::os::raw::c_void,
        cbData: uint32,
        nSendFlags: ::std::os::raw::c_int,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingFakeUDPPort_ReceiveMessages(
        self_: *mut ISteamNetworkingFakeUDPPort,
        ppOutMessages: *mut *mut SteamNetworkingMessage_t,
        nMaxMessages: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingFakeUDPPort_ScheduleCleanup(
        self_: *mut ISteamNetworkingFakeUDPPort,
        remoteAddress: *const SteamNetworkingIPAddr,
    );
}
extern "C" {
    pub fn SteamAPI_SteamIPAddress_t_IsSet(self_: *mut SteamIPAddress_t) -> bool;
}
extern "C" {
    pub fn SteamAPI_MatchMakingKeyValuePair_t_Construct(self_: *mut MatchMakingKeyValuePair_t);
}
extern "C" {
    pub fn SteamAPI_servernetadr_t_Construct(self_: *mut servernetadr_t);
}
extern "C" {
    pub fn SteamAPI_servernetadr_t_Init(
        self_: *mut servernetadr_t,
        ip: ::std::os::raw::c_uint,
        usQueryPort: uint16,
        usConnectionPort: uint16,
    );
}
extern "C" {
    pub fn SteamAPI_servernetadr_t_GetQueryPort(self_: *mut servernetadr_t) -> uint16;
}
extern "C" {
    pub fn SteamAPI_servernetadr_t_SetQueryPort(self_: *mut servernetadr_t, usPort: uint16);
}
extern "C" {
    pub fn SteamAPI_servernetadr_t_GetConnectionPort(self_: *mut servernetadr_t) -> uint16;
}
extern "C" {
    pub fn SteamAPI_servernetadr_t_SetConnectionPort(self_: *mut servernetadr_t, usPort: uint16);
}
extern "C" {
    pub fn SteamAPI_servernetadr_t_GetIP(self_: *mut servernetadr_t) -> uint32;
}
extern "C" {
    pub fn SteamAPI_servernetadr_t_SetIP(self_: *mut servernetadr_t, unIP: uint32);
}
extern "C" {
    pub fn SteamAPI_servernetadr_t_GetConnectionAddressString(
        self_: *mut servernetadr_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_servernetadr_t_GetQueryAddressString(
        self_: *mut servernetadr_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_servernetadr_t_IsLessThan(
        self_: *mut servernetadr_t,
        netadr: *const servernetadr_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_servernetadr_t_Assign(self_: *mut servernetadr_t, that: *const servernetadr_t);
}
extern "C" {
    pub fn SteamAPI_gameserveritem_t_Construct(self_: *mut gameserveritem_t);
}
extern "C" {
    pub fn SteamAPI_gameserveritem_t_GetName(
        self_: *mut gameserveritem_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_gameserveritem_t_SetName(
        self_: *mut gameserveritem_t,
        pName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_Clear(self_: *mut SteamNetworkingIPAddr);
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_IsIPv6AllZeros(self_: *mut SteamNetworkingIPAddr)
        -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_SetIPv6(
        self_: *mut SteamNetworkingIPAddr,
        ipv6: *const uint8,
        nPort: uint16,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_SetIPv4(
        self_: *mut SteamNetworkingIPAddr,
        nIP: uint32,
        nPort: uint16,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_IsIPv4(self_: *mut SteamNetworkingIPAddr) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_GetIPv4(self_: *mut SteamNetworkingIPAddr) -> uint32;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_SetIPv6LocalHost(
        self_: *mut SteamNetworkingIPAddr,
        nPort: uint16,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_IsLocalHost(self_: *mut SteamNetworkingIPAddr) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_ToString(
        self_: *mut SteamNetworkingIPAddr,
        buf: *mut ::std::os::raw::c_char,
        cbBuf: uint32,
        bWithPort: bool,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_ParseString(
        self_: *mut SteamNetworkingIPAddr,
        pszStr: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_IsEqualTo(
        self_: *mut SteamNetworkingIPAddr,
        x: *const SteamNetworkingIPAddr,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_GetFakeIPType(
        self_: *mut SteamNetworkingIPAddr,
    ) -> ESteamNetworkingFakeIPType;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_IsFakeIP(self_: *mut SteamNetworkingIPAddr) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_Clear(self_: *mut SteamNetworkingIdentity);
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_IsInvalid(self_: *mut SteamNetworkingIdentity) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_SetSteamID(
        self_: *mut SteamNetworkingIdentity,
        steamID: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_GetSteamID(
        self_: *mut SteamNetworkingIdentity,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_SetSteamID64(
        self_: *mut SteamNetworkingIdentity,
        steamID: uint64,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_GetSteamID64(
        self_: *mut SteamNetworkingIdentity,
    ) -> uint64;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_SetXboxPairwiseID(
        self_: *mut SteamNetworkingIdentity,
        pszString: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_GetXboxPairwiseID(
        self_: *mut SteamNetworkingIdentity,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_SetPSNID(
        self_: *mut SteamNetworkingIdentity,
        id: uint64,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_GetPSNID(self_: *mut SteamNetworkingIdentity)
        -> uint64;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_SetIPAddr(
        self_: *mut SteamNetworkingIdentity,
        addr: *const SteamNetworkingIPAddr,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_GetIPAddr(
        self_: *mut SteamNetworkingIdentity,
    ) -> *const SteamNetworkingIPAddr;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_SetIPv4Addr(
        self_: *mut SteamNetworkingIdentity,
        nIPv4: uint32,
        nPort: uint16,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_GetIPv4(self_: *mut SteamNetworkingIdentity) -> uint32;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_GetFakeIPType(
        self_: *mut SteamNetworkingIdentity,
    ) -> ESteamNetworkingFakeIPType;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_IsFakeIP(self_: *mut SteamNetworkingIdentity) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_SetLocalHost(self_: *mut SteamNetworkingIdentity);
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_IsLocalHost(
        self_: *mut SteamNetworkingIdentity,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_SetGenericString(
        self_: *mut SteamNetworkingIdentity,
        pszString: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_GetGenericString(
        self_: *mut SteamNetworkingIdentity,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_SetGenericBytes(
        self_: *mut SteamNetworkingIdentity,
        data: *const ::std::os::raw::c_void,
        cbLen: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_GetGenericBytes(
        self_: *mut SteamNetworkingIdentity,
        cbLen: *mut ::std::os::raw::c_int,
    ) -> *const uint8;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_IsEqualTo(
        self_: *mut SteamNetworkingIdentity,
        x: *const SteamNetworkingIdentity,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_ToString(
        self_: *mut SteamNetworkingIdentity,
        buf: *mut ::std::os::raw::c_char,
        cbBuf: uint32,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_ParseString(
        self_: *mut SteamNetworkingIdentity,
        pszStr: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingMessage_t_Release(self_: *mut SteamNetworkingMessage_t);
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingConfigValue_t_SetInt32(
        self_: *mut SteamNetworkingConfigValue_t,
        eVal: ESteamNetworkingConfigValue,
        data: i32,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingConfigValue_t_SetInt64(
        self_: *mut SteamNetworkingConfigValue_t,
        eVal: ESteamNetworkingConfigValue,
        data: i64,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingConfigValue_t_SetFloat(
        self_: *mut SteamNetworkingConfigValue_t,
        eVal: ESteamNetworkingConfigValue,
        data: f32,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingConfigValue_t_SetPtr(
        self_: *mut SteamNetworkingConfigValue_t,
        eVal: ESteamNetworkingConfigValue,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingConfigValue_t_SetString(
        self_: *mut SteamNetworkingConfigValue_t,
        eVal: ESteamNetworkingConfigValue,
        data: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_SteamDatagramHostedAddress_Clear(self_: *mut SteamDatagramHostedAddress);
}
extern "C" {
    pub fn SteamAPI_SteamDatagramHostedAddress_GetPopID(
        self_: *mut SteamDatagramHostedAddress,
    ) -> SteamNetworkingPOPID;
}
extern "C" {
    pub fn SteamAPI_SteamDatagramHostedAddress_SetDevAddress(
        self_: *mut SteamDatagramHostedAddress,
        nIP: uint32,
        nPort: uint16,
        popid: SteamNetworkingPOPID,
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EServerMode {
    eServerModeInvalid = 0,
    eServerModeNoAuthentication = 1,
    eServerModeAuthentication = 2,
    eServerModeAuthenticationAndSecure = 3,
}
#[doc = " Pass to SteamGameServer_Init to indicate that the same UDP port will be used for game traffic\n UDP queries for server browser pings and LAN discovery.  In this case, Steam will not open up a\n socket to handle server browser queries, and you must use ISteamGameServer::HandleIncomingPacket\n and ISteamGameServer::GetNextOutgoingPacket to handle packets related to server discovery on your socket."]
pub const STEAMGAMESERVER_QUERY_PORT_SHARED: uint16 = 65535;
extern "C" {
    pub fn SteamGameServer_Shutdown();
}
extern "C" {
    pub fn SteamGameServer_BSecure() -> bool;
}
extern "C" {
    pub fn SteamGameServer_GetSteamID() -> uint64;
}
extern "C" {
    pub fn SteamInternal_GameServer_Init_V2(
        unIP: uint32,
        usGamePort: uint16,
        usQueryPort: uint16,
        eServerMode: EServerMode,
        pchVersionString: *const ::std::os::raw::c_char,
        pszInternalCheckInterfaceVersions: *const ::std::os::raw::c_char,
        pOutErrMsg: *mut SteamErrMsg,
    ) -> ESteamAPIInitResult;
}
