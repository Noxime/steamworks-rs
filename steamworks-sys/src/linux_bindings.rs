/* automatically generated by rust-bindgen 0.69.5 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _STRING_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _ISOC95_SOURCE: u32 = 1;
pub const _ISOC99_SOURCE: u32 = 1;
pub const _ISOC11_SOURCE: u32 = 1;
pub const _ISOC2X_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _XOPEN_SOURCE: u32 = 700;
pub const _XOPEN_SOURCE_EXTENDED: u32 = 1;
pub const _LARGEFILE64_SOURCE: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const _DYNAMIC_STACK_SIZE_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_ISOCXX11: u32 = 1;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const __USE_XOPEN: u32 = 1;
pub const __USE_XOPEN_EXTENDED: u32 = 1;
pub const __USE_UNIX98: u32 = 1;
pub const _LARGEFILE_SOURCE: u32 = 1;
pub const __USE_XOPEN2K8XSI: u32 = 1;
pub const __USE_XOPEN2KXSI: u32 = 1;
pub const __USE_LARGEFILE: u32 = 1;
pub const __USE_LARGEFILE64: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_DYNAMIC_STACK_SIZE: u32 = 1;
pub const __USE_GNU: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 1;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 1;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 39;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 0;
pub const __GLIBC_USE_LIB_EXT2: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const STEAMCLIENT_INTERFACE_VERSION: &[u8; 15] = b"SteamClient021\0";
pub const STEAMUSER_INTERFACE_VERSION: &[u8; 13] = b"SteamUser023\0";
pub const STEAMFRIENDS_INTERFACE_VERSION: &[u8; 16] = b"SteamFriends018\0";
pub const STEAMUTILS_INTERFACE_VERSION: &[u8; 14] = b"SteamUtils010\0";
pub const _STDIO_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const __cookie_io_functions_t_defined: u32 = 1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_DATA: u32 = 3;
pub const SEEK_HOLE: u32 = 4;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const L_cuserid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _PRINTF_NAN_LEN_MAX: u32 = 4;
pub const RENAME_NOREPLACE: u32 = 1;
pub const RENAME_EXCHANGE: u32 = 2;
pub const RENAME_WHITEOUT: u32 = 4;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const k_nMaxLobbyKeyLength: u32 = 255;
pub const STEAMMATCHMAKING_INTERFACE_VERSION: &[u8; 20] = b"SteamMatchMaking009\0";
pub const STEAMMATCHMAKINGSERVERS_INTERFACE_VERSION: &[u8; 27] = b"SteamMatchMakingServers002\0";
pub const STEAMGAMESEARCH_INTERFACE_VERSION: &[u8; 24] = b"SteamMatchGameSearch001\0";
pub const STEAMPARTIES_INTERFACE_VERSION: &[u8; 16] = b"SteamParties002\0";
pub const STEAMREMOTESTORAGE_INTERFACE_VERSION: &[u8; 40] =
    b"STEAMREMOTESTORAGE_INTERFACE_VERSION016\0";
pub const STEAMUSERSTATS_INTERFACE_VERSION: &[u8; 36] = b"STEAMUSERSTATS_INTERFACE_VERSION013\0";
pub const STEAMAPPS_INTERFACE_VERSION: &[u8; 31] = b"STEAMAPPS_INTERFACE_VERSION008\0";
pub const STEAMNETWORKING_INTERFACE_VERSION: &[u8; 19] = b"SteamNetworking006\0";
pub const INVALID_SCREENSHOT_HANDLE: u32 = 0;
pub const STEAMSCREENSHOTS_INTERFACE_VERSION: &[u8; 38] =
    b"STEAMSCREENSHOTS_INTERFACE_VERSION003\0";
pub const STEAMMUSIC_INTERFACE_VERSION: &[u8; 32] = b"STEAMMUSIC_INTERFACE_VERSION001\0";
pub const k_SteamMusicNameMaxLength: u32 = 255;
pub const k_SteamMusicPNGMaxLength: u32 = 65535;
pub const STEAMMUSICREMOTE_INTERFACE_VERSION: &[u8; 38] =
    b"STEAMMUSICREMOTE_INTERFACE_VERSION001\0";
pub const INVALID_HTTPREQUEST_HANDLE: u32 = 0;
pub const INVALID_HTTPCOOKIE_HANDLE: u32 = 0;
pub const STEAMHTTP_INTERFACE_VERSION: &[u8; 31] = b"STEAMHTTP_INTERFACE_VERSION003\0";
pub const STEAM_INPUT_MAX_COUNT: u32 = 16;
pub const STEAM_INPUT_MAX_ANALOG_ACTIONS: u32 = 24;
pub const STEAM_INPUT_MAX_DIGITAL_ACTIONS: u32 = 256;
pub const STEAM_INPUT_MAX_ORIGINS: u32 = 8;
pub const STEAM_INPUT_MAX_ACTIVE_LAYERS: u32 = 16;
pub const STEAM_INPUT_MIN_ANALOG_ACTION_DATA: f64 = -1.0;
pub const STEAM_INPUT_MAX_ANALOG_ACTION_DATA: f64 = 1.0;
pub const STEAMINPUT_INTERFACE_VERSION: &[u8; 14] = b"SteamInput006\0";
pub const STEAM_CONTROLLER_MAX_COUNT: u32 = 16;
pub const STEAM_CONTROLLER_MAX_ANALOG_ACTIONS: u32 = 24;
pub const STEAM_CONTROLLER_MAX_DIGITAL_ACTIONS: u32 = 256;
pub const STEAM_CONTROLLER_MAX_ORIGINS: u32 = 8;
pub const STEAM_CONTROLLER_MAX_ACTIVE_LAYERS: u32 = 16;
pub const STEAM_CONTROLLER_MIN_ANALOG_ACTION_DATA: f64 = -1.0;
pub const STEAM_CONTROLLER_MAX_ANALOG_ACTION_DATA: f64 = 1.0;
pub const STEAMCONTROLLER_INTERFACE_VERSION: &[u8; 19] = b"SteamController008\0";
pub const STEAMUGC_INTERFACE_VERSION: &[u8; 30] = b"STEAMUGC_INTERFACE_VERSION021\0";
pub const STEAMHTMLSURFACE_INTERFACE_VERSION: &[u8; 39] =
    b"STEAMHTMLSURFACE_INTERFACE_VERSION_005\0";
pub const STEAMINVENTORY_INTERFACE_VERSION: &[u8; 30] = b"STEAMINVENTORY_INTERFACE_V003\0";
pub const STEAMTIMELINE_INTERFACE_VERSION: &[u8; 29] = b"STEAMTIMELINE_INTERFACE_V004\0";
pub const STEAMVIDEO_INTERFACE_VERSION: &[u8; 26] = b"STEAMVIDEO_INTERFACE_V007\0";
pub const STEAMPARENTALSETTINGS_INTERFACE_VERSION: &[u8; 43] =
    b"STEAMPARENTALSETTINGS_INTERFACE_VERSION001\0";
pub const STEAMREMOTEPLAY_INTERFACE_VERSION: &[u8; 37] = b"STEAMREMOTEPLAY_INTERFACE_VERSION003\0";
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const INT8_WIDTH: u32 = 8;
pub const UINT8_WIDTH: u32 = 8;
pub const INT16_WIDTH: u32 = 16;
pub const UINT16_WIDTH: u32 = 16;
pub const INT32_WIDTH: u32 = 32;
pub const UINT32_WIDTH: u32 = 32;
pub const INT64_WIDTH: u32 = 64;
pub const UINT64_WIDTH: u32 = 64;
pub const INT_LEAST8_WIDTH: u32 = 8;
pub const UINT_LEAST8_WIDTH: u32 = 8;
pub const INT_LEAST16_WIDTH: u32 = 16;
pub const UINT_LEAST16_WIDTH: u32 = 16;
pub const INT_LEAST32_WIDTH: u32 = 32;
pub const UINT_LEAST32_WIDTH: u32 = 32;
pub const INT_LEAST64_WIDTH: u32 = 64;
pub const UINT_LEAST64_WIDTH: u32 = 64;
pub const INT_FAST8_WIDTH: u32 = 8;
pub const UINT_FAST8_WIDTH: u32 = 8;
pub const INT_FAST16_WIDTH: u32 = 64;
pub const UINT_FAST16_WIDTH: u32 = 64;
pub const INT_FAST32_WIDTH: u32 = 64;
pub const UINT_FAST32_WIDTH: u32 = 64;
pub const INT_FAST64_WIDTH: u32 = 64;
pub const UINT_FAST64_WIDTH: u32 = 64;
pub const INTPTR_WIDTH: u32 = 64;
pub const UINTPTR_WIDTH: u32 = 64;
pub const INTMAX_WIDTH: u32 = 64;
pub const UINTMAX_WIDTH: u32 = 64;
pub const PTRDIFF_WIDTH: u32 = 64;
pub const SIG_ATOMIC_WIDTH: u32 = 32;
pub const SIZE_WIDTH: u32 = 64;
pub const WCHAR_WIDTH: u32 = 32;
pub const WINT_WIDTH: u32 = 32;
pub const STEAMNETWORKINGMESSAGES_INTERFACE_VERSION: &[u8; 27] = b"SteamNetworkingMessages002\0";
pub const STEAMNETWORKINGSOCKETS_INTERFACE_VERSION: &[u8; 26] = b"SteamNetworkingSockets012\0";
pub const STEAMNETWORKINGUTILS_INTERFACE_VERSION: &[u8; 24] = b"SteamNetworkingUtils004\0";
pub const STEAMGAMESERVER_INTERFACE_VERSION: &[u8; 19] = b"SteamGameServer015\0";
pub const STEAMGAMESERVERSTATS_INTERFACE_VERSION: &[u8; 24] = b"SteamGameServerStats001\0";
pub type uint8 = ::std::os::raw::c_uchar;
pub type int8 = ::std::os::raw::c_schar;
pub type int16 = ::std::os::raw::c_short;
pub type uint16 = ::std::os::raw::c_ushort;
pub type int32 = ::std::os::raw::c_int;
pub type uint32 = ::std::os::raw::c_uint;
pub type int64 = ::std::os::raw::c_longlong;
pub type uint64 = ::std::os::raw::c_ulonglong;
pub type lint64 = ::std::os::raw::c_long;
pub type ulint64 = ::std::os::raw::c_ulong;
pub type intp = ::std::os::raw::c_longlong;
pub type uintp = ::std::os::raw::c_ulonglong;
pub type AppId_t = uint32;
pub const k_uAppIdInvalid: AppId_t = 0;
pub type DepotId_t = uint32;
pub const k_uDepotIdInvalid: DepotId_t = 0;
pub type RTime32 = uint32;
pub type SteamAPICall_t = uint64;
pub const k_uAPICallInvalid: SteamAPICall_t = 0;
pub type AccountID_t = uint32;
pub const k_uAccountIdInvalid: AccountID_t = 0;
pub type PartyBeaconID_t = uint64;
pub const k_ulPartyBeaconIdInvalid: PartyBeaconID_t = 0;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamIPType {
    k_ESteamIPTypeIPv4 = 0,
    k_ESteamIPTypeIPv6 = 1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct SteamIPAddress_t {
    pub __bindgen_anon_1: SteamIPAddress_t__bindgen_ty_1,
    pub m_eType: ESteamIPType,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union SteamIPAddress_t__bindgen_ty_1 {
    pub m_unIPv4: uint32,
    pub m_rgubIPv6: [uint8; 16usize],
    pub m_ipv6Qword: [uint64; 2usize],
}
#[test]
fn bindgen_test_layout_SteamIPAddress_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<SteamIPAddress_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamIPAddress_t__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(SteamIPAddress_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamIPAddress_t__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamIPAddress_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unIPv4) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamIPAddress_t__bindgen_ty_1),
            "::",
            stringify!(m_unIPv4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgubIPv6) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamIPAddress_t__bindgen_ty_1),
            "::",
            stringify!(m_rgubIPv6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ipv6Qword) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamIPAddress_t__bindgen_ty_1),
            "::",
            stringify!(m_ipv6Qword)
        )
    );
}
#[test]
fn bindgen_test_layout_SteamIPAddress_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamIPAddress_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamIPAddress_t>(),
        20usize,
        concat!("Size of: ", stringify!(SteamIPAddress_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamIPAddress_t>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamIPAddress_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamIPAddress_t),
            "::",
            stringify!(m_eType)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EUniverse {
    k_EUniverseInvalid = 0,
    k_EUniversePublic = 1,
    k_EUniverseBeta = 2,
    k_EUniverseInternal = 3,
    k_EUniverseDev = 4,
    k_EUniverseMax = 5,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EResult {
    k_EResultNone = 0,
    k_EResultOK = 1,
    k_EResultFail = 2,
    k_EResultNoConnection = 3,
    k_EResultInvalidPassword = 5,
    k_EResultLoggedInElsewhere = 6,
    k_EResultInvalidProtocolVer = 7,
    k_EResultInvalidParam = 8,
    k_EResultFileNotFound = 9,
    k_EResultBusy = 10,
    k_EResultInvalidState = 11,
    k_EResultInvalidName = 12,
    k_EResultInvalidEmail = 13,
    k_EResultDuplicateName = 14,
    k_EResultAccessDenied = 15,
    k_EResultTimeout = 16,
    k_EResultBanned = 17,
    k_EResultAccountNotFound = 18,
    k_EResultInvalidSteamID = 19,
    k_EResultServiceUnavailable = 20,
    k_EResultNotLoggedOn = 21,
    k_EResultPending = 22,
    k_EResultEncryptionFailure = 23,
    k_EResultInsufficientPrivilege = 24,
    k_EResultLimitExceeded = 25,
    k_EResultRevoked = 26,
    k_EResultExpired = 27,
    k_EResultAlreadyRedeemed = 28,
    k_EResultDuplicateRequest = 29,
    k_EResultAlreadyOwned = 30,
    k_EResultIPNotFound = 31,
    k_EResultPersistFailed = 32,
    k_EResultLockingFailed = 33,
    k_EResultLogonSessionReplaced = 34,
    k_EResultConnectFailed = 35,
    k_EResultHandshakeFailed = 36,
    k_EResultIOFailure = 37,
    k_EResultRemoteDisconnect = 38,
    k_EResultShoppingCartNotFound = 39,
    k_EResultBlocked = 40,
    k_EResultIgnored = 41,
    k_EResultNoMatch = 42,
    k_EResultAccountDisabled = 43,
    k_EResultServiceReadOnly = 44,
    k_EResultAccountNotFeatured = 45,
    k_EResultAdministratorOK = 46,
    k_EResultContentVersion = 47,
    k_EResultTryAnotherCM = 48,
    k_EResultPasswordRequiredToKickSession = 49,
    k_EResultAlreadyLoggedInElsewhere = 50,
    k_EResultSuspended = 51,
    k_EResultCancelled = 52,
    k_EResultDataCorruption = 53,
    k_EResultDiskFull = 54,
    k_EResultRemoteCallFailed = 55,
    k_EResultPasswordUnset = 56,
    k_EResultExternalAccountUnlinked = 57,
    k_EResultPSNTicketInvalid = 58,
    k_EResultExternalAccountAlreadyLinked = 59,
    k_EResultRemoteFileConflict = 60,
    k_EResultIllegalPassword = 61,
    k_EResultSameAsPreviousValue = 62,
    k_EResultAccountLogonDenied = 63,
    k_EResultCannotUseOldPassword = 64,
    k_EResultInvalidLoginAuthCode = 65,
    k_EResultAccountLogonDeniedNoMail = 66,
    k_EResultHardwareNotCapableOfIPT = 67,
    k_EResultIPTInitError = 68,
    k_EResultParentalControlRestricted = 69,
    k_EResultFacebookQueryError = 70,
    k_EResultExpiredLoginAuthCode = 71,
    k_EResultIPLoginRestrictionFailed = 72,
    k_EResultAccountLockedDown = 73,
    k_EResultAccountLogonDeniedVerifiedEmailRequired = 74,
    k_EResultNoMatchingURL = 75,
    k_EResultBadResponse = 76,
    k_EResultRequirePasswordReEntry = 77,
    k_EResultValueOutOfRange = 78,
    k_EResultUnexpectedError = 79,
    k_EResultDisabled = 80,
    k_EResultInvalidCEGSubmission = 81,
    k_EResultRestrictedDevice = 82,
    k_EResultRegionLocked = 83,
    k_EResultRateLimitExceeded = 84,
    k_EResultAccountLoginDeniedNeedTwoFactor = 85,
    k_EResultItemDeleted = 86,
    k_EResultAccountLoginDeniedThrottle = 87,
    k_EResultTwoFactorCodeMismatch = 88,
    k_EResultTwoFactorActivationCodeMismatch = 89,
    k_EResultAccountAssociatedToMultiplePartners = 90,
    k_EResultNotModified = 91,
    k_EResultNoMobileDevice = 92,
    k_EResultTimeNotSynced = 93,
    k_EResultSmsCodeFailed = 94,
    k_EResultAccountLimitExceeded = 95,
    k_EResultAccountActivityLimitExceeded = 96,
    k_EResultPhoneActivityLimitExceeded = 97,
    k_EResultRefundToWallet = 98,
    k_EResultEmailSendFailure = 99,
    k_EResultNotSettled = 100,
    k_EResultNeedCaptcha = 101,
    k_EResultGSLTDenied = 102,
    k_EResultGSOwnerDenied = 103,
    k_EResultInvalidItemType = 104,
    k_EResultIPBanned = 105,
    k_EResultGSLTExpired = 106,
    k_EResultInsufficientFunds = 107,
    k_EResultTooManyPending = 108,
    k_EResultNoSiteLicensesFound = 109,
    k_EResultWGNetworkSendExceeded = 110,
    k_EResultAccountNotFriends = 111,
    k_EResultLimitedUserAccount = 112,
    k_EResultCantRemoveItem = 113,
    k_EResultAccountDeleted = 114,
    k_EResultExistingUserCancelledLicense = 115,
    k_EResultCommunityCooldown = 116,
    k_EResultNoLauncherSpecified = 117,
    k_EResultMustAgreeToSSA = 118,
    k_EResultLauncherMigrated = 119,
    k_EResultSteamRealmMismatch = 120,
    k_EResultInvalidSignature = 121,
    k_EResultParseFailure = 122,
    k_EResultNoVerifiedPhone = 123,
    k_EResultInsufficientBattery = 124,
    k_EResultChargerRequired = 125,
    k_EResultCachedCredentialInvalid = 126,
    K_EResultPhoneNumberIsVOIP = 127,
    k_EResultNotSupported = 128,
    k_EResultFamilySizeLimitExceeded = 129,
    k_EResultOfflineAppCacheInvalid = 130,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EVoiceResult {
    k_EVoiceResultOK = 0,
    k_EVoiceResultNotInitialized = 1,
    k_EVoiceResultNotRecording = 2,
    k_EVoiceResultNoData = 3,
    k_EVoiceResultBufferTooSmall = 4,
    k_EVoiceResultDataCorrupted = 5,
    k_EVoiceResultRestricted = 6,
    k_EVoiceResultUnsupportedCodec = 7,
    k_EVoiceResultReceiverOutOfDate = 8,
    k_EVoiceResultReceiverDidNotAnswer = 9,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EDenyReason {
    k_EDenyInvalid = 0,
    k_EDenyInvalidVersion = 1,
    k_EDenyGeneric = 2,
    k_EDenyNotLoggedOn = 3,
    k_EDenyNoLicense = 4,
    k_EDenyCheater = 5,
    k_EDenyLoggedInElseWhere = 6,
    k_EDenyUnknownText = 7,
    k_EDenyIncompatibleAnticheat = 8,
    k_EDenyMemoryCorruption = 9,
    k_EDenyIncompatibleSoftware = 10,
    k_EDenySteamConnectionLost = 11,
    k_EDenySteamConnectionError = 12,
    k_EDenySteamResponseTimedOut = 13,
    k_EDenySteamValidationStalled = 14,
    k_EDenySteamOwnerLeftGuestUser = 15,
}
pub type HAuthTicket = uint32;
pub const k_HAuthTicketInvalid: HAuthTicket = 0;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EBeginAuthSessionResult {
    k_EBeginAuthSessionResultOK = 0,
    k_EBeginAuthSessionResultInvalidTicket = 1,
    k_EBeginAuthSessionResultDuplicateRequest = 2,
    k_EBeginAuthSessionResultInvalidVersion = 3,
    k_EBeginAuthSessionResultGameMismatch = 4,
    k_EBeginAuthSessionResultExpiredTicket = 5,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EAuthSessionResponse {
    k_EAuthSessionResponseOK = 0,
    k_EAuthSessionResponseUserNotConnectedToSteam = 1,
    k_EAuthSessionResponseNoLicenseOrExpired = 2,
    k_EAuthSessionResponseVACBanned = 3,
    k_EAuthSessionResponseLoggedInElseWhere = 4,
    k_EAuthSessionResponseVACCheckTimedOut = 5,
    k_EAuthSessionResponseAuthTicketCanceled = 6,
    k_EAuthSessionResponseAuthTicketInvalidAlreadyUsed = 7,
    k_EAuthSessionResponseAuthTicketInvalid = 8,
    k_EAuthSessionResponsePublisherIssuedBan = 9,
    k_EAuthSessionResponseAuthTicketNetworkIdentityFailure = 10,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EUserHasLicenseForAppResult {
    k_EUserHasLicenseResultHasLicense = 0,
    k_EUserHasLicenseResultDoesNotHaveLicense = 1,
    k_EUserHasLicenseResultNoAuth = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EAccountType {
    k_EAccountTypeInvalid = 0,
    k_EAccountTypeIndividual = 1,
    k_EAccountTypeMultiseat = 2,
    k_EAccountTypeGameServer = 3,
    k_EAccountTypeAnonGameServer = 4,
    k_EAccountTypePending = 5,
    k_EAccountTypeContentServer = 6,
    k_EAccountTypeClan = 7,
    k_EAccountTypeChat = 8,
    k_EAccountTypeConsoleUser = 9,
    k_EAccountTypeAnonUser = 10,
    k_EAccountTypeMax = 11,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EChatEntryType {
    k_EChatEntryTypeInvalid = 0,
    k_EChatEntryTypeChatMsg = 1,
    k_EChatEntryTypeTyping = 2,
    k_EChatEntryTypeInviteGame = 3,
    k_EChatEntryTypeEmote = 4,
    k_EChatEntryTypeLeftConversation = 6,
    k_EChatEntryTypeEntered = 7,
    k_EChatEntryTypeWasKicked = 8,
    k_EChatEntryTypeWasBanned = 9,
    k_EChatEntryTypeDisconnected = 10,
    k_EChatEntryTypeHistoricalChat = 11,
    k_EChatEntryTypeLinkBlocked = 14,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EChatRoomEnterResponse {
    k_EChatRoomEnterResponseSuccess = 1,
    k_EChatRoomEnterResponseDoesntExist = 2,
    k_EChatRoomEnterResponseNotAllowed = 3,
    k_EChatRoomEnterResponseFull = 4,
    k_EChatRoomEnterResponseError = 5,
    k_EChatRoomEnterResponseBanned = 6,
    k_EChatRoomEnterResponseLimited = 7,
    k_EChatRoomEnterResponseClanDisabled = 8,
    k_EChatRoomEnterResponseCommunityBan = 9,
    k_EChatRoomEnterResponseMemberBlockedYou = 10,
    k_EChatRoomEnterResponseYouBlockedMember = 11,
    k_EChatRoomEnterResponseRatelimitExceeded = 15,
}
pub const k_unSteamAccountIDMask: ::std::os::raw::c_uint = 4294967295;
pub const k_unSteamAccountInstanceMask: ::std::os::raw::c_uint = 1048575;
pub const k_unSteamUserDefaultInstance: ::std::os::raw::c_uint = 1;
impl EChatSteamIDInstanceFlags {
    pub const k_EChatAccountInstanceMask: EChatSteamIDInstanceFlags =
        EChatSteamIDInstanceFlags(4095);
}
impl EChatSteamIDInstanceFlags {
    pub const k_EChatInstanceFlagClan: EChatSteamIDInstanceFlags =
        EChatSteamIDInstanceFlags(524288);
}
impl EChatSteamIDInstanceFlags {
    pub const k_EChatInstanceFlagLobby: EChatSteamIDInstanceFlags =
        EChatSteamIDInstanceFlags(262144);
}
impl EChatSteamIDInstanceFlags {
    pub const k_EChatInstanceFlagMMSLobby: EChatSteamIDInstanceFlags =
        EChatSteamIDInstanceFlags(131072);
}
impl ::std::ops::BitOr<EChatSteamIDInstanceFlags> for EChatSteamIDInstanceFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        EChatSteamIDInstanceFlags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for EChatSteamIDInstanceFlags {
    #[inline]
    fn bitor_assign(&mut self, rhs: EChatSteamIDInstanceFlags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<EChatSteamIDInstanceFlags> for EChatSteamIDInstanceFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        EChatSteamIDInstanceFlags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for EChatSteamIDInstanceFlags {
    #[inline]
    fn bitand_assign(&mut self, rhs: EChatSteamIDInstanceFlags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct EChatSteamIDInstanceFlags(pub ::std::os::raw::c_uint);
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ENotificationPosition {
    k_EPositionInvalid = -1,
    k_EPositionTopLeft = 0,
    k_EPositionTopRight = 1,
    k_EPositionBottomLeft = 2,
    k_EPositionBottomRight = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EBroadcastUploadResult {
    k_EBroadcastUploadResultNone = 0,
    k_EBroadcastUploadResultOK = 1,
    k_EBroadcastUploadResultInitFailed = 2,
    k_EBroadcastUploadResultFrameFailed = 3,
    k_EBroadcastUploadResultTimeout = 4,
    k_EBroadcastUploadResultBandwidthExceeded = 5,
    k_EBroadcastUploadResultLowFPS = 6,
    k_EBroadcastUploadResultMissingKeyFrames = 7,
    k_EBroadcastUploadResultNoConnection = 8,
    k_EBroadcastUploadResultRelayFailed = 9,
    k_EBroadcastUploadResultSettingsChanged = 10,
    k_EBroadcastUploadResultMissingAudio = 11,
    k_EBroadcastUploadResultTooFarBehind = 12,
    k_EBroadcastUploadResultTranscodeBehind = 13,
    k_EBroadcastUploadResultNotAllowedToPlay = 14,
    k_EBroadcastUploadResultBusy = 15,
    k_EBroadcastUploadResultBanned = 16,
    k_EBroadcastUploadResultAlreadyActive = 17,
    k_EBroadcastUploadResultForcedOff = 18,
    k_EBroadcastUploadResultAudioBehind = 19,
    k_EBroadcastUploadResultShutdown = 20,
    k_EBroadcastUploadResultDisconnect = 21,
    k_EBroadcastUploadResultVideoInitFailed = 22,
    k_EBroadcastUploadResultAudioInitFailed = 23,
}
impl EMarketNotAllowedReasonFlags {
    pub const k_EMarketNotAllowedReason_None: EMarketNotAllowedReasonFlags =
        EMarketNotAllowedReasonFlags(0);
}
impl EMarketNotAllowedReasonFlags {
    pub const k_EMarketNotAllowedReason_TemporaryFailure: EMarketNotAllowedReasonFlags =
        EMarketNotAllowedReasonFlags(1);
}
impl EMarketNotAllowedReasonFlags {
    pub const k_EMarketNotAllowedReason_AccountDisabled: EMarketNotAllowedReasonFlags =
        EMarketNotAllowedReasonFlags(2);
}
impl EMarketNotAllowedReasonFlags {
    pub const k_EMarketNotAllowedReason_AccountLockedDown: EMarketNotAllowedReasonFlags =
        EMarketNotAllowedReasonFlags(4);
}
impl EMarketNotAllowedReasonFlags {
    pub const k_EMarketNotAllowedReason_AccountLimited: EMarketNotAllowedReasonFlags =
        EMarketNotAllowedReasonFlags(8);
}
impl EMarketNotAllowedReasonFlags {
    pub const k_EMarketNotAllowedReason_TradeBanned: EMarketNotAllowedReasonFlags =
        EMarketNotAllowedReasonFlags(16);
}
impl EMarketNotAllowedReasonFlags {
    pub const k_EMarketNotAllowedReason_AccountNotTrusted: EMarketNotAllowedReasonFlags =
        EMarketNotAllowedReasonFlags(32);
}
impl EMarketNotAllowedReasonFlags {
    pub const k_EMarketNotAllowedReason_SteamGuardNotEnabled: EMarketNotAllowedReasonFlags =
        EMarketNotAllowedReasonFlags(64);
}
impl EMarketNotAllowedReasonFlags {
    pub const k_EMarketNotAllowedReason_SteamGuardOnlyRecentlyEnabled:
        EMarketNotAllowedReasonFlags = EMarketNotAllowedReasonFlags(128);
}
impl EMarketNotAllowedReasonFlags {
    pub const k_EMarketNotAllowedReason_RecentPasswordReset: EMarketNotAllowedReasonFlags =
        EMarketNotAllowedReasonFlags(256);
}
impl EMarketNotAllowedReasonFlags {
    pub const k_EMarketNotAllowedReason_NewPaymentMethod: EMarketNotAllowedReasonFlags =
        EMarketNotAllowedReasonFlags(512);
}
impl EMarketNotAllowedReasonFlags {
    pub const k_EMarketNotAllowedReason_InvalidCookie: EMarketNotAllowedReasonFlags =
        EMarketNotAllowedReasonFlags(1024);
}
impl EMarketNotAllowedReasonFlags {
    pub const k_EMarketNotAllowedReason_UsingNewDevice: EMarketNotAllowedReasonFlags =
        EMarketNotAllowedReasonFlags(2048);
}
impl EMarketNotAllowedReasonFlags {
    pub const k_EMarketNotAllowedReason_RecentSelfRefund: EMarketNotAllowedReasonFlags =
        EMarketNotAllowedReasonFlags(4096);
}
impl EMarketNotAllowedReasonFlags {
    pub const k_EMarketNotAllowedReason_NewPaymentMethodCannotBeVerified:
        EMarketNotAllowedReasonFlags = EMarketNotAllowedReasonFlags(8192);
}
impl EMarketNotAllowedReasonFlags {
    pub const k_EMarketNotAllowedReason_NoRecentPurchases: EMarketNotAllowedReasonFlags =
        EMarketNotAllowedReasonFlags(16384);
}
impl EMarketNotAllowedReasonFlags {
    pub const k_EMarketNotAllowedReason_AcceptedWalletGift: EMarketNotAllowedReasonFlags =
        EMarketNotAllowedReasonFlags(32768);
}
impl ::std::ops::BitOr<EMarketNotAllowedReasonFlags> for EMarketNotAllowedReasonFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        EMarketNotAllowedReasonFlags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for EMarketNotAllowedReasonFlags {
    #[inline]
    fn bitor_assign(&mut self, rhs: EMarketNotAllowedReasonFlags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<EMarketNotAllowedReasonFlags> for EMarketNotAllowedReasonFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        EMarketNotAllowedReasonFlags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for EMarketNotAllowedReasonFlags {
    #[inline]
    fn bitand_assign(&mut self, rhs: EMarketNotAllowedReasonFlags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct EMarketNotAllowedReasonFlags(pub ::std::os::raw::c_uint);
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EDurationControlProgress {
    k_EDurationControlProgress_Full = 0,
    k_EDurationControlProgress_Half = 1,
    k_EDurationControlProgress_None = 2,
    k_EDurationControl_ExitSoon_3h = 3,
    k_EDurationControl_ExitSoon_5h = 4,
    k_EDurationControl_ExitSoon_Night = 5,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EDurationControlNotification {
    k_EDurationControlNotification_None = 0,
    k_EDurationControlNotification_1Hour = 1,
    k_EDurationControlNotification_3Hours = 2,
    k_EDurationControlNotification_HalfProgress = 3,
    k_EDurationControlNotification_NoProgress = 4,
    k_EDurationControlNotification_ExitSoon_3h = 5,
    k_EDurationControlNotification_ExitSoon_5h = 6,
    k_EDurationControlNotification_ExitSoon_Night = 7,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EDurationControlOnlineState {
    k_EDurationControlOnlineState_Invalid = 0,
    k_EDurationControlOnlineState_Offline = 1,
    k_EDurationControlOnlineState_Online = 2,
    k_EDurationControlOnlineState_OnlineHighPri = 3,
}
impl EBetaBranchFlags {
    pub const k_EBetaBranch_None: EBetaBranchFlags = EBetaBranchFlags(0);
}
impl EBetaBranchFlags {
    pub const k_EBetaBranch_Default: EBetaBranchFlags = EBetaBranchFlags(1);
}
impl EBetaBranchFlags {
    pub const k_EBetaBranch_Available: EBetaBranchFlags = EBetaBranchFlags(2);
}
impl EBetaBranchFlags {
    pub const k_EBetaBranch_Private: EBetaBranchFlags = EBetaBranchFlags(4);
}
impl EBetaBranchFlags {
    pub const k_EBetaBranch_Selected: EBetaBranchFlags = EBetaBranchFlags(8);
}
impl EBetaBranchFlags {
    pub const k_EBetaBranch_Installed: EBetaBranchFlags = EBetaBranchFlags(16);
}
impl ::std::ops::BitOr<EBetaBranchFlags> for EBetaBranchFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        EBetaBranchFlags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for EBetaBranchFlags {
    #[inline]
    fn bitor_assign(&mut self, rhs: EBetaBranchFlags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<EBetaBranchFlags> for EBetaBranchFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        EBetaBranchFlags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for EBetaBranchFlags {
    #[inline]
    fn bitand_assign(&mut self, rhs: EBetaBranchFlags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct EBetaBranchFlags(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CSteamID {
    pub m_steamid: CSteamID_SteamID_t,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union CSteamID_SteamID_t {
    pub m_comp: CSteamID_SteamID_t_SteamIDComponent_t,
    pub m_unAll64Bits: uint64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CSteamID_SteamID_t_SteamIDComponent_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_CSteamID_SteamID_t_SteamIDComponent_t() {
    assert_eq!(
        ::std::mem::size_of::<CSteamID_SteamID_t_SteamIDComponent_t>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CSteamID_SteamID_t_SteamIDComponent_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CSteamID_SteamID_t_SteamIDComponent_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(CSteamID_SteamID_t_SteamIDComponent_t)
        )
    );
}
impl CSteamID_SteamID_t_SteamIDComponent_t {
    #[inline]
    pub fn m_unAccountID(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_m_unAccountID(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn m_unAccountInstance(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_m_unAccountInstance(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn m_EAccountType(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_m_EAccountType(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn m_EUniverse(&self) -> EUniverse {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_m_EUniverse(&mut self, val: EUniverse) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        m_unAccountID: uint32,
        m_unAccountInstance: ::std::os::raw::c_uint,
        m_EAccountType: ::std::os::raw::c_uint,
        m_EUniverse: EUniverse,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let m_unAccountID: u32 = unsafe { ::std::mem::transmute(m_unAccountID) };
            m_unAccountID as u64
        });
        __bindgen_bitfield_unit.set(32usize, 20u8, {
            let m_unAccountInstance: u32 = unsafe { ::std::mem::transmute(m_unAccountInstance) };
            m_unAccountInstance as u64
        });
        __bindgen_bitfield_unit.set(52usize, 4u8, {
            let m_EAccountType: u32 = unsafe { ::std::mem::transmute(m_EAccountType) };
            m_EAccountType as u64
        });
        __bindgen_bitfield_unit.set(56usize, 8u8, {
            let m_EUniverse: u32 = unsafe { ::std::mem::transmute(m_EUniverse) };
            m_EUniverse as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_CSteamID_SteamID_t() {
    const UNINIT: ::std::mem::MaybeUninit<CSteamID_SteamID_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CSteamID_SteamID_t>(),
        8usize,
        concat!("Size of: ", stringify!(CSteamID_SteamID_t))
    );
    assert_eq!(
        ::std::mem::align_of::<CSteamID_SteamID_t>(),
        1usize,
        concat!("Alignment of ", stringify!(CSteamID_SteamID_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_comp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamID_SteamID_t),
            "::",
            stringify!(m_comp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unAll64Bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamID_SteamID_t),
            "::",
            stringify!(m_unAll64Bits)
        )
    );
}
#[test]
fn bindgen_test_layout_CSteamID() {
    const UNINIT: ::std::mem::MaybeUninit<CSteamID> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CSteamID>(),
        8usize,
        concat!("Size of: ", stringify!(CSteamID))
    );
    assert_eq!(
        ::std::mem::align_of::<CSteamID>(),
        1usize,
        concat!("Alignment of ", stringify!(CSteamID))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamID),
            "::",
            stringify!(m_steamid)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK8CSteamID6RenderEv"]
    pub fn CSteamID_Render(this: *const CSteamID) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN8CSteamID6RenderEy"]
    pub fn CSteamID_Render1(ulSteamID: uint64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN8CSteamID13SetFromStringEPKc9EUniverse"]
    pub fn CSteamID_SetFromString(
        this: *mut CSteamID,
        pchSteamID: *const ::std::os::raw::c_char,
        eDefaultUniverse: EUniverse,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8CSteamID19SetFromStringStrictEPKc9EUniverse"]
    pub fn CSteamID_SetFromStringStrict(
        this: *mut CSteamID,
        pchSteamID: *const ::std::os::raw::c_char,
        eDefaultUniverse: EUniverse,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8CSteamID21BValidExternalSteamIDEv"]
    pub fn CSteamID_BValidExternalSteamID(this: *const CSteamID) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8CSteamIDC1EPKc9EUniverse"]
    pub fn CSteamID_CSteamID(
        this: *mut CSteamID,
        pchSteamID: *const ::std::os::raw::c_char,
        eDefaultUniverse: EUniverse,
    );
}
impl CSteamID {
    #[inline]
    pub unsafe fn Render(&self) -> *const ::std::os::raw::c_char {
        CSteamID_Render(self)
    }
    #[inline]
    pub unsafe fn Render1(ulSteamID: uint64) -> *const ::std::os::raw::c_char {
        CSteamID_Render1(ulSteamID)
    }
    #[inline]
    pub unsafe fn SetFromString(
        &mut self,
        pchSteamID: *const ::std::os::raw::c_char,
        eDefaultUniverse: EUniverse,
    ) {
        CSteamID_SetFromString(self, pchSteamID, eDefaultUniverse)
    }
    #[inline]
    pub unsafe fn SetFromStringStrict(
        &mut self,
        pchSteamID: *const ::std::os::raw::c_char,
        eDefaultUniverse: EUniverse,
    ) -> bool {
        CSteamID_SetFromStringStrict(self, pchSteamID, eDefaultUniverse)
    }
    #[inline]
    pub unsafe fn BValidExternalSteamID(&self) -> bool {
        CSteamID_BValidExternalSteamID(self)
    }
    #[inline]
    pub unsafe fn new(
        pchSteamID: *const ::std::os::raw::c_char,
        eDefaultUniverse: EUniverse,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        CSteamID_CSteamID(__bindgen_tmp.as_mut_ptr(), pchSteamID, eDefaultUniverse);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CGameID {
    pub __bindgen_anon_1: CGameID__bindgen_ty_1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CGameID_EGameIDType {
    k_EGameIDTypeApp = 0,
    k_EGameIDTypeGameMod = 1,
    k_EGameIDTypeShortcut = 2,
    k_EGameIDTypeP2P = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CGameID_GameID_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_CGameID_GameID_t() {
    assert_eq!(
        ::std::mem::size_of::<CGameID_GameID_t>(),
        8usize,
        concat!("Size of: ", stringify!(CGameID_GameID_t))
    );
    assert_eq!(
        ::std::mem::align_of::<CGameID_GameID_t>(),
        1usize,
        concat!("Alignment of ", stringify!(CGameID_GameID_t))
    );
}
impl CGameID_GameID_t {
    #[inline]
    pub fn m_nAppID(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_m_nAppID(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn m_nType(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_m_nType(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn m_nModID(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_m_nModID(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        m_nAppID: ::std::os::raw::c_uint,
        m_nType: ::std::os::raw::c_uint,
        m_nModID: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let m_nAppID: u32 = unsafe { ::std::mem::transmute(m_nAppID) };
            m_nAppID as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let m_nType: u32 = unsafe { ::std::mem::transmute(m_nType) };
            m_nType as u64
        });
        __bindgen_bitfield_unit.set(32usize, 32u8, {
            let m_nModID: u32 = unsafe { ::std::mem::transmute(m_nModID) };
            m_nModID as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union CGameID__bindgen_ty_1 {
    pub m_ulGameID: uint64,
    pub m_gameID: CGameID_GameID_t,
}
#[test]
fn bindgen_test_layout_CGameID__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<CGameID__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CGameID__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(CGameID__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<CGameID__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(CGameID__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulGameID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CGameID__bindgen_ty_1),
            "::",
            stringify!(m_ulGameID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_gameID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CGameID__bindgen_ty_1),
            "::",
            stringify!(m_gameID)
        )
    );
}
#[test]
fn bindgen_test_layout_CGameID() {
    assert_eq!(
        ::std::mem::size_of::<CGameID>(),
        8usize,
        concat!("Size of: ", stringify!(CGameID))
    );
    assert_eq!(
        ::std::mem::align_of::<CGameID>(),
        1usize,
        concat!("Alignment of ", stringify!(CGameID))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK7CGameID6RenderEv"]
    pub fn CGameID_Render(this: *const CGameID) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN7CGameID6RenderEy"]
    pub fn CGameID_Render1(ulGameID: uint64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN7CGameIDC1EPKc"]
    pub fn CGameID_CGameID(this: *mut CGameID, pchGameID: *const ::std::os::raw::c_char);
}
impl CGameID {
    #[inline]
    pub unsafe fn Render(&self) -> *const ::std::os::raw::c_char {
        CGameID_Render(self)
    }
    #[inline]
    pub unsafe fn Render1(ulGameID: uint64) -> *const ::std::os::raw::c_char {
        CGameID_Render1(ulGameID)
    }
    #[inline]
    pub unsafe fn new(pchGameID: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        CGameID_CGameID(__bindgen_tmp.as_mut_ptr(), pchGameID);
        __bindgen_tmp.assume_init()
    }
}
pub const k_cchGameExtraInfoMax: ::std::os::raw::c_int = 64;
pub type PFNPreMinidumpCallback =
    ::std::option::Option<unsafe extern "C" fn(context: *mut ::std::os::raw::c_void)>;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EGameSearchErrorCode_t {
    k_EGameSearchErrorCode_OK = 1,
    k_EGameSearchErrorCode_Failed_Search_Already_In_Progress = 2,
    k_EGameSearchErrorCode_Failed_No_Search_In_Progress = 3,
    k_EGameSearchErrorCode_Failed_Not_Lobby_Leader = 4,
    k_EGameSearchErrorCode_Failed_No_Host_Available = 5,
    k_EGameSearchErrorCode_Failed_Search_Params_Invalid = 6,
    k_EGameSearchErrorCode_Failed_Offline = 7,
    k_EGameSearchErrorCode_Failed_NotAuthorized = 8,
    k_EGameSearchErrorCode_Failed_Unknown_Error = 9,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EPlayerResult_t {
    k_EPlayerResultFailedToConnect = 1,
    k_EPlayerResultAbandoned = 2,
    k_EPlayerResultKicked = 3,
    k_EPlayerResultIncomplete = 4,
    k_EPlayerResultCompleted = 5,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamIPv6ConnectivityProtocol {
    k_ESteamIPv6ConnectivityProtocol_Invalid = 0,
    k_ESteamIPv6ConnectivityProtocol_HTTP = 1,
    k_ESteamIPv6ConnectivityProtocol_UDP = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamIPv6ConnectivityState {
    k_ESteamIPv6ConnectivityState_Unknown = 0,
    k_ESteamIPv6ConnectivityState_Good = 1,
    k_ESteamIPv6ConnectivityState_Bad = 2,
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct ValvePackingSentinel_t {
    pub m_u32: uint32,
    pub m_u64: uint64,
    pub m_u16: uint16,
    pub m_d: f64,
}
#[test]
fn bindgen_test_layout_ValvePackingSentinel_t() {
    const UNINIT: ::std::mem::MaybeUninit<ValvePackingSentinel_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ValvePackingSentinel_t>(),
        24usize,
        concat!("Size of: ", stringify!(ValvePackingSentinel_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ValvePackingSentinel_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ValvePackingSentinel_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_u32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ValvePackingSentinel_t),
            "::",
            stringify!(m_u32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_u64) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ValvePackingSentinel_t),
            "::",
            stringify!(m_u64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_u16) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ValvePackingSentinel_t),
            "::",
            stringify!(m_u16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_d) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ValvePackingSentinel_t),
            "::",
            stringify!(m_d)
        )
    );
}
pub type compile_time_assert_type = [::std::os::raw::c_char; 1usize];
pub type HSteamPipe = int32;
pub type HSteamUser = int32;
pub const k_cchMaxSteamErrMsg: ::std::os::raw::c_int = 1024;
pub type SteamErrMsg = [::std::os::raw::c_char; 1024usize];
pub type SteamAPIWarningMessageHook_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char),
>;
pub type SteamAPI_CheckCallbackRegistered_t =
    ::std::option::Option<unsafe extern "C" fn(iCallbackNum: ::std::os::raw::c_int) -> uint32>;
extern "C" {
    pub fn SteamAPI_RunCallbacks();
}
extern "C" {
    pub fn SteamGameServer_RunCallbacks();
}
#[repr(C)]
pub struct CCallbackBase__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CCallbackBase {
    pub vtable_: *const CCallbackBase__bindgen_vtable,
    pub m_nCallbackFlags: uint8,
    pub m_iCallback: ::std::os::raw::c_int,
}
pub const CCallbackBase_k_ECallbackFlagsRegistered: CCallbackBase__bindgen_ty_1 =
    CCallbackBase__bindgen_ty_1::k_ECallbackFlagsRegistered;
pub const CCallbackBase_k_ECallbackFlagsGameServer: CCallbackBase__bindgen_ty_1 =
    CCallbackBase__bindgen_ty_1::k_ECallbackFlagsGameServer;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CCallbackBase__bindgen_ty_1 {
    k_ECallbackFlagsRegistered = 1,
    k_ECallbackFlagsGameServer = 2,
}
#[test]
fn bindgen_test_layout_CCallbackBase() {
    const UNINIT: ::std::mem::MaybeUninit<CCallbackBase> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CCallbackBase>(),
        16usize,
        concat!("Size of: ", stringify!(CCallbackBase))
    );
    assert_eq!(
        ::std::mem::align_of::<CCallbackBase>(),
        8usize,
        concat!("Alignment of ", stringify!(CCallbackBase))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nCallbackFlags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CCallbackBase),
            "::",
            stringify!(m_nCallbackFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_iCallback) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CCallbackBase),
            "::",
            stringify!(m_iCallback)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct CCallResult<T, P> {
    pub _base: CCallbackBase,
    pub m_hAPICall: SteamAPICall_t,
    pub m_pObj: *mut T,
    pub m_Func: CCallResult_func_t<P>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<P>>,
}
pub type CCallResult_func_t<P> =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut P, arg2: bool)>;
pub type CCallback_func_t<P> = ::std::option::Option<unsafe extern "C" fn(arg1: *mut P)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::std::mem::MaybeUninit<__locale_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn SteamAPI_GetHSteamPipe() -> HSteamPipe;
}
extern "C" {
    pub fn SteamAPI_GetHSteamUser() -> HSteamUser;
}
extern "C" {
    pub fn SteamGameServer_GetHSteamPipe() -> HSteamPipe;
}
extern "C" {
    pub fn SteamGameServer_GetHSteamUser() -> HSteamUser;
}
extern "C" {
    pub fn SteamInternal_ContextInit(
        pContextInitData: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SteamInternal_CreateInterface(
        ver: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SteamInternal_FindOrCreateUserInterface(
        hSteamUser: HSteamUser,
        pszVersion: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SteamInternal_FindOrCreateGameServerInterface(
        hSteamUser: HSteamUser,
        pszVersion: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SteamAPI_RegisterCallback(
        pCallback: *mut CCallbackBase,
        iCallback: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_UnregisterCallback(pCallback: *mut CCallbackBase);
}
extern "C" {
    pub fn SteamAPI_RegisterCallResult(pCallback: *mut CCallbackBase, hAPICall: SteamAPICall_t);
}
extern "C" {
    pub fn SteamAPI_UnregisterCallResult(pCallback: *mut CCallbackBase, hAPICall: SteamAPICall_t);
}
#[doc = " Internal structure used in manual callback dispatch"]
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct CallbackMsg_t {
    pub m_hSteamUser: HSteamUser,
    pub m_iCallback: ::std::os::raw::c_int,
    pub m_pubParam: *mut uint8,
    pub m_cubParam: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CallbackMsg_t() {
    const UNINIT: ::std::mem::MaybeUninit<CallbackMsg_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CallbackMsg_t>(),
        20usize,
        concat!("Size of: ", stringify!(CallbackMsg_t))
    );
    assert_eq!(
        ::std::mem::align_of::<CallbackMsg_t>(),
        4usize,
        concat!("Alignment of ", stringify!(CallbackMsg_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hSteamUser) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CallbackMsg_t),
            "::",
            stringify!(m_hSteamUser)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_iCallback) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CallbackMsg_t),
            "::",
            stringify!(m_iCallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pubParam) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CallbackMsg_t),
            "::",
            stringify!(m_pubParam)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cubParam) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CallbackMsg_t),
            "::",
            stringify!(m_cubParam)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamContentServer {
    _unused: [u8; 0],
}
pub const k_iSteamUserCallbacks: _bindgen_ty_1 = _bindgen_ty_1::k_iSteamUserCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_1 {
    k_iSteamUserCallbacks = 100,
}
pub const k_iSteamGameServerCallbacks: _bindgen_ty_2 = _bindgen_ty_2::k_iSteamGameServerCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_2 {
    k_iSteamGameServerCallbacks = 200,
}
pub const k_iSteamFriendsCallbacks: _bindgen_ty_3 = _bindgen_ty_3::k_iSteamFriendsCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_3 {
    k_iSteamFriendsCallbacks = 300,
}
pub const k_iSteamBillingCallbacks: _bindgen_ty_4 = _bindgen_ty_4::k_iSteamBillingCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_4 {
    k_iSteamBillingCallbacks = 400,
}
pub const k_iSteamMatchmakingCallbacks: _bindgen_ty_5 = _bindgen_ty_5::k_iSteamMatchmakingCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_5 {
    k_iSteamMatchmakingCallbacks = 500,
}
pub const k_iSteamContentServerCallbacks: _bindgen_ty_6 =
    _bindgen_ty_6::k_iSteamContentServerCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_6 {
    k_iSteamContentServerCallbacks = 600,
}
pub const k_iSteamUtilsCallbacks: _bindgen_ty_7 = _bindgen_ty_7::k_iSteamUtilsCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_7 {
    k_iSteamUtilsCallbacks = 700,
}
pub const k_iSteamAppsCallbacks: _bindgen_ty_8 = _bindgen_ty_8::k_iSteamAppsCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_8 {
    k_iSteamAppsCallbacks = 1000,
}
pub const k_iSteamUserStatsCallbacks: _bindgen_ty_9 = _bindgen_ty_9::k_iSteamUserStatsCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_9 {
    k_iSteamUserStatsCallbacks = 1100,
}
pub const k_iSteamNetworkingCallbacks: _bindgen_ty_10 = _bindgen_ty_10::k_iSteamNetworkingCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_10 {
    k_iSteamNetworkingCallbacks = 1200,
}
pub const k_iSteamNetworkingSocketsCallbacks: _bindgen_ty_11 =
    _bindgen_ty_11::k_iSteamNetworkingSocketsCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_11 {
    k_iSteamNetworkingSocketsCallbacks = 1220,
}
pub const k_iSteamNetworkingMessagesCallbacks: _bindgen_ty_12 =
    _bindgen_ty_12::k_iSteamNetworkingMessagesCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_12 {
    k_iSteamNetworkingMessagesCallbacks = 1250,
}
pub const k_iSteamNetworkingUtilsCallbacks: _bindgen_ty_13 =
    _bindgen_ty_13::k_iSteamNetworkingUtilsCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_13 {
    k_iSteamNetworkingUtilsCallbacks = 1280,
}
pub const k_iSteamRemoteStorageCallbacks: _bindgen_ty_14 =
    _bindgen_ty_14::k_iSteamRemoteStorageCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_14 {
    k_iSteamRemoteStorageCallbacks = 1300,
}
pub const k_iSteamGameServerItemsCallbacks: _bindgen_ty_15 =
    _bindgen_ty_15::k_iSteamGameServerItemsCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_15 {
    k_iSteamGameServerItemsCallbacks = 1500,
}
pub const k_iSteamGameCoordinatorCallbacks: _bindgen_ty_16 =
    _bindgen_ty_16::k_iSteamGameCoordinatorCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_16 {
    k_iSteamGameCoordinatorCallbacks = 1700,
}
pub const k_iSteamGameServerStatsCallbacks: _bindgen_ty_17 =
    _bindgen_ty_17::k_iSteamGameServerStatsCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_17 {
    k_iSteamGameServerStatsCallbacks = 1800,
}
pub const k_iSteam2AsyncCallbacks: _bindgen_ty_18 = _bindgen_ty_18::k_iSteam2AsyncCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_18 {
    k_iSteam2AsyncCallbacks = 1900,
}
pub const k_iSteamGameStatsCallbacks: _bindgen_ty_19 = _bindgen_ty_19::k_iSteamGameStatsCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_19 {
    k_iSteamGameStatsCallbacks = 2000,
}
pub const k_iSteamHTTPCallbacks: _bindgen_ty_20 = _bindgen_ty_20::k_iSteamHTTPCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_20 {
    k_iSteamHTTPCallbacks = 2100,
}
pub const k_iSteamScreenshotsCallbacks: _bindgen_ty_21 =
    _bindgen_ty_21::k_iSteamScreenshotsCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_21 {
    k_iSteamScreenshotsCallbacks = 2300,
}
pub const k_iSteamStreamLauncherCallbacks: _bindgen_ty_22 =
    _bindgen_ty_22::k_iSteamStreamLauncherCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_22 {
    k_iSteamStreamLauncherCallbacks = 2600,
}
pub const k_iSteamControllerCallbacks: _bindgen_ty_23 = _bindgen_ty_23::k_iSteamControllerCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_23 {
    k_iSteamControllerCallbacks = 2800,
}
pub const k_iSteamUGCCallbacks: _bindgen_ty_24 = _bindgen_ty_24::k_iSteamUGCCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_24 {
    k_iSteamUGCCallbacks = 3400,
}
pub const k_iSteamStreamClientCallbacks: _bindgen_ty_25 =
    _bindgen_ty_25::k_iSteamStreamClientCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_25 {
    k_iSteamStreamClientCallbacks = 3500,
}
pub const k_iSteamMusicCallbacks: _bindgen_ty_26 = _bindgen_ty_26::k_iSteamMusicCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_26 {
    k_iSteamMusicCallbacks = 4000,
}
pub const k_iSteamMusicRemoteCallbacks: _bindgen_ty_27 =
    _bindgen_ty_27::k_iSteamMusicRemoteCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_27 {
    k_iSteamMusicRemoteCallbacks = 4100,
}
pub const k_iSteamGameNotificationCallbacks: _bindgen_ty_28 =
    _bindgen_ty_28::k_iSteamGameNotificationCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_28 {
    k_iSteamGameNotificationCallbacks = 4400,
}
pub const k_iSteamHTMLSurfaceCallbacks: _bindgen_ty_29 =
    _bindgen_ty_29::k_iSteamHTMLSurfaceCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_29 {
    k_iSteamHTMLSurfaceCallbacks = 4500,
}
pub const k_iSteamVideoCallbacks: _bindgen_ty_30 = _bindgen_ty_30::k_iSteamVideoCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_30 {
    k_iSteamVideoCallbacks = 4600,
}
pub const k_iSteamInventoryCallbacks: _bindgen_ty_31 = _bindgen_ty_31::k_iSteamInventoryCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_31 {
    k_iSteamInventoryCallbacks = 4700,
}
pub const k_ISteamParentalSettingsCallbacks: _bindgen_ty_32 =
    _bindgen_ty_32::k_ISteamParentalSettingsCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_32 {
    k_ISteamParentalSettingsCallbacks = 5000,
}
pub const k_iSteamGameSearchCallbacks: _bindgen_ty_33 = _bindgen_ty_33::k_iSteamGameSearchCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_33 {
    k_iSteamGameSearchCallbacks = 5200,
}
pub const k_iSteamPartiesCallbacks: _bindgen_ty_34 = _bindgen_ty_34::k_iSteamPartiesCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_34 {
    k_iSteamPartiesCallbacks = 5300,
}
pub const k_iSteamSTARCallbacks: _bindgen_ty_35 = _bindgen_ty_35::k_iSteamSTARCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_35 {
    k_iSteamSTARCallbacks = 5500,
}
pub const k_iSteamRemotePlayCallbacks: _bindgen_ty_36 = _bindgen_ty_36::k_iSteamRemotePlayCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_36 {
    k_iSteamRemotePlayCallbacks = 5700,
}
pub const k_iSteamChatCallbacks: _bindgen_ty_37 = _bindgen_ty_37::k_iSteamChatCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_37 {
    k_iSteamChatCallbacks = 5900,
}
pub const k_iSteamTimelineCallbacks: _bindgen_ty_38 = _bindgen_ty_38::k_iSteamTimelineCallbacks;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_38 {
    k_iSteamTimelineCallbacks = 6000,
}
#[repr(C)]
pub struct ISteamClient__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamClient {
    pub vtable_: *const ISteamClient__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamClient() {
    assert_eq!(
        ::std::mem::size_of::<ISteamClient>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamClient))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamClient>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamClient))
    );
}
#[repr(C)]
pub struct ISteamUser__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamUser {
    pub vtable_: *const ISteamUser__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamUser() {
    assert_eq!(
        ::std::mem::size_of::<ISteamUser>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamUser))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamUser>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamUser))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamServersConnected_t {
    pub _address: u8,
}
pub const SteamServersConnected_t_k_iCallback: SteamServersConnected_t__bindgen_ty_1 =
    SteamServersConnected_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamServersConnected_t__bindgen_ty_1 {
    k_iCallback = 101,
}
#[test]
fn bindgen_test_layout_SteamServersConnected_t() {
    assert_eq!(
        ::std::mem::size_of::<SteamServersConnected_t>(),
        1usize,
        concat!("Size of: ", stringify!(SteamServersConnected_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamServersConnected_t>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamServersConnected_t))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamServerConnectFailure_t {
    pub m_eResult: EResult,
    pub m_bStillRetrying: bool,
}
pub const SteamServerConnectFailure_t_k_iCallback: SteamServerConnectFailure_t__bindgen_ty_1 =
    SteamServerConnectFailure_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamServerConnectFailure_t__bindgen_ty_1 {
    k_iCallback = 102,
}
#[test]
fn bindgen_test_layout_SteamServerConnectFailure_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamServerConnectFailure_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamServerConnectFailure_t>(),
        8usize,
        concat!("Size of: ", stringify!(SteamServerConnectFailure_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamServerConnectFailure_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamServerConnectFailure_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamServerConnectFailure_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bStillRetrying) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamServerConnectFailure_t),
            "::",
            stringify!(m_bStillRetrying)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamServersDisconnected_t {
    pub m_eResult: EResult,
}
pub const SteamServersDisconnected_t_k_iCallback: SteamServersDisconnected_t__bindgen_ty_1 =
    SteamServersDisconnected_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamServersDisconnected_t__bindgen_ty_1 {
    k_iCallback = 103,
}
#[test]
fn bindgen_test_layout_SteamServersDisconnected_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamServersDisconnected_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamServersDisconnected_t>(),
        4usize,
        concat!("Size of: ", stringify!(SteamServersDisconnected_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamServersDisconnected_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamServersDisconnected_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamServersDisconnected_t),
            "::",
            stringify!(m_eResult)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ClientGameServerDeny_t {
    pub m_uAppID: uint32,
    pub m_unGameServerIP: uint32,
    pub m_usGameServerPort: uint16,
    pub m_bSecure: uint16,
    pub m_uReason: uint32,
}
pub const ClientGameServerDeny_t_k_iCallback: ClientGameServerDeny_t__bindgen_ty_1 =
    ClientGameServerDeny_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ClientGameServerDeny_t__bindgen_ty_1 {
    k_iCallback = 113,
}
#[test]
fn bindgen_test_layout_ClientGameServerDeny_t() {
    const UNINIT: ::std::mem::MaybeUninit<ClientGameServerDeny_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClientGameServerDeny_t>(),
        16usize,
        concat!("Size of: ", stringify!(ClientGameServerDeny_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ClientGameServerDeny_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ClientGameServerDeny_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uAppID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClientGameServerDeny_t),
            "::",
            stringify!(m_uAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unGameServerIP) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ClientGameServerDeny_t),
            "::",
            stringify!(m_unGameServerIP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_usGameServerPort) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClientGameServerDeny_t),
            "::",
            stringify!(m_usGameServerPort)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bSecure) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ClientGameServerDeny_t),
            "::",
            stringify!(m_bSecure)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uReason) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ClientGameServerDeny_t),
            "::",
            stringify!(m_uReason)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPCFailure_t {
    pub m_eFailureType: uint8,
}
pub const IPCFailure_t_k_iCallback: IPCFailure_t__bindgen_ty_1 =
    IPCFailure_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IPCFailure_t__bindgen_ty_1 {
    k_iCallback = 117,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IPCFailure_t_EFailureType {
    k_EFailureFlushedCallbackQueue = 0,
    k_EFailurePipeFail = 1,
}
#[test]
fn bindgen_test_layout_IPCFailure_t() {
    const UNINIT: ::std::mem::MaybeUninit<IPCFailure_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IPCFailure_t>(),
        1usize,
        concat!("Size of: ", stringify!(IPCFailure_t))
    );
    assert_eq!(
        ::std::mem::align_of::<IPCFailure_t>(),
        1usize,
        concat!("Alignment of ", stringify!(IPCFailure_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eFailureType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IPCFailure_t),
            "::",
            stringify!(m_eFailureType)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LicensesUpdated_t {
    pub _address: u8,
}
pub const LicensesUpdated_t_k_iCallback: LicensesUpdated_t__bindgen_ty_1 =
    LicensesUpdated_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum LicensesUpdated_t__bindgen_ty_1 {
    k_iCallback = 125,
}
#[test]
fn bindgen_test_layout_LicensesUpdated_t() {
    assert_eq!(
        ::std::mem::size_of::<LicensesUpdated_t>(),
        1usize,
        concat!("Size of: ", stringify!(LicensesUpdated_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LicensesUpdated_t>(),
        1usize,
        concat!("Alignment of ", stringify!(LicensesUpdated_t))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ValidateAuthTicketResponse_t {
    pub m_SteamID: CSteamID,
    pub m_eAuthSessionResponse: EAuthSessionResponse,
    pub m_OwnerSteamID: CSteamID,
}
pub const ValidateAuthTicketResponse_t_k_iCallback: ValidateAuthTicketResponse_t__bindgen_ty_1 =
    ValidateAuthTicketResponse_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ValidateAuthTicketResponse_t__bindgen_ty_1 {
    k_iCallback = 143,
}
#[test]
fn bindgen_test_layout_ValidateAuthTicketResponse_t() {
    const UNINIT: ::std::mem::MaybeUninit<ValidateAuthTicketResponse_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ValidateAuthTicketResponse_t>(),
        20usize,
        concat!("Size of: ", stringify!(ValidateAuthTicketResponse_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ValidateAuthTicketResponse_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ValidateAuthTicketResponse_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_SteamID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ValidateAuthTicketResponse_t),
            "::",
            stringify!(m_SteamID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eAuthSessionResponse) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ValidateAuthTicketResponse_t),
            "::",
            stringify!(m_eAuthSessionResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_OwnerSteamID) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ValidateAuthTicketResponse_t),
            "::",
            stringify!(m_OwnerSteamID)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct MicroTxnAuthorizationResponse_t {
    pub m_unAppID: uint32,
    pub m_ulOrderID: uint64,
    pub m_bAuthorized: uint8,
}
pub const MicroTxnAuthorizationResponse_t_k_iCallback:
    MicroTxnAuthorizationResponse_t__bindgen_ty_1 =
    MicroTxnAuthorizationResponse_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum MicroTxnAuthorizationResponse_t__bindgen_ty_1 {
    k_iCallback = 152,
}
#[test]
fn bindgen_test_layout_MicroTxnAuthorizationResponse_t() {
    const UNINIT: ::std::mem::MaybeUninit<MicroTxnAuthorizationResponse_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MicroTxnAuthorizationResponse_t>(),
        16usize,
        concat!("Size of: ", stringify!(MicroTxnAuthorizationResponse_t))
    );
    assert_eq!(
        ::std::mem::align_of::<MicroTxnAuthorizationResponse_t>(),
        4usize,
        concat!("Alignment of ", stringify!(MicroTxnAuthorizationResponse_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unAppID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MicroTxnAuthorizationResponse_t),
            "::",
            stringify!(m_unAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulOrderID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MicroTxnAuthorizationResponse_t),
            "::",
            stringify!(m_ulOrderID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bAuthorized) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MicroTxnAuthorizationResponse_t),
            "::",
            stringify!(m_bAuthorized)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EncryptedAppTicketResponse_t {
    pub m_eResult: EResult,
}
pub const EncryptedAppTicketResponse_t_k_iCallback: EncryptedAppTicketResponse_t__bindgen_ty_1 =
    EncryptedAppTicketResponse_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EncryptedAppTicketResponse_t__bindgen_ty_1 {
    k_iCallback = 154,
}
#[test]
fn bindgen_test_layout_EncryptedAppTicketResponse_t() {
    const UNINIT: ::std::mem::MaybeUninit<EncryptedAppTicketResponse_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<EncryptedAppTicketResponse_t>(),
        4usize,
        concat!("Size of: ", stringify!(EncryptedAppTicketResponse_t))
    );
    assert_eq!(
        ::std::mem::align_of::<EncryptedAppTicketResponse_t>(),
        4usize,
        concat!("Alignment of ", stringify!(EncryptedAppTicketResponse_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EncryptedAppTicketResponse_t),
            "::",
            stringify!(m_eResult)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GetAuthSessionTicketResponse_t {
    pub m_hAuthTicket: HAuthTicket,
    pub m_eResult: EResult,
}
pub const GetAuthSessionTicketResponse_t_k_iCallback: GetAuthSessionTicketResponse_t__bindgen_ty_1 =
    GetAuthSessionTicketResponse_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GetAuthSessionTicketResponse_t__bindgen_ty_1 {
    k_iCallback = 163,
}
#[test]
fn bindgen_test_layout_GetAuthSessionTicketResponse_t() {
    const UNINIT: ::std::mem::MaybeUninit<GetAuthSessionTicketResponse_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GetAuthSessionTicketResponse_t>(),
        8usize,
        concat!("Size of: ", stringify!(GetAuthSessionTicketResponse_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GetAuthSessionTicketResponse_t>(),
        4usize,
        concat!("Alignment of ", stringify!(GetAuthSessionTicketResponse_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hAuthTicket) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GetAuthSessionTicketResponse_t),
            "::",
            stringify!(m_hAuthTicket)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GetAuthSessionTicketResponse_t),
            "::",
            stringify!(m_eResult)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GameWebCallback_t {
    pub m_szURL: [::std::os::raw::c_char; 256usize],
}
pub const GameWebCallback_t_k_iCallback: GameWebCallback_t__bindgen_ty_1 =
    GameWebCallback_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GameWebCallback_t__bindgen_ty_1 {
    k_iCallback = 164,
}
#[test]
fn bindgen_test_layout_GameWebCallback_t() {
    const UNINIT: ::std::mem::MaybeUninit<GameWebCallback_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GameWebCallback_t>(),
        256usize,
        concat!("Size of: ", stringify!(GameWebCallback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GameWebCallback_t>(),
        1usize,
        concat!("Alignment of ", stringify!(GameWebCallback_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szURL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GameWebCallback_t),
            "::",
            stringify!(m_szURL)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StoreAuthURLResponse_t {
    pub m_szURL: [::std::os::raw::c_char; 512usize],
}
pub const StoreAuthURLResponse_t_k_iCallback: StoreAuthURLResponse_t__bindgen_ty_1 =
    StoreAuthURLResponse_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum StoreAuthURLResponse_t__bindgen_ty_1 {
    k_iCallback = 165,
}
#[test]
fn bindgen_test_layout_StoreAuthURLResponse_t() {
    const UNINIT: ::std::mem::MaybeUninit<StoreAuthURLResponse_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<StoreAuthURLResponse_t>(),
        512usize,
        concat!("Size of: ", stringify!(StoreAuthURLResponse_t))
    );
    assert_eq!(
        ::std::mem::align_of::<StoreAuthURLResponse_t>(),
        1usize,
        concat!("Alignment of ", stringify!(StoreAuthURLResponse_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szURL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(StoreAuthURLResponse_t),
            "::",
            stringify!(m_szURL)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MarketEligibilityResponse_t {
    pub m_bAllowed: bool,
    pub m_eNotAllowedReason: EMarketNotAllowedReasonFlags,
    pub m_rtAllowedAtTime: RTime32,
    pub m_cdaySteamGuardRequiredDays: ::std::os::raw::c_int,
    pub m_cdayNewDeviceCooldown: ::std::os::raw::c_int,
}
pub const MarketEligibilityResponse_t_k_iCallback: MarketEligibilityResponse_t__bindgen_ty_1 =
    MarketEligibilityResponse_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum MarketEligibilityResponse_t__bindgen_ty_1 {
    k_iCallback = 166,
}
#[test]
fn bindgen_test_layout_MarketEligibilityResponse_t() {
    const UNINIT: ::std::mem::MaybeUninit<MarketEligibilityResponse_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MarketEligibilityResponse_t>(),
        20usize,
        concat!("Size of: ", stringify!(MarketEligibilityResponse_t))
    );
    assert_eq!(
        ::std::mem::align_of::<MarketEligibilityResponse_t>(),
        4usize,
        concat!("Alignment of ", stringify!(MarketEligibilityResponse_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bAllowed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MarketEligibilityResponse_t),
            "::",
            stringify!(m_bAllowed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eNotAllowedReason) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MarketEligibilityResponse_t),
            "::",
            stringify!(m_eNotAllowedReason)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rtAllowedAtTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MarketEligibilityResponse_t),
            "::",
            stringify!(m_rtAllowedAtTime)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_cdaySteamGuardRequiredDays) as usize - ptr as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MarketEligibilityResponse_t),
            "::",
            stringify!(m_cdaySteamGuardRequiredDays)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cdayNewDeviceCooldown) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MarketEligibilityResponse_t),
            "::",
            stringify!(m_cdayNewDeviceCooldown)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DurationControl_t {
    pub m_eResult: EResult,
    pub m_appid: AppId_t,
    pub m_bApplicable: bool,
    pub m_csecsLast5h: int32,
    pub m_progress: EDurationControlProgress,
    pub m_notification: EDurationControlNotification,
    pub m_csecsToday: int32,
    pub m_csecsRemaining: int32,
}
pub const DurationControl_t_k_iCallback: DurationControl_t__bindgen_ty_1 =
    DurationControl_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum DurationControl_t__bindgen_ty_1 {
    k_iCallback = 167,
}
#[test]
fn bindgen_test_layout_DurationControl_t() {
    const UNINIT: ::std::mem::MaybeUninit<DurationControl_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DurationControl_t>(),
        32usize,
        concat!("Size of: ", stringify!(DurationControl_t))
    );
    assert_eq!(
        ::std::mem::align_of::<DurationControl_t>(),
        4usize,
        concat!("Alignment of ", stringify!(DurationControl_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DurationControl_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_appid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DurationControl_t),
            "::",
            stringify!(m_appid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bApplicable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DurationControl_t),
            "::",
            stringify!(m_bApplicable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_csecsLast5h) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DurationControl_t),
            "::",
            stringify!(m_csecsLast5h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_progress) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DurationControl_t),
            "::",
            stringify!(m_progress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_notification) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(DurationControl_t),
            "::",
            stringify!(m_notification)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_csecsToday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DurationControl_t),
            "::",
            stringify!(m_csecsToday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_csecsRemaining) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(DurationControl_t),
            "::",
            stringify!(m_csecsRemaining)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GetTicketForWebApiResponse_t {
    pub m_hAuthTicket: HAuthTicket,
    pub m_eResult: EResult,
    pub m_cubTicket: ::std::os::raw::c_int,
    pub m_rgubTicket: [uint8; 2560usize],
}
pub const GetTicketForWebApiResponse_t_k_iCallback: GetTicketForWebApiResponse_t__bindgen_ty_1 =
    GetTicketForWebApiResponse_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GetTicketForWebApiResponse_t__bindgen_ty_1 {
    k_iCallback = 168,
}
pub const GetTicketForWebApiResponse_t_k_nCubTicketMaxLength: ::std::os::raw::c_int = 2560;
#[test]
fn bindgen_test_layout_GetTicketForWebApiResponse_t() {
    const UNINIT: ::std::mem::MaybeUninit<GetTicketForWebApiResponse_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GetTicketForWebApiResponse_t>(),
        2572usize,
        concat!("Size of: ", stringify!(GetTicketForWebApiResponse_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GetTicketForWebApiResponse_t>(),
        4usize,
        concat!("Alignment of ", stringify!(GetTicketForWebApiResponse_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hAuthTicket) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GetTicketForWebApiResponse_t),
            "::",
            stringify!(m_hAuthTicket)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GetTicketForWebApiResponse_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cubTicket) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GetTicketForWebApiResponse_t),
            "::",
            stringify!(m_cubTicket)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgubTicket) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GetTicketForWebApiResponse_t),
            "::",
            stringify!(m_rgubTicket)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EFriendRelationship {
    k_EFriendRelationshipNone = 0,
    k_EFriendRelationshipBlocked = 1,
    k_EFriendRelationshipRequestRecipient = 2,
    k_EFriendRelationshipFriend = 3,
    k_EFriendRelationshipRequestInitiator = 4,
    k_EFriendRelationshipIgnored = 5,
    k_EFriendRelationshipIgnoredFriend = 6,
    k_EFriendRelationshipSuggested_DEPRECATED = 7,
    k_EFriendRelationshipMax = 8,
}
pub const k_cchMaxFriendsGroupName: ::std::os::raw::c_int = 64;
pub const k_cFriendsGroupLimit: ::std::os::raw::c_int = 100;
pub type FriendsGroupID_t = int16;
pub const k_FriendsGroupID_Invalid: FriendsGroupID_t = -1;
pub const k_cEnumerateFollowersMax: ::std::os::raw::c_int = 50;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EPersonaState {
    k_EPersonaStateOffline = 0,
    k_EPersonaStateOnline = 1,
    k_EPersonaStateBusy = 2,
    k_EPersonaStateAway = 3,
    k_EPersonaStateSnooze = 4,
    k_EPersonaStateLookingToTrade = 5,
    k_EPersonaStateLookingToPlay = 6,
    k_EPersonaStateInvisible = 7,
    k_EPersonaStateMax = 8,
}
impl EFriendFlags {
    pub const k_EFriendFlagNone: EFriendFlags = EFriendFlags(0);
}
impl EFriendFlags {
    pub const k_EFriendFlagBlocked: EFriendFlags = EFriendFlags(1);
}
impl EFriendFlags {
    pub const k_EFriendFlagFriendshipRequested: EFriendFlags = EFriendFlags(2);
}
impl EFriendFlags {
    pub const k_EFriendFlagImmediate: EFriendFlags = EFriendFlags(4);
}
impl EFriendFlags {
    pub const k_EFriendFlagClanMember: EFriendFlags = EFriendFlags(8);
}
impl EFriendFlags {
    pub const k_EFriendFlagOnGameServer: EFriendFlags = EFriendFlags(16);
}
impl EFriendFlags {
    pub const k_EFriendFlagRequestingFriendship: EFriendFlags = EFriendFlags(128);
}
impl EFriendFlags {
    pub const k_EFriendFlagRequestingInfo: EFriendFlags = EFriendFlags(256);
}
impl EFriendFlags {
    pub const k_EFriendFlagIgnored: EFriendFlags = EFriendFlags(512);
}
impl EFriendFlags {
    pub const k_EFriendFlagIgnoredFriend: EFriendFlags = EFriendFlags(1024);
}
impl EFriendFlags {
    pub const k_EFriendFlagChatMember: EFriendFlags = EFriendFlags(4096);
}
impl EFriendFlags {
    pub const k_EFriendFlagAll: EFriendFlags = EFriendFlags(65535);
}
impl ::std::ops::BitOr<EFriendFlags> for EFriendFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        EFriendFlags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for EFriendFlags {
    #[inline]
    fn bitor_assign(&mut self, rhs: EFriendFlags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<EFriendFlags> for EFriendFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        EFriendFlags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for EFriendFlags {
    #[inline]
    fn bitand_assign(&mut self, rhs: EFriendFlags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct EFriendFlags(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FriendGameInfo_t {
    pub m_gameID: CGameID,
    pub m_unGameIP: uint32,
    pub m_usGamePort: uint16,
    pub m_usQueryPort: uint16,
    pub m_steamIDLobby: CSteamID,
}
#[test]
fn bindgen_test_layout_FriendGameInfo_t() {
    const UNINIT: ::std::mem::MaybeUninit<FriendGameInfo_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FriendGameInfo_t>(),
        24usize,
        concat!("Size of: ", stringify!(FriendGameInfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<FriendGameInfo_t>(),
        4usize,
        concat!("Alignment of ", stringify!(FriendGameInfo_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_gameID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendGameInfo_t),
            "::",
            stringify!(m_gameID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unGameIP) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendGameInfo_t),
            "::",
            stringify!(m_unGameIP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_usGamePort) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendGameInfo_t),
            "::",
            stringify!(m_usGamePort)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_usQueryPort) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendGameInfo_t),
            "::",
            stringify!(m_usQueryPort)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDLobby) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendGameInfo_t),
            "::",
            stringify!(m_steamIDLobby)
        )
    );
}
pub const k_usFriendGameInfoQueryPort_NotInitialized: uint16 = 65535;
pub const k_usFriendGameInfoQueryPort_Error: uint16 = 65534;
pub const k_cchPersonaNameMax: _bindgen_ty_39 = _bindgen_ty_39::k_cchPersonaNameMax;
pub const k_cwchPersonaNameMax: _bindgen_ty_39 = _bindgen_ty_39::k_cwchPersonaNameMax;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_39 {
    k_cchPersonaNameMax = 128,
    k_cwchPersonaNameMax = 32,
}
pub const k_cubChatMetadataMax: uint32 = 8192;
pub const k_cchMaxRichPresenceKeys: _bindgen_ty_40 = _bindgen_ty_40::k_cchMaxRichPresenceKeys;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_40 {
    k_cchMaxRichPresenceKeys = 30,
}
pub const k_cchMaxRichPresenceKeyLength: _bindgen_ty_41 =
    _bindgen_ty_41::k_cchMaxRichPresenceKeyLength;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_41 {
    k_cchMaxRichPresenceKeyLength = 64,
}
pub const k_cchMaxRichPresenceValueLength: _bindgen_ty_42 =
    _bindgen_ty_42::k_cchMaxRichPresenceValueLength;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_42 {
    k_cchMaxRichPresenceValueLength = 256,
}
impl EOverlayToStoreFlag {
    pub const k_EOverlayToStoreFlag_None: EOverlayToStoreFlag = EOverlayToStoreFlag(0);
}
impl EOverlayToStoreFlag {
    pub const k_EOverlayToStoreFlag_AddToCart: EOverlayToStoreFlag = EOverlayToStoreFlag(1);
}
impl EOverlayToStoreFlag {
    pub const k_EOverlayToStoreFlag_AddToCartAndShow: EOverlayToStoreFlag = EOverlayToStoreFlag(2);
}
impl ::std::ops::BitOr<EOverlayToStoreFlag> for EOverlayToStoreFlag {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        EOverlayToStoreFlag(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for EOverlayToStoreFlag {
    #[inline]
    fn bitor_assign(&mut self, rhs: EOverlayToStoreFlag) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<EOverlayToStoreFlag> for EOverlayToStoreFlag {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        EOverlayToStoreFlag(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for EOverlayToStoreFlag {
    #[inline]
    fn bitand_assign(&mut self, rhs: EOverlayToStoreFlag) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct EOverlayToStoreFlag(pub ::std::os::raw::c_uint);
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EActivateGameOverlayToWebPageMode {
    k_EActivateGameOverlayToWebPageMode_Default = 0,
    k_EActivateGameOverlayToWebPageMode_Modal = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ECommunityProfileItemType {
    k_ECommunityProfileItemType_AnimatedAvatar = 0,
    k_ECommunityProfileItemType_AvatarFrame = 1,
    k_ECommunityProfileItemType_ProfileModifier = 2,
    k_ECommunityProfileItemType_ProfileBackground = 3,
    k_ECommunityProfileItemType_MiniProfileBackground = 4,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ECommunityProfileItemProperty {
    k_ECommunityProfileItemProperty_ImageSmall = 0,
    k_ECommunityProfileItemProperty_ImageLarge = 1,
    k_ECommunityProfileItemProperty_InternalName = 2,
    k_ECommunityProfileItemProperty_Title = 3,
    k_ECommunityProfileItemProperty_Description = 4,
    k_ECommunityProfileItemProperty_AppID = 5,
    k_ECommunityProfileItemProperty_TypeID = 6,
    k_ECommunityProfileItemProperty_Class = 7,
    k_ECommunityProfileItemProperty_MovieWebM = 8,
    k_ECommunityProfileItemProperty_MovieMP4 = 9,
    k_ECommunityProfileItemProperty_MovieWebMSmall = 10,
    k_ECommunityProfileItemProperty_MovieMP4Small = 11,
}
#[repr(C)]
pub struct ISteamFriends__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamFriends {
    pub vtable_: *const ISteamFriends__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamFriends() {
    assert_eq!(
        ::std::mem::size_of::<ISteamFriends>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamFriends))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamFriends>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamFriends))
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct PersonaStateChange_t {
    pub m_ulSteamID: uint64,
    pub m_nChangeFlags: ::std::os::raw::c_int,
}
pub const PersonaStateChange_t_k_iCallback: PersonaStateChange_t__bindgen_ty_1 =
    PersonaStateChange_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum PersonaStateChange_t__bindgen_ty_1 {
    k_iCallback = 304,
}
#[test]
fn bindgen_test_layout_PersonaStateChange_t() {
    const UNINIT: ::std::mem::MaybeUninit<PersonaStateChange_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PersonaStateChange_t>(),
        12usize,
        concat!("Size of: ", stringify!(PersonaStateChange_t))
    );
    assert_eq!(
        ::std::mem::align_of::<PersonaStateChange_t>(),
        4usize,
        concat!("Alignment of ", stringify!(PersonaStateChange_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PersonaStateChange_t),
            "::",
            stringify!(m_ulSteamID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nChangeFlags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PersonaStateChange_t),
            "::",
            stringify!(m_nChangeFlags)
        )
    );
}
impl EPersonaChange {
    pub const k_EPersonaChangeName: EPersonaChange = EPersonaChange(1);
}
impl EPersonaChange {
    pub const k_EPersonaChangeStatus: EPersonaChange = EPersonaChange(2);
}
impl EPersonaChange {
    pub const k_EPersonaChangeComeOnline: EPersonaChange = EPersonaChange(4);
}
impl EPersonaChange {
    pub const k_EPersonaChangeGoneOffline: EPersonaChange = EPersonaChange(8);
}
impl EPersonaChange {
    pub const k_EPersonaChangeGamePlayed: EPersonaChange = EPersonaChange(16);
}
impl EPersonaChange {
    pub const k_EPersonaChangeGameServer: EPersonaChange = EPersonaChange(32);
}
impl EPersonaChange {
    pub const k_EPersonaChangeAvatar: EPersonaChange = EPersonaChange(64);
}
impl EPersonaChange {
    pub const k_EPersonaChangeJoinedSource: EPersonaChange = EPersonaChange(128);
}
impl EPersonaChange {
    pub const k_EPersonaChangeLeftSource: EPersonaChange = EPersonaChange(256);
}
impl EPersonaChange {
    pub const k_EPersonaChangeRelationshipChanged: EPersonaChange = EPersonaChange(512);
}
impl EPersonaChange {
    pub const k_EPersonaChangeNameFirstSet: EPersonaChange = EPersonaChange(1024);
}
impl EPersonaChange {
    pub const k_EPersonaChangeBroadcast: EPersonaChange = EPersonaChange(2048);
}
impl EPersonaChange {
    pub const k_EPersonaChangeNickname: EPersonaChange = EPersonaChange(4096);
}
impl EPersonaChange {
    pub const k_EPersonaChangeSteamLevel: EPersonaChange = EPersonaChange(8192);
}
impl EPersonaChange {
    pub const k_EPersonaChangeRichPresence: EPersonaChange = EPersonaChange(16384);
}
impl ::std::ops::BitOr<EPersonaChange> for EPersonaChange {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        EPersonaChange(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for EPersonaChange {
    #[inline]
    fn bitor_assign(&mut self, rhs: EPersonaChange) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<EPersonaChange> for EPersonaChange {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        EPersonaChange(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for EPersonaChange {
    #[inline]
    fn bitand_assign(&mut self, rhs: EPersonaChange) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct EPersonaChange(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GameOverlayActivated_t {
    pub m_bActive: uint8,
    pub m_bUserInitiated: bool,
    pub m_nAppID: AppId_t,
    pub m_dwOverlayPID: uint32,
}
pub const GameOverlayActivated_t_k_iCallback: GameOverlayActivated_t__bindgen_ty_1 =
    GameOverlayActivated_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GameOverlayActivated_t__bindgen_ty_1 {
    k_iCallback = 331,
}
#[test]
fn bindgen_test_layout_GameOverlayActivated_t() {
    const UNINIT: ::std::mem::MaybeUninit<GameOverlayActivated_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GameOverlayActivated_t>(),
        12usize,
        concat!("Size of: ", stringify!(GameOverlayActivated_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GameOverlayActivated_t>(),
        4usize,
        concat!("Alignment of ", stringify!(GameOverlayActivated_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bActive) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GameOverlayActivated_t),
            "::",
            stringify!(m_bActive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bUserInitiated) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(GameOverlayActivated_t),
            "::",
            stringify!(m_bUserInitiated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nAppID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GameOverlayActivated_t),
            "::",
            stringify!(m_nAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_dwOverlayPID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GameOverlayActivated_t),
            "::",
            stringify!(m_dwOverlayPID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GameServerChangeRequested_t {
    pub m_rgchServer: [::std::os::raw::c_char; 64usize],
    pub m_rgchPassword: [::std::os::raw::c_char; 64usize],
}
pub const GameServerChangeRequested_t_k_iCallback: GameServerChangeRequested_t__bindgen_ty_1 =
    GameServerChangeRequested_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GameServerChangeRequested_t__bindgen_ty_1 {
    k_iCallback = 332,
}
#[test]
fn bindgen_test_layout_GameServerChangeRequested_t() {
    const UNINIT: ::std::mem::MaybeUninit<GameServerChangeRequested_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GameServerChangeRequested_t>(),
        128usize,
        concat!("Size of: ", stringify!(GameServerChangeRequested_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GameServerChangeRequested_t>(),
        1usize,
        concat!("Alignment of ", stringify!(GameServerChangeRequested_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchServer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GameServerChangeRequested_t),
            "::",
            stringify!(m_rgchServer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchPassword) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(GameServerChangeRequested_t),
            "::",
            stringify!(m_rgchPassword)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GameLobbyJoinRequested_t {
    pub m_steamIDLobby: CSteamID,
    pub m_steamIDFriend: CSteamID,
}
pub const GameLobbyJoinRequested_t_k_iCallback: GameLobbyJoinRequested_t__bindgen_ty_1 =
    GameLobbyJoinRequested_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GameLobbyJoinRequested_t__bindgen_ty_1 {
    k_iCallback = 333,
}
#[test]
fn bindgen_test_layout_GameLobbyJoinRequested_t() {
    const UNINIT: ::std::mem::MaybeUninit<GameLobbyJoinRequested_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GameLobbyJoinRequested_t>(),
        16usize,
        concat!("Size of: ", stringify!(GameLobbyJoinRequested_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GameLobbyJoinRequested_t>(),
        1usize,
        concat!("Alignment of ", stringify!(GameLobbyJoinRequested_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDLobby) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GameLobbyJoinRequested_t),
            "::",
            stringify!(m_steamIDLobby)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDFriend) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GameLobbyJoinRequested_t),
            "::",
            stringify!(m_steamIDFriend)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AvatarImageLoaded_t {
    pub m_steamID: CSteamID,
    pub m_iImage: ::std::os::raw::c_int,
    pub m_iWide: ::std::os::raw::c_int,
    pub m_iTall: ::std::os::raw::c_int,
}
pub const AvatarImageLoaded_t_k_iCallback: AvatarImageLoaded_t__bindgen_ty_1 =
    AvatarImageLoaded_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AvatarImageLoaded_t__bindgen_ty_1 {
    k_iCallback = 334,
}
#[test]
fn bindgen_test_layout_AvatarImageLoaded_t() {
    const UNINIT: ::std::mem::MaybeUninit<AvatarImageLoaded_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AvatarImageLoaded_t>(),
        20usize,
        concat!("Size of: ", stringify!(AvatarImageLoaded_t))
    );
    assert_eq!(
        ::std::mem::align_of::<AvatarImageLoaded_t>(),
        4usize,
        concat!("Alignment of ", stringify!(AvatarImageLoaded_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AvatarImageLoaded_t),
            "::",
            stringify!(m_steamID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_iImage) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AvatarImageLoaded_t),
            "::",
            stringify!(m_iImage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_iWide) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AvatarImageLoaded_t),
            "::",
            stringify!(m_iWide)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_iTall) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AvatarImageLoaded_t),
            "::",
            stringify!(m_iTall)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ClanOfficerListResponse_t {
    pub m_steamIDClan: CSteamID,
    pub m_cOfficers: ::std::os::raw::c_int,
    pub m_bSuccess: uint8,
}
pub const ClanOfficerListResponse_t_k_iCallback: ClanOfficerListResponse_t__bindgen_ty_1 =
    ClanOfficerListResponse_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ClanOfficerListResponse_t__bindgen_ty_1 {
    k_iCallback = 335,
}
#[test]
fn bindgen_test_layout_ClanOfficerListResponse_t() {
    const UNINIT: ::std::mem::MaybeUninit<ClanOfficerListResponse_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClanOfficerListResponse_t>(),
        16usize,
        concat!("Size of: ", stringify!(ClanOfficerListResponse_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ClanOfficerListResponse_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ClanOfficerListResponse_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDClan) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClanOfficerListResponse_t),
            "::",
            stringify!(m_steamIDClan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cOfficers) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClanOfficerListResponse_t),
            "::",
            stringify!(m_cOfficers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bSuccess) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ClanOfficerListResponse_t),
            "::",
            stringify!(m_bSuccess)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FriendRichPresenceUpdate_t {
    pub m_steamIDFriend: CSteamID,
    pub m_nAppID: AppId_t,
}
pub const FriendRichPresenceUpdate_t_k_iCallback: FriendRichPresenceUpdate_t__bindgen_ty_1 =
    FriendRichPresenceUpdate_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum FriendRichPresenceUpdate_t__bindgen_ty_1 {
    k_iCallback = 336,
}
#[test]
fn bindgen_test_layout_FriendRichPresenceUpdate_t() {
    const UNINIT: ::std::mem::MaybeUninit<FriendRichPresenceUpdate_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FriendRichPresenceUpdate_t>(),
        12usize,
        concat!("Size of: ", stringify!(FriendRichPresenceUpdate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<FriendRichPresenceUpdate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(FriendRichPresenceUpdate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDFriend) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendRichPresenceUpdate_t),
            "::",
            stringify!(m_steamIDFriend)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nAppID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendRichPresenceUpdate_t),
            "::",
            stringify!(m_nAppID)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GameRichPresenceJoinRequested_t {
    pub m_steamIDFriend: CSteamID,
    pub m_rgchConnect: [::std::os::raw::c_char; 256usize],
}
pub const GameRichPresenceJoinRequested_t_k_iCallback:
    GameRichPresenceJoinRequested_t__bindgen_ty_1 =
    GameRichPresenceJoinRequested_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GameRichPresenceJoinRequested_t__bindgen_ty_1 {
    k_iCallback = 337,
}
#[test]
fn bindgen_test_layout_GameRichPresenceJoinRequested_t() {
    const UNINIT: ::std::mem::MaybeUninit<GameRichPresenceJoinRequested_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GameRichPresenceJoinRequested_t>(),
        264usize,
        concat!("Size of: ", stringify!(GameRichPresenceJoinRequested_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GameRichPresenceJoinRequested_t>(),
        1usize,
        concat!("Alignment of ", stringify!(GameRichPresenceJoinRequested_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDFriend) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GameRichPresenceJoinRequested_t),
            "::",
            stringify!(m_steamIDFriend)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchConnect) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GameRichPresenceJoinRequested_t),
            "::",
            stringify!(m_rgchConnect)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GameConnectedClanChatMsg_t {
    pub m_steamIDClanChat: CSteamID,
    pub m_steamIDUser: CSteamID,
    pub m_iMessageID: ::std::os::raw::c_int,
}
pub const GameConnectedClanChatMsg_t_k_iCallback: GameConnectedClanChatMsg_t__bindgen_ty_1 =
    GameConnectedClanChatMsg_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GameConnectedClanChatMsg_t__bindgen_ty_1 {
    k_iCallback = 338,
}
#[test]
fn bindgen_test_layout_GameConnectedClanChatMsg_t() {
    const UNINIT: ::std::mem::MaybeUninit<GameConnectedClanChatMsg_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GameConnectedClanChatMsg_t>(),
        20usize,
        concat!("Size of: ", stringify!(GameConnectedClanChatMsg_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GameConnectedClanChatMsg_t>(),
        4usize,
        concat!("Alignment of ", stringify!(GameConnectedClanChatMsg_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDClanChat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GameConnectedClanChatMsg_t),
            "::",
            stringify!(m_steamIDClanChat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDUser) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GameConnectedClanChatMsg_t),
            "::",
            stringify!(m_steamIDUser)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_iMessageID) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GameConnectedClanChatMsg_t),
            "::",
            stringify!(m_iMessageID)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GameConnectedChatJoin_t {
    pub m_steamIDClanChat: CSteamID,
    pub m_steamIDUser: CSteamID,
}
pub const GameConnectedChatJoin_t_k_iCallback: GameConnectedChatJoin_t__bindgen_ty_1 =
    GameConnectedChatJoin_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GameConnectedChatJoin_t__bindgen_ty_1 {
    k_iCallback = 339,
}
#[test]
fn bindgen_test_layout_GameConnectedChatJoin_t() {
    const UNINIT: ::std::mem::MaybeUninit<GameConnectedChatJoin_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GameConnectedChatJoin_t>(),
        16usize,
        concat!("Size of: ", stringify!(GameConnectedChatJoin_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GameConnectedChatJoin_t>(),
        1usize,
        concat!("Alignment of ", stringify!(GameConnectedChatJoin_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDClanChat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GameConnectedChatJoin_t),
            "::",
            stringify!(m_steamIDClanChat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDUser) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GameConnectedChatJoin_t),
            "::",
            stringify!(m_steamIDUser)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GameConnectedChatLeave_t {
    pub m_steamIDClanChat: CSteamID,
    pub m_steamIDUser: CSteamID,
    pub m_bKicked: bool,
    pub m_bDropped: bool,
}
pub const GameConnectedChatLeave_t_k_iCallback: GameConnectedChatLeave_t__bindgen_ty_1 =
    GameConnectedChatLeave_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GameConnectedChatLeave_t__bindgen_ty_1 {
    k_iCallback = 340,
}
#[test]
fn bindgen_test_layout_GameConnectedChatLeave_t() {
    const UNINIT: ::std::mem::MaybeUninit<GameConnectedChatLeave_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GameConnectedChatLeave_t>(),
        18usize,
        concat!("Size of: ", stringify!(GameConnectedChatLeave_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GameConnectedChatLeave_t>(),
        1usize,
        concat!("Alignment of ", stringify!(GameConnectedChatLeave_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDClanChat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GameConnectedChatLeave_t),
            "::",
            stringify!(m_steamIDClanChat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDUser) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GameConnectedChatLeave_t),
            "::",
            stringify!(m_steamIDUser)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bKicked) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GameConnectedChatLeave_t),
            "::",
            stringify!(m_bKicked)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bDropped) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(GameConnectedChatLeave_t),
            "::",
            stringify!(m_bDropped)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DownloadClanActivityCountsResult_t {
    pub m_bSuccess: bool,
}
pub const DownloadClanActivityCountsResult_t_k_iCallback:
    DownloadClanActivityCountsResult_t__bindgen_ty_1 =
    DownloadClanActivityCountsResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum DownloadClanActivityCountsResult_t__bindgen_ty_1 {
    k_iCallback = 341,
}
#[test]
fn bindgen_test_layout_DownloadClanActivityCountsResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<DownloadClanActivityCountsResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DownloadClanActivityCountsResult_t>(),
        1usize,
        concat!("Size of: ", stringify!(DownloadClanActivityCountsResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<DownloadClanActivityCountsResult_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(DownloadClanActivityCountsResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bSuccess) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DownloadClanActivityCountsResult_t),
            "::",
            stringify!(m_bSuccess)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct JoinClanChatRoomCompletionResult_t {
    pub m_steamIDClanChat: CSteamID,
    pub m_eChatRoomEnterResponse: EChatRoomEnterResponse,
}
pub const JoinClanChatRoomCompletionResult_t_k_iCallback:
    JoinClanChatRoomCompletionResult_t__bindgen_ty_1 =
    JoinClanChatRoomCompletionResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum JoinClanChatRoomCompletionResult_t__bindgen_ty_1 {
    k_iCallback = 342,
}
#[test]
fn bindgen_test_layout_JoinClanChatRoomCompletionResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<JoinClanChatRoomCompletionResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JoinClanChatRoomCompletionResult_t>(),
        12usize,
        concat!("Size of: ", stringify!(JoinClanChatRoomCompletionResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<JoinClanChatRoomCompletionResult_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(JoinClanChatRoomCompletionResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDClanChat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JoinClanChatRoomCompletionResult_t),
            "::",
            stringify!(m_steamIDClanChat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eChatRoomEnterResponse) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JoinClanChatRoomCompletionResult_t),
            "::",
            stringify!(m_eChatRoomEnterResponse)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GameConnectedFriendChatMsg_t {
    pub m_steamIDUser: CSteamID,
    pub m_iMessageID: ::std::os::raw::c_int,
}
pub const GameConnectedFriendChatMsg_t_k_iCallback: GameConnectedFriendChatMsg_t__bindgen_ty_1 =
    GameConnectedFriendChatMsg_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GameConnectedFriendChatMsg_t__bindgen_ty_1 {
    k_iCallback = 343,
}
#[test]
fn bindgen_test_layout_GameConnectedFriendChatMsg_t() {
    const UNINIT: ::std::mem::MaybeUninit<GameConnectedFriendChatMsg_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GameConnectedFriendChatMsg_t>(),
        12usize,
        concat!("Size of: ", stringify!(GameConnectedFriendChatMsg_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GameConnectedFriendChatMsg_t>(),
        4usize,
        concat!("Alignment of ", stringify!(GameConnectedFriendChatMsg_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDUser) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GameConnectedFriendChatMsg_t),
            "::",
            stringify!(m_steamIDUser)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_iMessageID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GameConnectedFriendChatMsg_t),
            "::",
            stringify!(m_iMessageID)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FriendsGetFollowerCount_t {
    pub m_eResult: EResult,
    pub m_steamID: CSteamID,
    pub m_nCount: ::std::os::raw::c_int,
}
pub const FriendsGetFollowerCount_t_k_iCallback: FriendsGetFollowerCount_t__bindgen_ty_1 =
    FriendsGetFollowerCount_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum FriendsGetFollowerCount_t__bindgen_ty_1 {
    k_iCallback = 344,
}
#[test]
fn bindgen_test_layout_FriendsGetFollowerCount_t() {
    const UNINIT: ::std::mem::MaybeUninit<FriendsGetFollowerCount_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FriendsGetFollowerCount_t>(),
        16usize,
        concat!("Size of: ", stringify!(FriendsGetFollowerCount_t))
    );
    assert_eq!(
        ::std::mem::align_of::<FriendsGetFollowerCount_t>(),
        4usize,
        concat!("Alignment of ", stringify!(FriendsGetFollowerCount_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendsGetFollowerCount_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendsGetFollowerCount_t),
            "::",
            stringify!(m_steamID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nCount) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendsGetFollowerCount_t),
            "::",
            stringify!(m_nCount)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FriendsIsFollowing_t {
    pub m_eResult: EResult,
    pub m_steamID: CSteamID,
    pub m_bIsFollowing: bool,
}
pub const FriendsIsFollowing_t_k_iCallback: FriendsIsFollowing_t__bindgen_ty_1 =
    FriendsIsFollowing_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum FriendsIsFollowing_t__bindgen_ty_1 {
    k_iCallback = 345,
}
#[test]
fn bindgen_test_layout_FriendsIsFollowing_t() {
    const UNINIT: ::std::mem::MaybeUninit<FriendsIsFollowing_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FriendsIsFollowing_t>(),
        16usize,
        concat!("Size of: ", stringify!(FriendsIsFollowing_t))
    );
    assert_eq!(
        ::std::mem::align_of::<FriendsIsFollowing_t>(),
        4usize,
        concat!("Alignment of ", stringify!(FriendsIsFollowing_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendsIsFollowing_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendsIsFollowing_t),
            "::",
            stringify!(m_steamID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bIsFollowing) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendsIsFollowing_t),
            "::",
            stringify!(m_bIsFollowing)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FriendsEnumerateFollowingList_t {
    pub m_eResult: EResult,
    pub m_rgSteamID: [CSteamID; 50usize],
    pub m_nResultsReturned: int32,
    pub m_nTotalResultCount: int32,
}
pub const FriendsEnumerateFollowingList_t_k_iCallback:
    FriendsEnumerateFollowingList_t__bindgen_ty_1 =
    FriendsEnumerateFollowingList_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum FriendsEnumerateFollowingList_t__bindgen_ty_1 {
    k_iCallback = 346,
}
#[test]
fn bindgen_test_layout_FriendsEnumerateFollowingList_t() {
    const UNINIT: ::std::mem::MaybeUninit<FriendsEnumerateFollowingList_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FriendsEnumerateFollowingList_t>(),
        412usize,
        concat!("Size of: ", stringify!(FriendsEnumerateFollowingList_t))
    );
    assert_eq!(
        ::std::mem::align_of::<FriendsEnumerateFollowingList_t>(),
        4usize,
        concat!("Alignment of ", stringify!(FriendsEnumerateFollowingList_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendsEnumerateFollowingList_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgSteamID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendsEnumerateFollowingList_t),
            "::",
            stringify!(m_rgSteamID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nResultsReturned) as usize - ptr as usize },
        404usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendsEnumerateFollowingList_t),
            "::",
            stringify!(m_nResultsReturned)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nTotalResultCount) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendsEnumerateFollowingList_t),
            "::",
            stringify!(m_nTotalResultCount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UnreadChatMessagesChanged_t {
    pub _address: u8,
}
pub const UnreadChatMessagesChanged_t_k_iCallback: UnreadChatMessagesChanged_t__bindgen_ty_1 =
    UnreadChatMessagesChanged_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum UnreadChatMessagesChanged_t__bindgen_ty_1 {
    k_iCallback = 348,
}
#[test]
fn bindgen_test_layout_UnreadChatMessagesChanged_t() {
    assert_eq!(
        ::std::mem::size_of::<UnreadChatMessagesChanged_t>(),
        1usize,
        concat!("Size of: ", stringify!(UnreadChatMessagesChanged_t))
    );
    assert_eq!(
        ::std::mem::align_of::<UnreadChatMessagesChanged_t>(),
        1usize,
        concat!("Alignment of ", stringify!(UnreadChatMessagesChanged_t))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OverlayBrowserProtocolNavigation_t {
    pub rgchURI: [::std::os::raw::c_char; 1024usize],
}
pub const OverlayBrowserProtocolNavigation_t_k_iCallback:
    OverlayBrowserProtocolNavigation_t__bindgen_ty_1 =
    OverlayBrowserProtocolNavigation_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum OverlayBrowserProtocolNavigation_t__bindgen_ty_1 {
    k_iCallback = 349,
}
#[test]
fn bindgen_test_layout_OverlayBrowserProtocolNavigation_t() {
    const UNINIT: ::std::mem::MaybeUninit<OverlayBrowserProtocolNavigation_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OverlayBrowserProtocolNavigation_t>(),
        1024usize,
        concat!("Size of: ", stringify!(OverlayBrowserProtocolNavigation_t))
    );
    assert_eq!(
        ::std::mem::align_of::<OverlayBrowserProtocolNavigation_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(OverlayBrowserProtocolNavigation_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rgchURI) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OverlayBrowserProtocolNavigation_t),
            "::",
            stringify!(rgchURI)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct EquippedProfileItemsChanged_t {
    pub m_steamID: CSteamID,
}
pub const EquippedProfileItemsChanged_t_k_iCallback: EquippedProfileItemsChanged_t__bindgen_ty_1 =
    EquippedProfileItemsChanged_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EquippedProfileItemsChanged_t__bindgen_ty_1 {
    k_iCallback = 350,
}
#[test]
fn bindgen_test_layout_EquippedProfileItemsChanged_t() {
    const UNINIT: ::std::mem::MaybeUninit<EquippedProfileItemsChanged_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<EquippedProfileItemsChanged_t>(),
        8usize,
        concat!("Size of: ", stringify!(EquippedProfileItemsChanged_t))
    );
    assert_eq!(
        ::std::mem::align_of::<EquippedProfileItemsChanged_t>(),
        1usize,
        concat!("Alignment of ", stringify!(EquippedProfileItemsChanged_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EquippedProfileItemsChanged_t),
            "::",
            stringify!(m_steamID)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct EquippedProfileItems_t {
    pub m_eResult: EResult,
    pub m_steamID: CSteamID,
    pub m_bHasAnimatedAvatar: bool,
    pub m_bHasAvatarFrame: bool,
    pub m_bHasProfileModifier: bool,
    pub m_bHasProfileBackground: bool,
    pub m_bHasMiniProfileBackground: bool,
    pub m_bFromCache: bool,
}
pub const EquippedProfileItems_t_k_iCallback: EquippedProfileItems_t__bindgen_ty_1 =
    EquippedProfileItems_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EquippedProfileItems_t__bindgen_ty_1 {
    k_iCallback = 351,
}
#[test]
fn bindgen_test_layout_EquippedProfileItems_t() {
    const UNINIT: ::std::mem::MaybeUninit<EquippedProfileItems_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<EquippedProfileItems_t>(),
        20usize,
        concat!("Size of: ", stringify!(EquippedProfileItems_t))
    );
    assert_eq!(
        ::std::mem::align_of::<EquippedProfileItems_t>(),
        4usize,
        concat!("Alignment of ", stringify!(EquippedProfileItems_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EquippedProfileItems_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(EquippedProfileItems_t),
            "::",
            stringify!(m_steamID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bHasAnimatedAvatar) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(EquippedProfileItems_t),
            "::",
            stringify!(m_bHasAnimatedAvatar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bHasAvatarFrame) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(EquippedProfileItems_t),
            "::",
            stringify!(m_bHasAvatarFrame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bHasProfileModifier) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(EquippedProfileItems_t),
            "::",
            stringify!(m_bHasProfileModifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bHasProfileBackground) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(EquippedProfileItems_t),
            "::",
            stringify!(m_bHasProfileBackground)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bHasMiniProfileBackground) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EquippedProfileItems_t),
            "::",
            stringify!(m_bHasMiniProfileBackground)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bFromCache) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(EquippedProfileItems_t),
            "::",
            stringify!(m_bFromCache)
        )
    );
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamAPICallFailure {
    k_ESteamAPICallFailureNone = -1,
    k_ESteamAPICallFailureSteamGone = 0,
    k_ESteamAPICallFailureNetworkFailure = 1,
    k_ESteamAPICallFailureInvalidHandle = 2,
    k_ESteamAPICallFailureMismatchedCallback = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EGamepadTextInputMode {
    k_EGamepadTextInputModeNormal = 0,
    k_EGamepadTextInputModePassword = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EGamepadTextInputLineMode {
    k_EGamepadTextInputLineModeSingleLine = 0,
    k_EGamepadTextInputLineModeMultipleLines = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EFloatingGamepadTextInputMode {
    k_EFloatingGamepadTextInputModeModeSingleLine = 0,
    k_EFloatingGamepadTextInputModeModeMultipleLines = 1,
    k_EFloatingGamepadTextInputModeModeEmail = 2,
    k_EFloatingGamepadTextInputModeModeNumeric = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ETextFilteringContext {
    k_ETextFilteringContextUnknown = 0,
    k_ETextFilteringContextGameContent = 1,
    k_ETextFilteringContextChat = 2,
    k_ETextFilteringContextName = 3,
}
#[repr(C)]
pub struct ISteamUtils__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamUtils {
    pub vtable_: *const ISteamUtils__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamUtils() {
    assert_eq!(
        ::std::mem::size_of::<ISteamUtils>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamUtils))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamUtils>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamUtils))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPCountry_t {
    pub _address: u8,
}
pub const IPCountry_t_k_iCallback: IPCountry_t__bindgen_ty_1 =
    IPCountry_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IPCountry_t__bindgen_ty_1 {
    k_iCallback = 701,
}
#[test]
fn bindgen_test_layout_IPCountry_t() {
    assert_eq!(
        ::std::mem::size_of::<IPCountry_t>(),
        1usize,
        concat!("Size of: ", stringify!(IPCountry_t))
    );
    assert_eq!(
        ::std::mem::align_of::<IPCountry_t>(),
        1usize,
        concat!("Alignment of ", stringify!(IPCountry_t))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LowBatteryPower_t {
    pub m_nMinutesBatteryLeft: uint8,
}
pub const LowBatteryPower_t_k_iCallback: LowBatteryPower_t__bindgen_ty_1 =
    LowBatteryPower_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum LowBatteryPower_t__bindgen_ty_1 {
    k_iCallback = 702,
}
#[test]
fn bindgen_test_layout_LowBatteryPower_t() {
    const UNINIT: ::std::mem::MaybeUninit<LowBatteryPower_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LowBatteryPower_t>(),
        1usize,
        concat!("Size of: ", stringify!(LowBatteryPower_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LowBatteryPower_t>(),
        1usize,
        concat!("Alignment of ", stringify!(LowBatteryPower_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nMinutesBatteryLeft) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LowBatteryPower_t),
            "::",
            stringify!(m_nMinutesBatteryLeft)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct SteamAPICallCompleted_t {
    pub m_hAsyncCall: SteamAPICall_t,
    pub m_iCallback: ::std::os::raw::c_int,
    pub m_cubParam: uint32,
}
pub const SteamAPICallCompleted_t_k_iCallback: SteamAPICallCompleted_t__bindgen_ty_1 =
    SteamAPICallCompleted_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamAPICallCompleted_t__bindgen_ty_1 {
    k_iCallback = 703,
}
#[test]
fn bindgen_test_layout_SteamAPICallCompleted_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamAPICallCompleted_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamAPICallCompleted_t>(),
        16usize,
        concat!("Size of: ", stringify!(SteamAPICallCompleted_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamAPICallCompleted_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamAPICallCompleted_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hAsyncCall) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamAPICallCompleted_t),
            "::",
            stringify!(m_hAsyncCall)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_iCallback) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamAPICallCompleted_t),
            "::",
            stringify!(m_iCallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cubParam) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamAPICallCompleted_t),
            "::",
            stringify!(m_cubParam)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamShutdown_t {
    pub _address: u8,
}
pub const SteamShutdown_t_k_iCallback: SteamShutdown_t__bindgen_ty_1 =
    SteamShutdown_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamShutdown_t__bindgen_ty_1 {
    k_iCallback = 704,
}
#[test]
fn bindgen_test_layout_SteamShutdown_t() {
    assert_eq!(
        ::std::mem::size_of::<SteamShutdown_t>(),
        1usize,
        concat!("Size of: ", stringify!(SteamShutdown_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamShutdown_t>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamShutdown_t))
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ECheckFileSignature {
    k_ECheckFileSignatureInvalidSignature = 0,
    k_ECheckFileSignatureValidSignature = 1,
    k_ECheckFileSignatureFileNotFound = 2,
    k_ECheckFileSignatureNoSignaturesFoundForThisApp = 3,
    k_ECheckFileSignatureNoSignaturesFoundForThisFile = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CheckFileSignature_t {
    pub m_eCheckFileSignature: ECheckFileSignature,
}
pub const CheckFileSignature_t_k_iCallback: CheckFileSignature_t__bindgen_ty_1 =
    CheckFileSignature_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CheckFileSignature_t__bindgen_ty_1 {
    k_iCallback = 705,
}
#[test]
fn bindgen_test_layout_CheckFileSignature_t() {
    const UNINIT: ::std::mem::MaybeUninit<CheckFileSignature_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CheckFileSignature_t>(),
        4usize,
        concat!("Size of: ", stringify!(CheckFileSignature_t))
    );
    assert_eq!(
        ::std::mem::align_of::<CheckFileSignature_t>(),
        4usize,
        concat!("Alignment of ", stringify!(CheckFileSignature_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eCheckFileSignature) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CheckFileSignature_t),
            "::",
            stringify!(m_eCheckFileSignature)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GamepadTextInputDismissed_t {
    pub m_bSubmitted: bool,
    pub m_unSubmittedText: uint32,
    pub m_unAppID: AppId_t,
}
pub const GamepadTextInputDismissed_t_k_iCallback: GamepadTextInputDismissed_t__bindgen_ty_1 =
    GamepadTextInputDismissed_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GamepadTextInputDismissed_t__bindgen_ty_1 {
    k_iCallback = 714,
}
#[test]
fn bindgen_test_layout_GamepadTextInputDismissed_t() {
    const UNINIT: ::std::mem::MaybeUninit<GamepadTextInputDismissed_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GamepadTextInputDismissed_t>(),
        12usize,
        concat!("Size of: ", stringify!(GamepadTextInputDismissed_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GamepadTextInputDismissed_t>(),
        4usize,
        concat!("Alignment of ", stringify!(GamepadTextInputDismissed_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bSubmitted) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GamepadTextInputDismissed_t),
            "::",
            stringify!(m_bSubmitted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unSubmittedText) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GamepadTextInputDismissed_t),
            "::",
            stringify!(m_unSubmittedText)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unAppID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GamepadTextInputDismissed_t),
            "::",
            stringify!(m_unAppID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AppResumingFromSuspend_t {
    pub _address: u8,
}
pub const AppResumingFromSuspend_t_k_iCallback: AppResumingFromSuspend_t__bindgen_ty_1 =
    AppResumingFromSuspend_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AppResumingFromSuspend_t__bindgen_ty_1 {
    k_iCallback = 736,
}
#[test]
fn bindgen_test_layout_AppResumingFromSuspend_t() {
    assert_eq!(
        ::std::mem::size_of::<AppResumingFromSuspend_t>(),
        1usize,
        concat!("Size of: ", stringify!(AppResumingFromSuspend_t))
    );
    assert_eq!(
        ::std::mem::align_of::<AppResumingFromSuspend_t>(),
        1usize,
        concat!("Alignment of ", stringify!(AppResumingFromSuspend_t))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FloatingGamepadTextInputDismissed_t {
    pub _address: u8,
}
pub const FloatingGamepadTextInputDismissed_t_k_iCallback:
    FloatingGamepadTextInputDismissed_t__bindgen_ty_1 =
    FloatingGamepadTextInputDismissed_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum FloatingGamepadTextInputDismissed_t__bindgen_ty_1 {
    k_iCallback = 738,
}
#[test]
fn bindgen_test_layout_FloatingGamepadTextInputDismissed_t() {
    assert_eq!(
        ::std::mem::size_of::<FloatingGamepadTextInputDismissed_t>(),
        1usize,
        concat!("Size of: ", stringify!(FloatingGamepadTextInputDismissed_t))
    );
    assert_eq!(
        ::std::mem::align_of::<FloatingGamepadTextInputDismissed_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(FloatingGamepadTextInputDismissed_t)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FilterTextDictionaryChanged_t {
    pub m_eLanguage: ::std::os::raw::c_int,
}
pub const FilterTextDictionaryChanged_t_k_iCallback: FilterTextDictionaryChanged_t__bindgen_ty_1 =
    FilterTextDictionaryChanged_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum FilterTextDictionaryChanged_t__bindgen_ty_1 {
    k_iCallback = 739,
}
#[test]
fn bindgen_test_layout_FilterTextDictionaryChanged_t() {
    const UNINIT: ::std::mem::MaybeUninit<FilterTextDictionaryChanged_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FilterTextDictionaryChanged_t>(),
        4usize,
        concat!("Size of: ", stringify!(FilterTextDictionaryChanged_t))
    );
    assert_eq!(
        ::std::mem::align_of::<FilterTextDictionaryChanged_t>(),
        4usize,
        concat!("Alignment of ", stringify!(FilterTextDictionaryChanged_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eLanguage) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FilterTextDictionaryChanged_t),
            "::",
            stringify!(m_eLanguage)
        )
    );
}
pub type __gnuc_va_list = __builtin_va_list;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos64_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_FILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type cookie_read_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_write_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_seek_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type cookie_close_function_t = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
#[test]
fn bindgen_test_layout__IO_cookie_io_functions_t() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_cookie_io_functions_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_cookie_io_functions_t>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_cookie_io_functions_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(close)
        )
    );
}
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub type va_list = __gnuc_va_list;
pub type off_t = __off_t;
pub type off64_t = __off64_t;
pub type fpos_t = __fpos_t;
pub type fpos64_t = __fpos64_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obstack {
    _unused: [u8; 0],
}
pub const k_cbMaxGameServerGameDir: ::std::os::raw::c_int = 32;
pub const k_cbMaxGameServerMapName: ::std::os::raw::c_int = 32;
pub const k_cbMaxGameServerGameDescription: ::std::os::raw::c_int = 64;
pub const k_cbMaxGameServerName: ::std::os::raw::c_int = 64;
pub const k_cbMaxGameServerTags: ::std::os::raw::c_int = 128;
pub const k_cbMaxGameServerGameData: ::std::os::raw::c_int = 2048;
#[doc = " Store key/value pair used in matchmaking queries.\n\n Actually, the name Key/Value is a bit misleading.  The \"key\" is better\n understood as \"filter operation code\" and the \"value\" is the operand to this\n filter operation.  The meaning of the operand depends upon the filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MatchMakingKeyValuePair_t {
    pub m_szKey: [::std::os::raw::c_char; 256usize],
    pub m_szValue: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_MatchMakingKeyValuePair_t() {
    const UNINIT: ::std::mem::MaybeUninit<MatchMakingKeyValuePair_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MatchMakingKeyValuePair_t>(),
        512usize,
        concat!("Size of: ", stringify!(MatchMakingKeyValuePair_t))
    );
    assert_eq!(
        ::std::mem::align_of::<MatchMakingKeyValuePair_t>(),
        1usize,
        concat!("Alignment of ", stringify!(MatchMakingKeyValuePair_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MatchMakingKeyValuePair_t),
            "::",
            stringify!(m_szKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szValue) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(MatchMakingKeyValuePair_t),
            "::",
            stringify!(m_szValue)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EMatchMakingServerResponse {
    eServerResponded = 0,
    eServerFailedToRespond = 1,
    eNoServersListedOnMasterServer = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct servernetadr_t {
    pub m_usConnectionPort: uint16,
    pub m_usQueryPort: uint16,
    pub m_unIP: uint32,
}
#[test]
fn bindgen_test_layout_servernetadr_t() {
    const UNINIT: ::std::mem::MaybeUninit<servernetadr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<servernetadr_t>(),
        8usize,
        concat!("Size of: ", stringify!(servernetadr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<servernetadr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(servernetadr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_usConnectionPort) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(servernetadr_t),
            "::",
            stringify!(m_usConnectionPort)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_usQueryPort) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(servernetadr_t),
            "::",
            stringify!(m_usQueryPort)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unIP) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(servernetadr_t),
            "::",
            stringify!(m_unIP)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gameserveritem_t {
    #[doc = "< IP/Query Port/Connection Port for this server"]
    pub m_NetAdr: servernetadr_t,
    #[doc = "< current ping time in milliseconds"]
    pub m_nPing: ::std::os::raw::c_int,
    #[doc = "< server has responded successfully in the past"]
    pub m_bHadSuccessfulResponse: bool,
    #[doc = "< server is marked as not responding and should no longer be refreshed"]
    pub m_bDoNotRefresh: bool,
    #[doc = "< current game directory"]
    pub m_szGameDir: [::std::os::raw::c_char; 32usize],
    #[doc = "< current map"]
    pub m_szMap: [::std::os::raw::c_char; 32usize],
    #[doc = "< game description"]
    pub m_szGameDescription: [::std::os::raw::c_char; 64usize],
    #[doc = "< Steam App ID of this server"]
    pub m_nAppID: uint32,
    #[doc = "< total number of players currently on the server.  INCLUDES BOTS!!"]
    pub m_nPlayers: ::std::os::raw::c_int,
    #[doc = "< Maximum players that can join this server"]
    pub m_nMaxPlayers: ::std::os::raw::c_int,
    #[doc = "< Number of bots (i.e simulated players) on this server"]
    pub m_nBotPlayers: ::std::os::raw::c_int,
    #[doc = "< true if this server needs a password to join"]
    pub m_bPassword: bool,
    #[doc = "< Is this server protected by VAC"]
    pub m_bSecure: bool,
    #[doc = "< time (in unix time) when this server was last played on (for favorite/history servers)"]
    pub m_ulTimeLastPlayed: uint32,
    #[doc = "< server version as reported to Steam"]
    pub m_nServerVersion: ::std::os::raw::c_int,
    #[doc = " Game server name"]
    pub m_szServerName: [::std::os::raw::c_char; 64usize],
    #[doc = " the tags this server exposes"]
    pub m_szGameTags: [::std::os::raw::c_char; 128usize],
    #[doc = " steamID of the game server - invalid if it's doesn't have one (old server, or not connected to Steam)"]
    pub m_steamID: CSteamID,
}
#[test]
fn bindgen_test_layout_gameserveritem_t() {
    const UNINIT: ::std::mem::MaybeUninit<gameserveritem_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gameserveritem_t>(),
        372usize,
        concat!("Size of: ", stringify!(gameserveritem_t))
    );
    assert_eq!(
        ::std::mem::align_of::<gameserveritem_t>(),
        4usize,
        concat!("Alignment of ", stringify!(gameserveritem_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_NetAdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_NetAdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPing) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_nPing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bHadSuccessfulResponse) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_bHadSuccessfulResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bDoNotRefresh) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_bDoNotRefresh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szGameDir) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_szGameDir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szMap) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_szMap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szGameDescription) as usize - ptr as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_szGameDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nAppID) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_nAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPlayers) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_nPlayers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nMaxPlayers) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_nMaxPlayers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nBotPlayers) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_nBotPlayers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bPassword) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_bPassword)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bSecure) as usize - ptr as usize },
        161usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_bSecure)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulTimeLastPlayed) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_ulTimeLastPlayed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nServerVersion) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_nServerVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szServerName) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_szServerName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szGameTags) as usize - ptr as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_szGameTags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamID) as usize - ptr as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_steamID)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ELobbyType {
    k_ELobbyTypePrivate = 0,
    k_ELobbyTypeFriendsOnly = 1,
    k_ELobbyTypePublic = 2,
    k_ELobbyTypeInvisible = 3,
    k_ELobbyTypePrivateUnique = 4,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ELobbyComparison {
    k_ELobbyComparisonEqualToOrLessThan = -2,
    k_ELobbyComparisonLessThan = -1,
    k_ELobbyComparisonEqual = 0,
    k_ELobbyComparisonGreaterThan = 1,
    k_ELobbyComparisonEqualToOrGreaterThan = 2,
    k_ELobbyComparisonNotEqual = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ELobbyDistanceFilter {
    k_ELobbyDistanceFilterClose = 0,
    k_ELobbyDistanceFilterDefault = 1,
    k_ELobbyDistanceFilterFar = 2,
    k_ELobbyDistanceFilterWorldwide = 3,
}
#[repr(C)]
pub struct ISteamMatchmaking__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamMatchmaking {
    pub vtable_: *const ISteamMatchmaking__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamMatchmaking() {
    assert_eq!(
        ::std::mem::size_of::<ISteamMatchmaking>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamMatchmaking))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamMatchmaking>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamMatchmaking))
    );
}
pub type HServerListRequest = *mut ::std::os::raw::c_void;
#[repr(C)]
pub struct ISteamMatchmakingServerListResponse__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamMatchmakingServerListResponse {
    pub vtable_: *const ISteamMatchmakingServerListResponse__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamMatchmakingServerListResponse() {
    assert_eq!(
        ::std::mem::size_of::<ISteamMatchmakingServerListResponse>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamMatchmakingServerListResponse))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamMatchmakingServerListResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ISteamMatchmakingServerListResponse)
        )
    );
}
#[repr(C)]
pub struct ISteamMatchmakingPingResponse__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamMatchmakingPingResponse {
    pub vtable_: *const ISteamMatchmakingPingResponse__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamMatchmakingPingResponse() {
    assert_eq!(
        ::std::mem::size_of::<ISteamMatchmakingPingResponse>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamMatchmakingPingResponse))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamMatchmakingPingResponse>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamMatchmakingPingResponse))
    );
}
#[repr(C)]
pub struct ISteamMatchmakingPlayersResponse__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamMatchmakingPlayersResponse {
    pub vtable_: *const ISteamMatchmakingPlayersResponse__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamMatchmakingPlayersResponse() {
    assert_eq!(
        ::std::mem::size_of::<ISteamMatchmakingPlayersResponse>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamMatchmakingPlayersResponse))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamMatchmakingPlayersResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ISteamMatchmakingPlayersResponse)
        )
    );
}
#[repr(C)]
pub struct ISteamMatchmakingRulesResponse__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamMatchmakingRulesResponse {
    pub vtable_: *const ISteamMatchmakingRulesResponse__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamMatchmakingRulesResponse() {
    assert_eq!(
        ::std::mem::size_of::<ISteamMatchmakingRulesResponse>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamMatchmakingRulesResponse))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamMatchmakingRulesResponse>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamMatchmakingRulesResponse))
    );
}
pub type HServerQuery = ::std::os::raw::c_int;
pub const HSERVERQUERY_INVALID: ::std::os::raw::c_int = -1;
#[repr(C)]
pub struct ISteamMatchmakingServers__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamMatchmakingServers {
    pub vtable_: *const ISteamMatchmakingServers__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamMatchmakingServers() {
    assert_eq!(
        ::std::mem::size_of::<ISteamMatchmakingServers>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamMatchmakingServers))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamMatchmakingServers>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamMatchmakingServers))
    );
}
pub const k_unFavoriteFlagNone: uint32 = 0;
pub const k_unFavoriteFlagFavorite: uint32 = 1;
pub const k_unFavoriteFlagHistory: uint32 = 2;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EChatMemberStateChange {
    k_EChatMemberStateChangeEntered = 1,
    k_EChatMemberStateChangeLeft = 2,
    k_EChatMemberStateChangeDisconnected = 4,
    k_EChatMemberStateChangeKicked = 8,
    k_EChatMemberStateChangeBanned = 16,
}
#[repr(C)]
pub struct ISteamGameSearch__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamGameSearch {
    pub vtable_: *const ISteamGameSearch__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamGameSearch() {
    assert_eq!(
        ::std::mem::size_of::<ISteamGameSearch>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamGameSearch))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamGameSearch>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamGameSearch))
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamPartyBeaconLocationType {
    k_ESteamPartyBeaconLocationType_Invalid = 0,
    k_ESteamPartyBeaconLocationType_ChatGroup = 1,
    k_ESteamPartyBeaconLocationType_Max = 2,
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct SteamPartyBeaconLocation_t {
    pub m_eType: ESteamPartyBeaconLocationType,
    pub m_ulLocationID: uint64,
}
#[test]
fn bindgen_test_layout_SteamPartyBeaconLocation_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamPartyBeaconLocation_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamPartyBeaconLocation_t>(),
        12usize,
        concat!("Size of: ", stringify!(SteamPartyBeaconLocation_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamPartyBeaconLocation_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamPartyBeaconLocation_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamPartyBeaconLocation_t),
            "::",
            stringify!(m_eType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulLocationID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamPartyBeaconLocation_t),
            "::",
            stringify!(m_ulLocationID)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamPartyBeaconLocationData {
    k_ESteamPartyBeaconLocationDataInvalid = 0,
    k_ESteamPartyBeaconLocationDataName = 1,
    k_ESteamPartyBeaconLocationDataIconURLSmall = 2,
    k_ESteamPartyBeaconLocationDataIconURLMedium = 3,
    k_ESteamPartyBeaconLocationDataIconURLLarge = 4,
}
#[repr(C)]
pub struct ISteamParties__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamParties {
    pub vtable_: *const ISteamParties__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamParties() {
    assert_eq!(
        ::std::mem::size_of::<ISteamParties>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamParties))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamParties>(),
        4usize,
        concat!("Alignment of ", stringify!(ISteamParties))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FavoritesListChanged_t {
    pub m_nIP: uint32,
    pub m_nQueryPort: uint32,
    pub m_nConnPort: uint32,
    pub m_nAppID: uint32,
    pub m_nFlags: uint32,
    pub m_bAdd: bool,
    pub m_unAccountId: AccountID_t,
}
pub const FavoritesListChanged_t_k_iCallback: FavoritesListChanged_t__bindgen_ty_1 =
    FavoritesListChanged_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum FavoritesListChanged_t__bindgen_ty_1 {
    k_iCallback = 502,
}
#[test]
fn bindgen_test_layout_FavoritesListChanged_t() {
    const UNINIT: ::std::mem::MaybeUninit<FavoritesListChanged_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FavoritesListChanged_t>(),
        28usize,
        concat!("Size of: ", stringify!(FavoritesListChanged_t))
    );
    assert_eq!(
        ::std::mem::align_of::<FavoritesListChanged_t>(),
        4usize,
        concat!("Alignment of ", stringify!(FavoritesListChanged_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nIP) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FavoritesListChanged_t),
            "::",
            stringify!(m_nIP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nQueryPort) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FavoritesListChanged_t),
            "::",
            stringify!(m_nQueryPort)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nConnPort) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FavoritesListChanged_t),
            "::",
            stringify!(m_nConnPort)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nAppID) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FavoritesListChanged_t),
            "::",
            stringify!(m_nAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nFlags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FavoritesListChanged_t),
            "::",
            stringify!(m_nFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bAdd) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FavoritesListChanged_t),
            "::",
            stringify!(m_bAdd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unAccountId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FavoritesListChanged_t),
            "::",
            stringify!(m_unAccountId)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct LobbyInvite_t {
    pub m_ulSteamIDUser: uint64,
    pub m_ulSteamIDLobby: uint64,
    pub m_ulGameID: uint64,
}
pub const LobbyInvite_t_k_iCallback: LobbyInvite_t__bindgen_ty_1 =
    LobbyInvite_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum LobbyInvite_t__bindgen_ty_1 {
    k_iCallback = 503,
}
#[test]
fn bindgen_test_layout_LobbyInvite_t() {
    const UNINIT: ::std::mem::MaybeUninit<LobbyInvite_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LobbyInvite_t>(),
        24usize,
        concat!("Size of: ", stringify!(LobbyInvite_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LobbyInvite_t>(),
        4usize,
        concat!("Alignment of ", stringify!(LobbyInvite_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDUser) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyInvite_t),
            "::",
            stringify!(m_ulSteamIDUser)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDLobby) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyInvite_t),
            "::",
            stringify!(m_ulSteamIDLobby)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulGameID) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyInvite_t),
            "::",
            stringify!(m_ulGameID)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct LobbyEnter_t {
    pub m_ulSteamIDLobby: uint64,
    pub m_rgfChatPermissions: uint32,
    pub m_bLocked: bool,
    pub m_EChatRoomEnterResponse: uint32,
}
pub const LobbyEnter_t_k_iCallback: LobbyEnter_t__bindgen_ty_1 =
    LobbyEnter_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum LobbyEnter_t__bindgen_ty_1 {
    k_iCallback = 504,
}
#[test]
fn bindgen_test_layout_LobbyEnter_t() {
    const UNINIT: ::std::mem::MaybeUninit<LobbyEnter_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LobbyEnter_t>(),
        20usize,
        concat!("Size of: ", stringify!(LobbyEnter_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LobbyEnter_t>(),
        4usize,
        concat!("Alignment of ", stringify!(LobbyEnter_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDLobby) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyEnter_t),
            "::",
            stringify!(m_ulSteamIDLobby)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgfChatPermissions) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyEnter_t),
            "::",
            stringify!(m_rgfChatPermissions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bLocked) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyEnter_t),
            "::",
            stringify!(m_bLocked)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_EChatRoomEnterResponse) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyEnter_t),
            "::",
            stringify!(m_EChatRoomEnterResponse)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct LobbyDataUpdate_t {
    pub m_ulSteamIDLobby: uint64,
    pub m_ulSteamIDMember: uint64,
    pub m_bSuccess: uint8,
}
pub const LobbyDataUpdate_t_k_iCallback: LobbyDataUpdate_t__bindgen_ty_1 =
    LobbyDataUpdate_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum LobbyDataUpdate_t__bindgen_ty_1 {
    k_iCallback = 505,
}
#[test]
fn bindgen_test_layout_LobbyDataUpdate_t() {
    const UNINIT: ::std::mem::MaybeUninit<LobbyDataUpdate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LobbyDataUpdate_t>(),
        20usize,
        concat!("Size of: ", stringify!(LobbyDataUpdate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LobbyDataUpdate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(LobbyDataUpdate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDLobby) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyDataUpdate_t),
            "::",
            stringify!(m_ulSteamIDLobby)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDMember) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyDataUpdate_t),
            "::",
            stringify!(m_ulSteamIDMember)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bSuccess) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyDataUpdate_t),
            "::",
            stringify!(m_bSuccess)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct LobbyChatUpdate_t {
    pub m_ulSteamIDLobby: uint64,
    pub m_ulSteamIDUserChanged: uint64,
    pub m_ulSteamIDMakingChange: uint64,
    pub m_rgfChatMemberStateChange: uint32,
}
pub const LobbyChatUpdate_t_k_iCallback: LobbyChatUpdate_t__bindgen_ty_1 =
    LobbyChatUpdate_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum LobbyChatUpdate_t__bindgen_ty_1 {
    k_iCallback = 506,
}
#[test]
fn bindgen_test_layout_LobbyChatUpdate_t() {
    const UNINIT: ::std::mem::MaybeUninit<LobbyChatUpdate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LobbyChatUpdate_t>(),
        28usize,
        concat!("Size of: ", stringify!(LobbyChatUpdate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LobbyChatUpdate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(LobbyChatUpdate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDLobby) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyChatUpdate_t),
            "::",
            stringify!(m_ulSteamIDLobby)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDUserChanged) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyChatUpdate_t),
            "::",
            stringify!(m_ulSteamIDUserChanged)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDMakingChange) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyChatUpdate_t),
            "::",
            stringify!(m_ulSteamIDMakingChange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgfChatMemberStateChange) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyChatUpdate_t),
            "::",
            stringify!(m_rgfChatMemberStateChange)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct LobbyChatMsg_t {
    pub m_ulSteamIDLobby: uint64,
    pub m_ulSteamIDUser: uint64,
    pub m_eChatEntryType: uint8,
    pub m_iChatID: uint32,
}
pub const LobbyChatMsg_t_k_iCallback: LobbyChatMsg_t__bindgen_ty_1 =
    LobbyChatMsg_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum LobbyChatMsg_t__bindgen_ty_1 {
    k_iCallback = 507,
}
#[test]
fn bindgen_test_layout_LobbyChatMsg_t() {
    const UNINIT: ::std::mem::MaybeUninit<LobbyChatMsg_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LobbyChatMsg_t>(),
        24usize,
        concat!("Size of: ", stringify!(LobbyChatMsg_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LobbyChatMsg_t>(),
        4usize,
        concat!("Alignment of ", stringify!(LobbyChatMsg_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDLobby) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyChatMsg_t),
            "::",
            stringify!(m_ulSteamIDLobby)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDUser) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyChatMsg_t),
            "::",
            stringify!(m_ulSteamIDUser)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eChatEntryType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyChatMsg_t),
            "::",
            stringify!(m_eChatEntryType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_iChatID) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyChatMsg_t),
            "::",
            stringify!(m_iChatID)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct LobbyGameCreated_t {
    pub m_ulSteamIDLobby: uint64,
    pub m_ulSteamIDGameServer: uint64,
    pub m_unIP: uint32,
    pub m_usPort: uint16,
}
pub const LobbyGameCreated_t_k_iCallback: LobbyGameCreated_t__bindgen_ty_1 =
    LobbyGameCreated_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum LobbyGameCreated_t__bindgen_ty_1 {
    k_iCallback = 509,
}
#[test]
fn bindgen_test_layout_LobbyGameCreated_t() {
    const UNINIT: ::std::mem::MaybeUninit<LobbyGameCreated_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LobbyGameCreated_t>(),
        24usize,
        concat!("Size of: ", stringify!(LobbyGameCreated_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LobbyGameCreated_t>(),
        4usize,
        concat!("Alignment of ", stringify!(LobbyGameCreated_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDLobby) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyGameCreated_t),
            "::",
            stringify!(m_ulSteamIDLobby)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDGameServer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyGameCreated_t),
            "::",
            stringify!(m_ulSteamIDGameServer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unIP) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyGameCreated_t),
            "::",
            stringify!(m_unIP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_usPort) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyGameCreated_t),
            "::",
            stringify!(m_usPort)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LobbyMatchList_t {
    pub m_nLobbiesMatching: uint32,
}
pub const LobbyMatchList_t_k_iCallback: LobbyMatchList_t__bindgen_ty_1 =
    LobbyMatchList_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum LobbyMatchList_t__bindgen_ty_1 {
    k_iCallback = 510,
}
#[test]
fn bindgen_test_layout_LobbyMatchList_t() {
    const UNINIT: ::std::mem::MaybeUninit<LobbyMatchList_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LobbyMatchList_t>(),
        4usize,
        concat!("Size of: ", stringify!(LobbyMatchList_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LobbyMatchList_t>(),
        4usize,
        concat!("Alignment of ", stringify!(LobbyMatchList_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nLobbiesMatching) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyMatchList_t),
            "::",
            stringify!(m_nLobbiesMatching)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct LobbyKicked_t {
    pub m_ulSteamIDLobby: uint64,
    pub m_ulSteamIDAdmin: uint64,
    pub m_bKickedDueToDisconnect: uint8,
}
pub const LobbyKicked_t_k_iCallback: LobbyKicked_t__bindgen_ty_1 =
    LobbyKicked_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum LobbyKicked_t__bindgen_ty_1 {
    k_iCallback = 512,
}
#[test]
fn bindgen_test_layout_LobbyKicked_t() {
    const UNINIT: ::std::mem::MaybeUninit<LobbyKicked_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LobbyKicked_t>(),
        20usize,
        concat!("Size of: ", stringify!(LobbyKicked_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LobbyKicked_t>(),
        4usize,
        concat!("Alignment of ", stringify!(LobbyKicked_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDLobby) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyKicked_t),
            "::",
            stringify!(m_ulSteamIDLobby)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDAdmin) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyKicked_t),
            "::",
            stringify!(m_ulSteamIDAdmin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bKickedDueToDisconnect) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyKicked_t),
            "::",
            stringify!(m_bKickedDueToDisconnect)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct LobbyCreated_t {
    pub m_eResult: EResult,
    pub m_ulSteamIDLobby: uint64,
}
pub const LobbyCreated_t_k_iCallback: LobbyCreated_t__bindgen_ty_1 =
    LobbyCreated_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum LobbyCreated_t__bindgen_ty_1 {
    k_iCallback = 513,
}
#[test]
fn bindgen_test_layout_LobbyCreated_t() {
    const UNINIT: ::std::mem::MaybeUninit<LobbyCreated_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LobbyCreated_t>(),
        12usize,
        concat!("Size of: ", stringify!(LobbyCreated_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LobbyCreated_t>(),
        4usize,
        concat!("Alignment of ", stringify!(LobbyCreated_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyCreated_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDLobby) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyCreated_t),
            "::",
            stringify!(m_ulSteamIDLobby)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FavoritesListAccountsUpdated_t {
    pub m_eResult: EResult,
}
pub const FavoritesListAccountsUpdated_t_k_iCallback: FavoritesListAccountsUpdated_t__bindgen_ty_1 =
    FavoritesListAccountsUpdated_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum FavoritesListAccountsUpdated_t__bindgen_ty_1 {
    k_iCallback = 516,
}
#[test]
fn bindgen_test_layout_FavoritesListAccountsUpdated_t() {
    const UNINIT: ::std::mem::MaybeUninit<FavoritesListAccountsUpdated_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FavoritesListAccountsUpdated_t>(),
        4usize,
        concat!("Size of: ", stringify!(FavoritesListAccountsUpdated_t))
    );
    assert_eq!(
        ::std::mem::align_of::<FavoritesListAccountsUpdated_t>(),
        4usize,
        concat!("Alignment of ", stringify!(FavoritesListAccountsUpdated_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FavoritesListAccountsUpdated_t),
            "::",
            stringify!(m_eResult)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct SearchForGameProgressCallback_t {
    pub m_ullSearchID: uint64,
    pub m_eResult: EResult,
    pub m_lobbyID: CSteamID,
    pub m_steamIDEndedSearch: CSteamID,
    pub m_nSecondsRemainingEstimate: int32,
    pub m_cPlayersSearching: int32,
}
pub const SearchForGameProgressCallback_t_k_iCallback:
    SearchForGameProgressCallback_t__bindgen_ty_1 =
    SearchForGameProgressCallback_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SearchForGameProgressCallback_t__bindgen_ty_1 {
    k_iCallback = 5201,
}
#[test]
fn bindgen_test_layout_SearchForGameProgressCallback_t() {
    const UNINIT: ::std::mem::MaybeUninit<SearchForGameProgressCallback_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SearchForGameProgressCallback_t>(),
        36usize,
        concat!("Size of: ", stringify!(SearchForGameProgressCallback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SearchForGameProgressCallback_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SearchForGameProgressCallback_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ullSearchID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SearchForGameProgressCallback_t),
            "::",
            stringify!(m_ullSearchID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SearchForGameProgressCallback_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_lobbyID) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SearchForGameProgressCallback_t),
            "::",
            stringify!(m_lobbyID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDEndedSearch) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SearchForGameProgressCallback_t),
            "::",
            stringify!(m_steamIDEndedSearch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nSecondsRemainingEstimate) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SearchForGameProgressCallback_t),
            "::",
            stringify!(m_nSecondsRemainingEstimate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cPlayersSearching) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SearchForGameProgressCallback_t),
            "::",
            stringify!(m_cPlayersSearching)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct SearchForGameResultCallback_t {
    pub m_ullSearchID: uint64,
    pub m_eResult: EResult,
    pub m_nCountPlayersInGame: int32,
    pub m_nCountAcceptedGame: int32,
    pub m_steamIDHost: CSteamID,
    pub m_bFinalCallback: bool,
}
pub const SearchForGameResultCallback_t_k_iCallback: SearchForGameResultCallback_t__bindgen_ty_1 =
    SearchForGameResultCallback_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SearchForGameResultCallback_t__bindgen_ty_1 {
    k_iCallback = 5202,
}
#[test]
fn bindgen_test_layout_SearchForGameResultCallback_t() {
    const UNINIT: ::std::mem::MaybeUninit<SearchForGameResultCallback_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SearchForGameResultCallback_t>(),
        32usize,
        concat!("Size of: ", stringify!(SearchForGameResultCallback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SearchForGameResultCallback_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SearchForGameResultCallback_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ullSearchID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SearchForGameResultCallback_t),
            "::",
            stringify!(m_ullSearchID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SearchForGameResultCallback_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nCountPlayersInGame) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SearchForGameResultCallback_t),
            "::",
            stringify!(m_nCountPlayersInGame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nCountAcceptedGame) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SearchForGameResultCallback_t),
            "::",
            stringify!(m_nCountAcceptedGame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDHost) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SearchForGameResultCallback_t),
            "::",
            stringify!(m_steamIDHost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bFinalCallback) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SearchForGameResultCallback_t),
            "::",
            stringify!(m_bFinalCallback)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct RequestPlayersForGameProgressCallback_t {
    pub m_eResult: EResult,
    pub m_ullSearchID: uint64,
}
pub const RequestPlayersForGameProgressCallback_t_k_iCallback:
    RequestPlayersForGameProgressCallback_t__bindgen_ty_1 =
    RequestPlayersForGameProgressCallback_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RequestPlayersForGameProgressCallback_t__bindgen_ty_1 {
    k_iCallback = 5211,
}
#[test]
fn bindgen_test_layout_RequestPlayersForGameProgressCallback_t() {
    const UNINIT: ::std::mem::MaybeUninit<RequestPlayersForGameProgressCallback_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RequestPlayersForGameProgressCallback_t>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(RequestPlayersForGameProgressCallback_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RequestPlayersForGameProgressCallback_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RequestPlayersForGameProgressCallback_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RequestPlayersForGameProgressCallback_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ullSearchID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RequestPlayersForGameProgressCallback_t),
            "::",
            stringify!(m_ullSearchID)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct RequestPlayersForGameResultCallback_t {
    pub m_eResult: EResult,
    pub m_ullSearchID: uint64,
    pub m_SteamIDPlayerFound: CSteamID,
    pub m_SteamIDLobby: CSteamID,
    pub m_ePlayerAcceptState: RequestPlayersForGameResultCallback_t_PlayerAcceptState_t,
    pub m_nPlayerIndex: int32,
    pub m_nTotalPlayersFound: int32,
    pub m_nTotalPlayersAcceptedGame: int32,
    pub m_nSuggestedTeamIndex: int32,
    pub m_ullUniqueGameID: uint64,
}
pub const RequestPlayersForGameResultCallback_t_k_iCallback:
    RequestPlayersForGameResultCallback_t__bindgen_ty_1 =
    RequestPlayersForGameResultCallback_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RequestPlayersForGameResultCallback_t__bindgen_ty_1 {
    k_iCallback = 5212,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RequestPlayersForGameResultCallback_t_PlayerAcceptState_t {
    k_EStateUnknown = 0,
    k_EStatePlayerAccepted = 1,
    k_EStatePlayerDeclined = 2,
}
#[test]
fn bindgen_test_layout_RequestPlayersForGameResultCallback_t() {
    const UNINIT: ::std::mem::MaybeUninit<RequestPlayersForGameResultCallback_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RequestPlayersForGameResultCallback_t>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(RequestPlayersForGameResultCallback_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RequestPlayersForGameResultCallback_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RequestPlayersForGameResultCallback_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RequestPlayersForGameResultCallback_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ullSearchID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RequestPlayersForGameResultCallback_t),
            "::",
            stringify!(m_ullSearchID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_SteamIDPlayerFound) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RequestPlayersForGameResultCallback_t),
            "::",
            stringify!(m_SteamIDPlayerFound)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_SteamIDLobby) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RequestPlayersForGameResultCallback_t),
            "::",
            stringify!(m_SteamIDLobby)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ePlayerAcceptState) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(RequestPlayersForGameResultCallback_t),
            "::",
            stringify!(m_ePlayerAcceptState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPlayerIndex) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RequestPlayersForGameResultCallback_t),
            "::",
            stringify!(m_nPlayerIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nTotalPlayersFound) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(RequestPlayersForGameResultCallback_t),
            "::",
            stringify!(m_nTotalPlayersFound)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nTotalPlayersAcceptedGame) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RequestPlayersForGameResultCallback_t),
            "::",
            stringify!(m_nTotalPlayersAcceptedGame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nSuggestedTeamIndex) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(RequestPlayersForGameResultCallback_t),
            "::",
            stringify!(m_nSuggestedTeamIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ullUniqueGameID) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(RequestPlayersForGameResultCallback_t),
            "::",
            stringify!(m_ullUniqueGameID)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct RequestPlayersForGameFinalResultCallback_t {
    pub m_eResult: EResult,
    pub m_ullSearchID: uint64,
    pub m_ullUniqueGameID: uint64,
}
pub const RequestPlayersForGameFinalResultCallback_t_k_iCallback:
    RequestPlayersForGameFinalResultCallback_t__bindgen_ty_1 =
    RequestPlayersForGameFinalResultCallback_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RequestPlayersForGameFinalResultCallback_t__bindgen_ty_1 {
    k_iCallback = 5213,
}
#[test]
fn bindgen_test_layout_RequestPlayersForGameFinalResultCallback_t() {
    const UNINIT: ::std::mem::MaybeUninit<RequestPlayersForGameFinalResultCallback_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RequestPlayersForGameFinalResultCallback_t>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(RequestPlayersForGameFinalResultCallback_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RequestPlayersForGameFinalResultCallback_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RequestPlayersForGameFinalResultCallback_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RequestPlayersForGameFinalResultCallback_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ullSearchID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RequestPlayersForGameFinalResultCallback_t),
            "::",
            stringify!(m_ullSearchID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ullUniqueGameID) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RequestPlayersForGameFinalResultCallback_t),
            "::",
            stringify!(m_ullUniqueGameID)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct SubmitPlayerResultResultCallback_t {
    pub m_eResult: EResult,
    pub ullUniqueGameID: uint64,
    pub steamIDPlayer: CSteamID,
}
pub const SubmitPlayerResultResultCallback_t_k_iCallback:
    SubmitPlayerResultResultCallback_t__bindgen_ty_1 =
    SubmitPlayerResultResultCallback_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SubmitPlayerResultResultCallback_t__bindgen_ty_1 {
    k_iCallback = 5214,
}
#[test]
fn bindgen_test_layout_SubmitPlayerResultResultCallback_t() {
    const UNINIT: ::std::mem::MaybeUninit<SubmitPlayerResultResultCallback_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SubmitPlayerResultResultCallback_t>(),
        20usize,
        concat!("Size of: ", stringify!(SubmitPlayerResultResultCallback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SubmitPlayerResultResultCallback_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SubmitPlayerResultResultCallback_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubmitPlayerResultResultCallback_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ullUniqueGameID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SubmitPlayerResultResultCallback_t),
            "::",
            stringify!(ullUniqueGameID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).steamIDPlayer) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SubmitPlayerResultResultCallback_t),
            "::",
            stringify!(steamIDPlayer)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct EndGameResultCallback_t {
    pub m_eResult: EResult,
    pub ullUniqueGameID: uint64,
}
pub const EndGameResultCallback_t_k_iCallback: EndGameResultCallback_t__bindgen_ty_1 =
    EndGameResultCallback_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EndGameResultCallback_t__bindgen_ty_1 {
    k_iCallback = 5215,
}
#[test]
fn bindgen_test_layout_EndGameResultCallback_t() {
    const UNINIT: ::std::mem::MaybeUninit<EndGameResultCallback_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<EndGameResultCallback_t>(),
        12usize,
        concat!("Size of: ", stringify!(EndGameResultCallback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<EndGameResultCallback_t>(),
        4usize,
        concat!("Alignment of ", stringify!(EndGameResultCallback_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EndGameResultCallback_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ullUniqueGameID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(EndGameResultCallback_t),
            "::",
            stringify!(ullUniqueGameID)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct JoinPartyCallback_t {
    pub m_eResult: EResult,
    pub m_ulBeaconID: PartyBeaconID_t,
    pub m_SteamIDBeaconOwner: CSteamID,
    pub m_rgchConnectString: [::std::os::raw::c_char; 256usize],
}
pub const JoinPartyCallback_t_k_iCallback: JoinPartyCallback_t__bindgen_ty_1 =
    JoinPartyCallback_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum JoinPartyCallback_t__bindgen_ty_1 {
    k_iCallback = 5301,
}
#[test]
fn bindgen_test_layout_JoinPartyCallback_t() {
    const UNINIT: ::std::mem::MaybeUninit<JoinPartyCallback_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JoinPartyCallback_t>(),
        276usize,
        concat!("Size of: ", stringify!(JoinPartyCallback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<JoinPartyCallback_t>(),
        4usize,
        concat!("Alignment of ", stringify!(JoinPartyCallback_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JoinPartyCallback_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulBeaconID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(JoinPartyCallback_t),
            "::",
            stringify!(m_ulBeaconID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_SteamIDBeaconOwner) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(JoinPartyCallback_t),
            "::",
            stringify!(m_SteamIDBeaconOwner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchConnectString) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(JoinPartyCallback_t),
            "::",
            stringify!(m_rgchConnectString)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct CreateBeaconCallback_t {
    pub m_eResult: EResult,
    pub m_ulBeaconID: PartyBeaconID_t,
}
pub const CreateBeaconCallback_t_k_iCallback: CreateBeaconCallback_t__bindgen_ty_1 =
    CreateBeaconCallback_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CreateBeaconCallback_t__bindgen_ty_1 {
    k_iCallback = 5302,
}
#[test]
fn bindgen_test_layout_CreateBeaconCallback_t() {
    const UNINIT: ::std::mem::MaybeUninit<CreateBeaconCallback_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CreateBeaconCallback_t>(),
        12usize,
        concat!("Size of: ", stringify!(CreateBeaconCallback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<CreateBeaconCallback_t>(),
        4usize,
        concat!("Alignment of ", stringify!(CreateBeaconCallback_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateBeaconCallback_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulBeaconID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateBeaconCallback_t),
            "::",
            stringify!(m_ulBeaconID)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct ReservationNotificationCallback_t {
    pub m_ulBeaconID: PartyBeaconID_t,
    pub m_steamIDJoiner: CSteamID,
}
pub const ReservationNotificationCallback_t_k_iCallback:
    ReservationNotificationCallback_t__bindgen_ty_1 =
    ReservationNotificationCallback_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ReservationNotificationCallback_t__bindgen_ty_1 {
    k_iCallback = 5303,
}
#[test]
fn bindgen_test_layout_ReservationNotificationCallback_t() {
    const UNINIT: ::std::mem::MaybeUninit<ReservationNotificationCallback_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ReservationNotificationCallback_t>(),
        16usize,
        concat!("Size of: ", stringify!(ReservationNotificationCallback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ReservationNotificationCallback_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ReservationNotificationCallback_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulBeaconID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ReservationNotificationCallback_t),
            "::",
            stringify!(m_ulBeaconID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDJoiner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ReservationNotificationCallback_t),
            "::",
            stringify!(m_steamIDJoiner)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ChangeNumOpenSlotsCallback_t {
    pub m_eResult: EResult,
}
pub const ChangeNumOpenSlotsCallback_t_k_iCallback: ChangeNumOpenSlotsCallback_t__bindgen_ty_1 =
    ChangeNumOpenSlotsCallback_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ChangeNumOpenSlotsCallback_t__bindgen_ty_1 {
    k_iCallback = 5304,
}
#[test]
fn bindgen_test_layout_ChangeNumOpenSlotsCallback_t() {
    const UNINIT: ::std::mem::MaybeUninit<ChangeNumOpenSlotsCallback_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ChangeNumOpenSlotsCallback_t>(),
        4usize,
        concat!("Size of: ", stringify!(ChangeNumOpenSlotsCallback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ChangeNumOpenSlotsCallback_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ChangeNumOpenSlotsCallback_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChangeNumOpenSlotsCallback_t),
            "::",
            stringify!(m_eResult)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AvailableBeaconLocationsUpdated_t {
    pub _address: u8,
}
pub const AvailableBeaconLocationsUpdated_t_k_iCallback:
    AvailableBeaconLocationsUpdated_t__bindgen_ty_1 =
    AvailableBeaconLocationsUpdated_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AvailableBeaconLocationsUpdated_t__bindgen_ty_1 {
    k_iCallback = 5305,
}
#[test]
fn bindgen_test_layout_AvailableBeaconLocationsUpdated_t() {
    assert_eq!(
        ::std::mem::size_of::<AvailableBeaconLocationsUpdated_t>(),
        1usize,
        concat!("Size of: ", stringify!(AvailableBeaconLocationsUpdated_t))
    );
    assert_eq!(
        ::std::mem::align_of::<AvailableBeaconLocationsUpdated_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(AvailableBeaconLocationsUpdated_t)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ActiveBeaconsUpdated_t {
    pub _address: u8,
}
pub const ActiveBeaconsUpdated_t_k_iCallback: ActiveBeaconsUpdated_t__bindgen_ty_1 =
    ActiveBeaconsUpdated_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ActiveBeaconsUpdated_t__bindgen_ty_1 {
    k_iCallback = 5306,
}
#[test]
fn bindgen_test_layout_ActiveBeaconsUpdated_t() {
    assert_eq!(
        ::std::mem::size_of::<ActiveBeaconsUpdated_t>(),
        1usize,
        concat!("Size of: ", stringify!(ActiveBeaconsUpdated_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ActiveBeaconsUpdated_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ActiveBeaconsUpdated_t))
    );
}
pub const k_unMaxCloudFileChunkSize: uint32 = 104857600;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct SteamParamStringArray_t {
    pub m_ppStrings: *mut *const ::std::os::raw::c_char,
    pub m_nNumStrings: int32,
}
#[test]
fn bindgen_test_layout_SteamParamStringArray_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamParamStringArray_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamParamStringArray_t>(),
        12usize,
        concat!("Size of: ", stringify!(SteamParamStringArray_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamParamStringArray_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamParamStringArray_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ppStrings) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamParamStringArray_t),
            "::",
            stringify!(m_ppStrings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nNumStrings) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamParamStringArray_t),
            "::",
            stringify!(m_nNumStrings)
        )
    );
}
pub type UGCHandle_t = uint64;
pub type PublishedFileUpdateHandle_t = uint64;
pub type PublishedFileId_t = uint64;
pub const k_PublishedFileIdInvalid: PublishedFileId_t = 0;
pub const k_UGCHandleInvalid: UGCHandle_t = 18446744073709551615;
pub const k_PublishedFileUpdateHandleInvalid: PublishedFileUpdateHandle_t = 18446744073709551615;
pub type UGCFileWriteStreamHandle_t = uint64;
pub const k_UGCFileStreamHandleInvalid: UGCFileWriteStreamHandle_t = 18446744073709551615;
pub const k_cchPublishedDocumentTitleMax: uint32 = 129;
pub const k_cchPublishedDocumentDescriptionMax: uint32 = 8000;
pub const k_cchPublishedDocumentChangeDescriptionMax: uint32 = 8000;
pub const k_unEnumeratePublishedFilesMaxResults: uint32 = 50;
pub const k_cchTagListMax: uint32 = 1025;
pub const k_cchFilenameMax: uint32 = 260;
pub const k_cchPublishedFileURLMax: uint32 = 256;
impl ERemoteStoragePlatform {
    pub const k_ERemoteStoragePlatformNone: ERemoteStoragePlatform = ERemoteStoragePlatform(0);
}
impl ERemoteStoragePlatform {
    pub const k_ERemoteStoragePlatformWindows: ERemoteStoragePlatform = ERemoteStoragePlatform(1);
}
impl ERemoteStoragePlatform {
    pub const k_ERemoteStoragePlatformOSX: ERemoteStoragePlatform = ERemoteStoragePlatform(2);
}
impl ERemoteStoragePlatform {
    pub const k_ERemoteStoragePlatformPS3: ERemoteStoragePlatform = ERemoteStoragePlatform(4);
}
impl ERemoteStoragePlatform {
    pub const k_ERemoteStoragePlatformLinux: ERemoteStoragePlatform = ERemoteStoragePlatform(8);
}
impl ERemoteStoragePlatform {
    pub const k_ERemoteStoragePlatformSwitch: ERemoteStoragePlatform = ERemoteStoragePlatform(16);
}
impl ERemoteStoragePlatform {
    pub const k_ERemoteStoragePlatformAndroid: ERemoteStoragePlatform = ERemoteStoragePlatform(32);
}
impl ERemoteStoragePlatform {
    pub const k_ERemoteStoragePlatformIOS: ERemoteStoragePlatform = ERemoteStoragePlatform(64);
}
impl ERemoteStoragePlatform {
    pub const k_ERemoteStoragePlatformAll: ERemoteStoragePlatform =
        ERemoteStoragePlatform(4294967295);
}
impl ::std::ops::BitOr<ERemoteStoragePlatform> for ERemoteStoragePlatform {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ERemoteStoragePlatform(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ERemoteStoragePlatform {
    #[inline]
    fn bitor_assign(&mut self, rhs: ERemoteStoragePlatform) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ERemoteStoragePlatform> for ERemoteStoragePlatform {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ERemoteStoragePlatform(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ERemoteStoragePlatform {
    #[inline]
    fn bitand_assign(&mut self, rhs: ERemoteStoragePlatform) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ERemoteStoragePlatform(pub ::std::os::raw::c_uint);
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ERemoteStoragePublishedFileVisibility {
    k_ERemoteStoragePublishedFileVisibilityPublic = 0,
    k_ERemoteStoragePublishedFileVisibilityFriendsOnly = 1,
    k_ERemoteStoragePublishedFileVisibilityPrivate = 2,
    k_ERemoteStoragePublishedFileVisibilityUnlisted = 3,
}
impl EWorkshopFileType {
    pub const k_EWorkshopFileTypeCommunity: EWorkshopFileType =
        EWorkshopFileType::k_EWorkshopFileTypeFirst;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EWorkshopFileType {
    k_EWorkshopFileTypeFirst = 0,
    k_EWorkshopFileTypeMicrotransaction = 1,
    k_EWorkshopFileTypeCollection = 2,
    k_EWorkshopFileTypeArt = 3,
    k_EWorkshopFileTypeVideo = 4,
    k_EWorkshopFileTypeScreenshot = 5,
    k_EWorkshopFileTypeGame = 6,
    k_EWorkshopFileTypeSoftware = 7,
    k_EWorkshopFileTypeConcept = 8,
    k_EWorkshopFileTypeWebGuide = 9,
    k_EWorkshopFileTypeIntegratedGuide = 10,
    k_EWorkshopFileTypeMerch = 11,
    k_EWorkshopFileTypeControllerBinding = 12,
    k_EWorkshopFileTypeSteamworksAccessInvite = 13,
    k_EWorkshopFileTypeSteamVideo = 14,
    k_EWorkshopFileTypeGameManagedItem = 15,
    k_EWorkshopFileTypeClip = 16,
    k_EWorkshopFileTypeMax = 17,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EWorkshopVote {
    k_EWorkshopVoteUnvoted = 0,
    k_EWorkshopVoteFor = 1,
    k_EWorkshopVoteAgainst = 2,
    k_EWorkshopVoteLater = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EWorkshopFileAction {
    k_EWorkshopFileActionPlayed = 0,
    k_EWorkshopFileActionCompleted = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EWorkshopEnumerationType {
    k_EWorkshopEnumerationTypeRankedByVote = 0,
    k_EWorkshopEnumerationTypeRecent = 1,
    k_EWorkshopEnumerationTypeTrending = 2,
    k_EWorkshopEnumerationTypeFavoritesOfFriends = 3,
    k_EWorkshopEnumerationTypeVotedByFriends = 4,
    k_EWorkshopEnumerationTypeContentByFriends = 5,
    k_EWorkshopEnumerationTypeRecentFromFollowedUsers = 6,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EWorkshopVideoProvider {
    k_EWorkshopVideoProviderNone = 0,
    k_EWorkshopVideoProviderYoutube = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EUGCReadAction {
    k_EUGCRead_ContinueReadingUntilFinished = 0,
    k_EUGCRead_ContinueReading = 1,
    k_EUGCRead_Close = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ERemoteStorageLocalFileChange {
    k_ERemoteStorageLocalFileChange_Invalid = 0,
    k_ERemoteStorageLocalFileChange_FileUpdated = 1,
    k_ERemoteStorageLocalFileChange_FileDeleted = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ERemoteStorageFilePathType {
    k_ERemoteStorageFilePathType_Invalid = 0,
    k_ERemoteStorageFilePathType_Absolute = 1,
    k_ERemoteStorageFilePathType_APIFilename = 2,
}
#[repr(C)]
pub struct ISteamRemoteStorage__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamRemoteStorage {
    pub vtable_: *const ISteamRemoteStorage__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamRemoteStorage() {
    assert_eq!(
        ::std::mem::size_of::<ISteamRemoteStorage>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamRemoteStorage))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamRemoteStorage>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamRemoteStorage))
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageFileShareResult_t {
    pub m_eResult: EResult,
    pub m_hFile: UGCHandle_t,
    pub m_rgchFilename: [::std::os::raw::c_char; 260usize],
}
pub const RemoteStorageFileShareResult_t_k_iCallback: RemoteStorageFileShareResult_t__bindgen_ty_1 =
    RemoteStorageFileShareResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RemoteStorageFileShareResult_t__bindgen_ty_1 {
    k_iCallback = 1307,
}
#[test]
fn bindgen_test_layout_RemoteStorageFileShareResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStorageFileShareResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageFileShareResult_t>(),
        272usize,
        concat!("Size of: ", stringify!(RemoteStorageFileShareResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageFileShareResult_t>(),
        4usize,
        concat!("Alignment of ", stringify!(RemoteStorageFileShareResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageFileShareResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hFile) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageFileShareResult_t),
            "::",
            stringify!(m_hFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchFilename) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageFileShareResult_t),
            "::",
            stringify!(m_rgchFilename)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStoragePublishFileResult_t {
    pub m_eResult: EResult,
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_bUserNeedsToAcceptWorkshopLegalAgreement: bool,
}
pub const RemoteStoragePublishFileResult_t_k_iCallback:
    RemoteStoragePublishFileResult_t__bindgen_ty_1 =
    RemoteStoragePublishFileResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RemoteStoragePublishFileResult_t__bindgen_ty_1 {
    k_iCallback = 1309,
}
#[test]
fn bindgen_test_layout_RemoteStoragePublishFileResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStoragePublishFileResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStoragePublishFileResult_t>(),
        16usize,
        concat!("Size of: ", stringify!(RemoteStoragePublishFileResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStoragePublishFileResult_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStoragePublishFileResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStoragePublishFileResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStoragePublishFileResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_bUserNeedsToAcceptWorkshopLegalAgreement) as usize
                - ptr as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStoragePublishFileResult_t),
            "::",
            stringify!(m_bUserNeedsToAcceptWorkshopLegalAgreement)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageDeletePublishedFileResult_t {
    pub m_eResult: EResult,
    pub m_nPublishedFileId: PublishedFileId_t,
}
pub const RemoteStorageDeletePublishedFileResult_t_k_iCallback:
    RemoteStorageDeletePublishedFileResult_t__bindgen_ty_1 =
    RemoteStorageDeletePublishedFileResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RemoteStorageDeletePublishedFileResult_t__bindgen_ty_1 {
    k_iCallback = 1311,
}
#[test]
fn bindgen_test_layout_RemoteStorageDeletePublishedFileResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStorageDeletePublishedFileResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageDeletePublishedFileResult_t>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(RemoteStorageDeletePublishedFileResult_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageDeletePublishedFileResult_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStorageDeletePublishedFileResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageDeletePublishedFileResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageDeletePublishedFileResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageEnumerateUserPublishedFilesResult_t {
    pub m_eResult: EResult,
    pub m_nResultsReturned: int32,
    pub m_nTotalResultCount: int32,
    pub m_rgPublishedFileId: [PublishedFileId_t; 50usize],
}
pub const RemoteStorageEnumerateUserPublishedFilesResult_t_k_iCallback:
    RemoteStorageEnumerateUserPublishedFilesResult_t__bindgen_ty_1 =
    RemoteStorageEnumerateUserPublishedFilesResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RemoteStorageEnumerateUserPublishedFilesResult_t__bindgen_ty_1 {
    k_iCallback = 1312,
}
#[test]
fn bindgen_test_layout_RemoteStorageEnumerateUserPublishedFilesResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStorageEnumerateUserPublishedFilesResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageEnumerateUserPublishedFilesResult_t>(),
        412usize,
        concat!(
            "Size of: ",
            stringify!(RemoteStorageEnumerateUserPublishedFilesResult_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageEnumerateUserPublishedFilesResult_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStorageEnumerateUserPublishedFilesResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateUserPublishedFilesResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nResultsReturned) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateUserPublishedFilesResult_t),
            "::",
            stringify!(m_nResultsReturned)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nTotalResultCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateUserPublishedFilesResult_t),
            "::",
            stringify!(m_nTotalResultCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgPublishedFileId) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateUserPublishedFilesResult_t),
            "::",
            stringify!(m_rgPublishedFileId)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageSubscribePublishedFileResult_t {
    pub m_eResult: EResult,
    pub m_nPublishedFileId: PublishedFileId_t,
}
pub const RemoteStorageSubscribePublishedFileResult_t_k_iCallback:
    RemoteStorageSubscribePublishedFileResult_t__bindgen_ty_1 =
    RemoteStorageSubscribePublishedFileResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RemoteStorageSubscribePublishedFileResult_t__bindgen_ty_1 {
    k_iCallback = 1313,
}
#[test]
fn bindgen_test_layout_RemoteStorageSubscribePublishedFileResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStorageSubscribePublishedFileResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageSubscribePublishedFileResult_t>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(RemoteStorageSubscribePublishedFileResult_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageSubscribePublishedFileResult_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStorageSubscribePublishedFileResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageSubscribePublishedFileResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageSubscribePublishedFileResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageEnumerateUserSubscribedFilesResult_t {
    pub m_eResult: EResult,
    pub m_nResultsReturned: int32,
    pub m_nTotalResultCount: int32,
    pub m_rgPublishedFileId: [PublishedFileId_t; 50usize],
    pub m_rgRTimeSubscribed: [uint32; 50usize],
}
pub const RemoteStorageEnumerateUserSubscribedFilesResult_t_k_iCallback:
    RemoteStorageEnumerateUserSubscribedFilesResult_t__bindgen_ty_1 =
    RemoteStorageEnumerateUserSubscribedFilesResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RemoteStorageEnumerateUserSubscribedFilesResult_t__bindgen_ty_1 {
    k_iCallback = 1314,
}
#[test]
fn bindgen_test_layout_RemoteStorageEnumerateUserSubscribedFilesResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStorageEnumerateUserSubscribedFilesResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageEnumerateUserSubscribedFilesResult_t>(),
        612usize,
        concat!(
            "Size of: ",
            stringify!(RemoteStorageEnumerateUserSubscribedFilesResult_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageEnumerateUserSubscribedFilesResult_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStorageEnumerateUserSubscribedFilesResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateUserSubscribedFilesResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nResultsReturned) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateUserSubscribedFilesResult_t),
            "::",
            stringify!(m_nResultsReturned)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nTotalResultCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateUserSubscribedFilesResult_t),
            "::",
            stringify!(m_nTotalResultCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgPublishedFileId) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateUserSubscribedFilesResult_t),
            "::",
            stringify!(m_rgPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgRTimeSubscribed) as usize - ptr as usize },
        412usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateUserSubscribedFilesResult_t),
            "::",
            stringify!(m_rgRTimeSubscribed)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageUnsubscribePublishedFileResult_t {
    pub m_eResult: EResult,
    pub m_nPublishedFileId: PublishedFileId_t,
}
pub const RemoteStorageUnsubscribePublishedFileResult_t_k_iCallback:
    RemoteStorageUnsubscribePublishedFileResult_t__bindgen_ty_1 =
    RemoteStorageUnsubscribePublishedFileResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RemoteStorageUnsubscribePublishedFileResult_t__bindgen_ty_1 {
    k_iCallback = 1315,
}
#[test]
fn bindgen_test_layout_RemoteStorageUnsubscribePublishedFileResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStorageUnsubscribePublishedFileResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageUnsubscribePublishedFileResult_t>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(RemoteStorageUnsubscribePublishedFileResult_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageUnsubscribePublishedFileResult_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStorageUnsubscribePublishedFileResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageUnsubscribePublishedFileResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageUnsubscribePublishedFileResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageUpdatePublishedFileResult_t {
    pub m_eResult: EResult,
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_bUserNeedsToAcceptWorkshopLegalAgreement: bool,
}
pub const RemoteStorageUpdatePublishedFileResult_t_k_iCallback:
    RemoteStorageUpdatePublishedFileResult_t__bindgen_ty_1 =
    RemoteStorageUpdatePublishedFileResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RemoteStorageUpdatePublishedFileResult_t__bindgen_ty_1 {
    k_iCallback = 1316,
}
#[test]
fn bindgen_test_layout_RemoteStorageUpdatePublishedFileResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStorageUpdatePublishedFileResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageUpdatePublishedFileResult_t>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(RemoteStorageUpdatePublishedFileResult_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageUpdatePublishedFileResult_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStorageUpdatePublishedFileResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageUpdatePublishedFileResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageUpdatePublishedFileResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_bUserNeedsToAcceptWorkshopLegalAgreement) as usize
                - ptr as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageUpdatePublishedFileResult_t),
            "::",
            stringify!(m_bUserNeedsToAcceptWorkshopLegalAgreement)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageDownloadUGCResult_t {
    pub m_eResult: EResult,
    pub m_hFile: UGCHandle_t,
    pub m_nAppID: AppId_t,
    pub m_nSizeInBytes: int32,
    pub m_pchFileName: [::std::os::raw::c_char; 260usize],
    pub m_ulSteamIDOwner: uint64,
}
pub const RemoteStorageDownloadUGCResult_t_k_iCallback:
    RemoteStorageDownloadUGCResult_t__bindgen_ty_1 =
    RemoteStorageDownloadUGCResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RemoteStorageDownloadUGCResult_t__bindgen_ty_1 {
    k_iCallback = 1317,
}
#[test]
fn bindgen_test_layout_RemoteStorageDownloadUGCResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStorageDownloadUGCResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageDownloadUGCResult_t>(),
        288usize,
        concat!("Size of: ", stringify!(RemoteStorageDownloadUGCResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageDownloadUGCResult_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStorageDownloadUGCResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageDownloadUGCResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hFile) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageDownloadUGCResult_t),
            "::",
            stringify!(m_hFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nAppID) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageDownloadUGCResult_t),
            "::",
            stringify!(m_nAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nSizeInBytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageDownloadUGCResult_t),
            "::",
            stringify!(m_nSizeInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pchFileName) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageDownloadUGCResult_t),
            "::",
            stringify!(m_pchFileName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDOwner) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageDownloadUGCResult_t),
            "::",
            stringify!(m_ulSteamIDOwner)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageGetPublishedFileDetailsResult_t {
    pub m_eResult: EResult,
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_nCreatorAppID: AppId_t,
    pub m_nConsumerAppID: AppId_t,
    pub m_rgchTitle: [::std::os::raw::c_char; 129usize],
    pub m_rgchDescription: [::std::os::raw::c_char; 8000usize],
    pub m_hFile: UGCHandle_t,
    pub m_hPreviewFile: UGCHandle_t,
    pub m_ulSteamIDOwner: uint64,
    pub m_rtimeCreated: uint32,
    pub m_rtimeUpdated: uint32,
    pub m_eVisibility: ERemoteStoragePublishedFileVisibility,
    pub m_bBanned: bool,
    pub m_rgchTags: [::std::os::raw::c_char; 1025usize],
    pub m_bTagsTruncated: bool,
    pub m_pchFileName: [::std::os::raw::c_char; 260usize],
    pub m_nFileSize: int32,
    pub m_nPreviewFileSize: int32,
    pub m_rgchURL: [::std::os::raw::c_char; 256usize],
    pub m_eFileType: EWorkshopFileType,
    pub m_bAcceptedForUse: bool,
}
pub const RemoteStorageGetPublishedFileDetailsResult_t_k_iCallback:
    RemoteStorageGetPublishedFileDetailsResult_t__bindgen_ty_1 =
    RemoteStorageGetPublishedFileDetailsResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RemoteStorageGetPublishedFileDetailsResult_t__bindgen_ty_1 {
    k_iCallback = 1318,
}
#[test]
fn bindgen_test_layout_RemoteStorageGetPublishedFileDetailsResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStorageGetPublishedFileDetailsResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageGetPublishedFileDetailsResult_t>(),
        9748usize,
        concat!(
            "Size of: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageGetPublishedFileDetailsResult_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nCreatorAppID) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_nCreatorAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nConsumerAppID) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_nConsumerAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchTitle) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_rgchTitle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchDescription) as usize - ptr as usize },
        149usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_rgchDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hFile) as usize - ptr as usize },
        8152usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_hFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hPreviewFile) as usize - ptr as usize },
        8160usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_hPreviewFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDOwner) as usize - ptr as usize },
        8168usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_ulSteamIDOwner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rtimeCreated) as usize - ptr as usize },
        8176usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_rtimeCreated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rtimeUpdated) as usize - ptr as usize },
        8180usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_rtimeUpdated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eVisibility) as usize - ptr as usize },
        8184usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_eVisibility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bBanned) as usize - ptr as usize },
        8188usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_bBanned)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchTags) as usize - ptr as usize },
        8189usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_rgchTags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bTagsTruncated) as usize - ptr as usize },
        9214usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_bTagsTruncated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pchFileName) as usize - ptr as usize },
        9215usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_pchFileName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nFileSize) as usize - ptr as usize },
        9476usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_nFileSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPreviewFileSize) as usize - ptr as usize },
        9480usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_nPreviewFileSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchURL) as usize - ptr as usize },
        9484usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_rgchURL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eFileType) as usize - ptr as usize },
        9740usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_eFileType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bAcceptedForUse) as usize - ptr as usize },
        9744usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_bAcceptedForUse)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageEnumerateWorkshopFilesResult_t {
    pub m_eResult: EResult,
    pub m_nResultsReturned: int32,
    pub m_nTotalResultCount: int32,
    pub m_rgPublishedFileId: [PublishedFileId_t; 50usize],
    pub m_rgScore: [f32; 50usize],
    pub m_nAppId: AppId_t,
    pub m_unStartIndex: uint32,
}
pub const RemoteStorageEnumerateWorkshopFilesResult_t_k_iCallback:
    RemoteStorageEnumerateWorkshopFilesResult_t__bindgen_ty_1 =
    RemoteStorageEnumerateWorkshopFilesResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RemoteStorageEnumerateWorkshopFilesResult_t__bindgen_ty_1 {
    k_iCallback = 1319,
}
#[test]
fn bindgen_test_layout_RemoteStorageEnumerateWorkshopFilesResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStorageEnumerateWorkshopFilesResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageEnumerateWorkshopFilesResult_t>(),
        620usize,
        concat!(
            "Size of: ",
            stringify!(RemoteStorageEnumerateWorkshopFilesResult_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageEnumerateWorkshopFilesResult_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStorageEnumerateWorkshopFilesResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateWorkshopFilesResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nResultsReturned) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateWorkshopFilesResult_t),
            "::",
            stringify!(m_nResultsReturned)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nTotalResultCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateWorkshopFilesResult_t),
            "::",
            stringify!(m_nTotalResultCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgPublishedFileId) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateWorkshopFilesResult_t),
            "::",
            stringify!(m_rgPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgScore) as usize - ptr as usize },
        412usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateWorkshopFilesResult_t),
            "::",
            stringify!(m_rgScore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nAppId) as usize - ptr as usize },
        612usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateWorkshopFilesResult_t),
            "::",
            stringify!(m_nAppId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unStartIndex) as usize - ptr as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateWorkshopFilesResult_t),
            "::",
            stringify!(m_unStartIndex)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageGetPublishedItemVoteDetailsResult_t {
    pub m_eResult: EResult,
    pub m_unPublishedFileId: PublishedFileId_t,
    pub m_nVotesFor: int32,
    pub m_nVotesAgainst: int32,
    pub m_nReports: int32,
    pub m_fScore: f32,
}
pub const RemoteStorageGetPublishedItemVoteDetailsResult_t_k_iCallback:
    RemoteStorageGetPublishedItemVoteDetailsResult_t__bindgen_ty_1 =
    RemoteStorageGetPublishedItemVoteDetailsResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RemoteStorageGetPublishedItemVoteDetailsResult_t__bindgen_ty_1 {
    k_iCallback = 1320,
}
#[test]
fn bindgen_test_layout_RemoteStorageGetPublishedItemVoteDetailsResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStorageGetPublishedItemVoteDetailsResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageGetPublishedItemVoteDetailsResult_t>(),
        28usize,
        concat!(
            "Size of: ",
            stringify!(RemoteStorageGetPublishedItemVoteDetailsResult_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageGetPublishedItemVoteDetailsResult_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStorageGetPublishedItemVoteDetailsResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedItemVoteDetailsResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unPublishedFileId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedItemVoteDetailsResult_t),
            "::",
            stringify!(m_unPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nVotesFor) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedItemVoteDetailsResult_t),
            "::",
            stringify!(m_nVotesFor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nVotesAgainst) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedItemVoteDetailsResult_t),
            "::",
            stringify!(m_nVotesAgainst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nReports) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedItemVoteDetailsResult_t),
            "::",
            stringify!(m_nReports)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fScore) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedItemVoteDetailsResult_t),
            "::",
            stringify!(m_fScore)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStoragePublishedFileSubscribed_t {
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_nAppID: AppId_t,
}
pub const RemoteStoragePublishedFileSubscribed_t_k_iCallback:
    RemoteStoragePublishedFileSubscribed_t__bindgen_ty_1 =
    RemoteStoragePublishedFileSubscribed_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RemoteStoragePublishedFileSubscribed_t__bindgen_ty_1 {
    k_iCallback = 1321,
}
#[test]
fn bindgen_test_layout_RemoteStoragePublishedFileSubscribed_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStoragePublishedFileSubscribed_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStoragePublishedFileSubscribed_t>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(RemoteStoragePublishedFileSubscribed_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStoragePublishedFileSubscribed_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStoragePublishedFileSubscribed_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStoragePublishedFileSubscribed_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nAppID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStoragePublishedFileSubscribed_t),
            "::",
            stringify!(m_nAppID)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStoragePublishedFileUnsubscribed_t {
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_nAppID: AppId_t,
}
pub const RemoteStoragePublishedFileUnsubscribed_t_k_iCallback:
    RemoteStoragePublishedFileUnsubscribed_t__bindgen_ty_1 =
    RemoteStoragePublishedFileUnsubscribed_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RemoteStoragePublishedFileUnsubscribed_t__bindgen_ty_1 {
    k_iCallback = 1322,
}
#[test]
fn bindgen_test_layout_RemoteStoragePublishedFileUnsubscribed_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStoragePublishedFileUnsubscribed_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStoragePublishedFileUnsubscribed_t>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(RemoteStoragePublishedFileUnsubscribed_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStoragePublishedFileUnsubscribed_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStoragePublishedFileUnsubscribed_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStoragePublishedFileUnsubscribed_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nAppID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStoragePublishedFileUnsubscribed_t),
            "::",
            stringify!(m_nAppID)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStoragePublishedFileDeleted_t {
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_nAppID: AppId_t,
}
pub const RemoteStoragePublishedFileDeleted_t_k_iCallback:
    RemoteStoragePublishedFileDeleted_t__bindgen_ty_1 =
    RemoteStoragePublishedFileDeleted_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RemoteStoragePublishedFileDeleted_t__bindgen_ty_1 {
    k_iCallback = 1323,
}
#[test]
fn bindgen_test_layout_RemoteStoragePublishedFileDeleted_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStoragePublishedFileDeleted_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStoragePublishedFileDeleted_t>(),
        12usize,
        concat!("Size of: ", stringify!(RemoteStoragePublishedFileDeleted_t))
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStoragePublishedFileDeleted_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStoragePublishedFileDeleted_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStoragePublishedFileDeleted_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nAppID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStoragePublishedFileDeleted_t),
            "::",
            stringify!(m_nAppID)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageUpdateUserPublishedItemVoteResult_t {
    pub m_eResult: EResult,
    pub m_nPublishedFileId: PublishedFileId_t,
}
pub const RemoteStorageUpdateUserPublishedItemVoteResult_t_k_iCallback:
    RemoteStorageUpdateUserPublishedItemVoteResult_t__bindgen_ty_1 =
    RemoteStorageUpdateUserPublishedItemVoteResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RemoteStorageUpdateUserPublishedItemVoteResult_t__bindgen_ty_1 {
    k_iCallback = 1324,
}
#[test]
fn bindgen_test_layout_RemoteStorageUpdateUserPublishedItemVoteResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStorageUpdateUserPublishedItemVoteResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageUpdateUserPublishedItemVoteResult_t>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(RemoteStorageUpdateUserPublishedItemVoteResult_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageUpdateUserPublishedItemVoteResult_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStorageUpdateUserPublishedItemVoteResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageUpdateUserPublishedItemVoteResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageUpdateUserPublishedItemVoteResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageUserVoteDetails_t {
    pub m_eResult: EResult,
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_eVote: EWorkshopVote,
}
pub const RemoteStorageUserVoteDetails_t_k_iCallback: RemoteStorageUserVoteDetails_t__bindgen_ty_1 =
    RemoteStorageUserVoteDetails_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RemoteStorageUserVoteDetails_t__bindgen_ty_1 {
    k_iCallback = 1325,
}
#[test]
fn bindgen_test_layout_RemoteStorageUserVoteDetails_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStorageUserVoteDetails_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageUserVoteDetails_t>(),
        16usize,
        concat!("Size of: ", stringify!(RemoteStorageUserVoteDetails_t))
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageUserVoteDetails_t>(),
        4usize,
        concat!("Alignment of ", stringify!(RemoteStorageUserVoteDetails_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageUserVoteDetails_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageUserVoteDetails_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eVote) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageUserVoteDetails_t),
            "::",
            stringify!(m_eVote)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageEnumerateUserSharedWorkshopFilesResult_t {
    pub m_eResult: EResult,
    pub m_nResultsReturned: int32,
    pub m_nTotalResultCount: int32,
    pub m_rgPublishedFileId: [PublishedFileId_t; 50usize],
}
pub const RemoteStorageEnumerateUserSharedWorkshopFilesResult_t_k_iCallback:
    RemoteStorageEnumerateUserSharedWorkshopFilesResult_t__bindgen_ty_1 =
    RemoteStorageEnumerateUserSharedWorkshopFilesResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RemoteStorageEnumerateUserSharedWorkshopFilesResult_t__bindgen_ty_1 {
    k_iCallback = 1326,
}
#[test]
fn bindgen_test_layout_RemoteStorageEnumerateUserSharedWorkshopFilesResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStorageEnumerateUserSharedWorkshopFilesResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageEnumerateUserSharedWorkshopFilesResult_t>(),
        412usize,
        concat!(
            "Size of: ",
            stringify!(RemoteStorageEnumerateUserSharedWorkshopFilesResult_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageEnumerateUserSharedWorkshopFilesResult_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStorageEnumerateUserSharedWorkshopFilesResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateUserSharedWorkshopFilesResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nResultsReturned) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateUserSharedWorkshopFilesResult_t),
            "::",
            stringify!(m_nResultsReturned)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nTotalResultCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateUserSharedWorkshopFilesResult_t),
            "::",
            stringify!(m_nTotalResultCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgPublishedFileId) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateUserSharedWorkshopFilesResult_t),
            "::",
            stringify!(m_rgPublishedFileId)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageSetUserPublishedFileActionResult_t {
    pub m_eResult: EResult,
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_eAction: EWorkshopFileAction,
}
pub const RemoteStorageSetUserPublishedFileActionResult_t_k_iCallback:
    RemoteStorageSetUserPublishedFileActionResult_t__bindgen_ty_1 =
    RemoteStorageSetUserPublishedFileActionResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RemoteStorageSetUserPublishedFileActionResult_t__bindgen_ty_1 {
    k_iCallback = 1327,
}
#[test]
fn bindgen_test_layout_RemoteStorageSetUserPublishedFileActionResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStorageSetUserPublishedFileActionResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageSetUserPublishedFileActionResult_t>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(RemoteStorageSetUserPublishedFileActionResult_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageSetUserPublishedFileActionResult_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStorageSetUserPublishedFileActionResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageSetUserPublishedFileActionResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageSetUserPublishedFileActionResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eAction) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageSetUserPublishedFileActionResult_t),
            "::",
            stringify!(m_eAction)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageEnumeratePublishedFilesByUserActionResult_t {
    pub m_eResult: EResult,
    pub m_eAction: EWorkshopFileAction,
    pub m_nResultsReturned: int32,
    pub m_nTotalResultCount: int32,
    pub m_rgPublishedFileId: [PublishedFileId_t; 50usize],
    pub m_rgRTimeUpdated: [uint32; 50usize],
}
pub const RemoteStorageEnumeratePublishedFilesByUserActionResult_t_k_iCallback:
    RemoteStorageEnumeratePublishedFilesByUserActionResult_t__bindgen_ty_1 =
    RemoteStorageEnumeratePublishedFilesByUserActionResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RemoteStorageEnumeratePublishedFilesByUserActionResult_t__bindgen_ty_1 {
    k_iCallback = 1328,
}
#[test]
fn bindgen_test_layout_RemoteStorageEnumeratePublishedFilesByUserActionResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<
        RemoteStorageEnumeratePublishedFilesByUserActionResult_t,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageEnumeratePublishedFilesByUserActionResult_t>(),
        616usize,
        concat!(
            "Size of: ",
            stringify!(RemoteStorageEnumeratePublishedFilesByUserActionResult_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageEnumeratePublishedFilesByUserActionResult_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStorageEnumeratePublishedFilesByUserActionResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumeratePublishedFilesByUserActionResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eAction) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumeratePublishedFilesByUserActionResult_t),
            "::",
            stringify!(m_eAction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nResultsReturned) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumeratePublishedFilesByUserActionResult_t),
            "::",
            stringify!(m_nResultsReturned)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nTotalResultCount) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumeratePublishedFilesByUserActionResult_t),
            "::",
            stringify!(m_nTotalResultCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgPublishedFileId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumeratePublishedFilesByUserActionResult_t),
            "::",
            stringify!(m_rgPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgRTimeUpdated) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumeratePublishedFilesByUserActionResult_t),
            "::",
            stringify!(m_rgRTimeUpdated)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStoragePublishFileProgress_t {
    pub m_dPercentFile: f64,
    pub m_bPreview: bool,
}
pub const RemoteStoragePublishFileProgress_t_k_iCallback:
    RemoteStoragePublishFileProgress_t__bindgen_ty_1 =
    RemoteStoragePublishFileProgress_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RemoteStoragePublishFileProgress_t__bindgen_ty_1 {
    k_iCallback = 1329,
}
#[test]
fn bindgen_test_layout_RemoteStoragePublishFileProgress_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStoragePublishFileProgress_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStoragePublishFileProgress_t>(),
        12usize,
        concat!("Size of: ", stringify!(RemoteStoragePublishFileProgress_t))
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStoragePublishFileProgress_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStoragePublishFileProgress_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_dPercentFile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStoragePublishFileProgress_t),
            "::",
            stringify!(m_dPercentFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bPreview) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStoragePublishFileProgress_t),
            "::",
            stringify!(m_bPreview)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStoragePublishedFileUpdated_t {
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_nAppID: AppId_t,
    pub m_ulUnused: uint64,
}
pub const RemoteStoragePublishedFileUpdated_t_k_iCallback:
    RemoteStoragePublishedFileUpdated_t__bindgen_ty_1 =
    RemoteStoragePublishedFileUpdated_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RemoteStoragePublishedFileUpdated_t__bindgen_ty_1 {
    k_iCallback = 1330,
}
#[test]
fn bindgen_test_layout_RemoteStoragePublishedFileUpdated_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStoragePublishedFileUpdated_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStoragePublishedFileUpdated_t>(),
        20usize,
        concat!("Size of: ", stringify!(RemoteStoragePublishedFileUpdated_t))
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStoragePublishedFileUpdated_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStoragePublishedFileUpdated_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStoragePublishedFileUpdated_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nAppID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStoragePublishedFileUpdated_t),
            "::",
            stringify!(m_nAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulUnused) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStoragePublishedFileUpdated_t),
            "::",
            stringify!(m_ulUnused)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageFileWriteAsyncComplete_t {
    pub m_eResult: EResult,
}
pub const RemoteStorageFileWriteAsyncComplete_t_k_iCallback:
    RemoteStorageFileWriteAsyncComplete_t__bindgen_ty_1 =
    RemoteStorageFileWriteAsyncComplete_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RemoteStorageFileWriteAsyncComplete_t__bindgen_ty_1 {
    k_iCallback = 1331,
}
#[test]
fn bindgen_test_layout_RemoteStorageFileWriteAsyncComplete_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStorageFileWriteAsyncComplete_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageFileWriteAsyncComplete_t>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(RemoteStorageFileWriteAsyncComplete_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageFileWriteAsyncComplete_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStorageFileWriteAsyncComplete_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageFileWriteAsyncComplete_t),
            "::",
            stringify!(m_eResult)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageFileReadAsyncComplete_t {
    pub m_hFileReadAsync: SteamAPICall_t,
    pub m_eResult: EResult,
    pub m_nOffset: uint32,
    pub m_cubRead: uint32,
}
pub const RemoteStorageFileReadAsyncComplete_t_k_iCallback:
    RemoteStorageFileReadAsyncComplete_t__bindgen_ty_1 =
    RemoteStorageFileReadAsyncComplete_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RemoteStorageFileReadAsyncComplete_t__bindgen_ty_1 {
    k_iCallback = 1332,
}
#[test]
fn bindgen_test_layout_RemoteStorageFileReadAsyncComplete_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStorageFileReadAsyncComplete_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageFileReadAsyncComplete_t>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(RemoteStorageFileReadAsyncComplete_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageFileReadAsyncComplete_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStorageFileReadAsyncComplete_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hFileReadAsync) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageFileReadAsyncComplete_t),
            "::",
            stringify!(m_hFileReadAsync)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageFileReadAsyncComplete_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nOffset) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageFileReadAsyncComplete_t),
            "::",
            stringify!(m_nOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cubRead) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageFileReadAsyncComplete_t),
            "::",
            stringify!(m_cubRead)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageLocalFileChange_t {
    pub _address: u8,
}
pub const RemoteStorageLocalFileChange_t_k_iCallback: RemoteStorageLocalFileChange_t__bindgen_ty_1 =
    RemoteStorageLocalFileChange_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RemoteStorageLocalFileChange_t__bindgen_ty_1 {
    k_iCallback = 1333,
}
#[test]
fn bindgen_test_layout_RemoteStorageLocalFileChange_t() {
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageLocalFileChange_t>(),
        1usize,
        concat!("Size of: ", stringify!(RemoteStorageLocalFileChange_t))
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageLocalFileChange_t>(),
        1usize,
        concat!("Alignment of ", stringify!(RemoteStorageLocalFileChange_t))
    );
}
pub const k_cchStatNameMax: _bindgen_ty_43 = _bindgen_ty_43::k_cchStatNameMax;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_43 {
    k_cchStatNameMax = 128,
}
pub const k_cchLeaderboardNameMax: _bindgen_ty_44 = _bindgen_ty_44::k_cchLeaderboardNameMax;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_44 {
    k_cchLeaderboardNameMax = 128,
}
pub const k_cLeaderboardDetailsMax: _bindgen_ty_45 = _bindgen_ty_45::k_cLeaderboardDetailsMax;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_45 {
    k_cLeaderboardDetailsMax = 64,
}
pub type SteamLeaderboard_t = uint64;
pub type SteamLeaderboardEntries_t = uint64;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ELeaderboardDataRequest {
    k_ELeaderboardDataRequestGlobal = 0,
    k_ELeaderboardDataRequestGlobalAroundUser = 1,
    k_ELeaderboardDataRequestFriends = 2,
    k_ELeaderboardDataRequestUsers = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ELeaderboardSortMethod {
    k_ELeaderboardSortMethodNone = 0,
    k_ELeaderboardSortMethodAscending = 1,
    k_ELeaderboardSortMethodDescending = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ELeaderboardDisplayType {
    k_ELeaderboardDisplayTypeNone = 0,
    k_ELeaderboardDisplayTypeNumeric = 1,
    k_ELeaderboardDisplayTypeTimeSeconds = 2,
    k_ELeaderboardDisplayTypeTimeMilliSeconds = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ELeaderboardUploadScoreMethod {
    k_ELeaderboardUploadScoreMethodNone = 0,
    k_ELeaderboardUploadScoreMethodKeepBest = 1,
    k_ELeaderboardUploadScoreMethodForceUpdate = 2,
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct LeaderboardEntry_t {
    pub m_steamIDUser: CSteamID,
    pub m_nGlobalRank: int32,
    pub m_nScore: int32,
    pub m_cDetails: int32,
    pub m_hUGC: UGCHandle_t,
}
#[test]
fn bindgen_test_layout_LeaderboardEntry_t() {
    const UNINIT: ::std::mem::MaybeUninit<LeaderboardEntry_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LeaderboardEntry_t>(),
        28usize,
        concat!("Size of: ", stringify!(LeaderboardEntry_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LeaderboardEntry_t>(),
        4usize,
        concat!("Alignment of ", stringify!(LeaderboardEntry_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDUser) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardEntry_t),
            "::",
            stringify!(m_steamIDUser)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nGlobalRank) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardEntry_t),
            "::",
            stringify!(m_nGlobalRank)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nScore) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardEntry_t),
            "::",
            stringify!(m_nScore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cDetails) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardEntry_t),
            "::",
            stringify!(m_cDetails)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hUGC) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardEntry_t),
            "::",
            stringify!(m_hUGC)
        )
    );
}
#[repr(C)]
pub struct ISteamUserStats__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamUserStats {
    pub vtable_: *const ISteamUserStats__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamUserStats() {
    assert_eq!(
        ::std::mem::size_of::<ISteamUserStats>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamUserStats))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamUserStats>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamUserStats))
    );
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct UserStatsReceived_t {
    pub m_nGameID: uint64,
    pub m_eResult: EResult,
    pub m_steamIDUser: CSteamID,
}
pub const UserStatsReceived_t_k_iCallback: UserStatsReceived_t__bindgen_ty_1 =
    UserStatsReceived_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum UserStatsReceived_t__bindgen_ty_1 {
    k_iCallback = 1101,
}
#[test]
fn bindgen_test_layout_UserStatsReceived_t() {
    const UNINIT: ::std::mem::MaybeUninit<UserStatsReceived_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<UserStatsReceived_t>(),
        20usize,
        concat!("Size of: ", stringify!(UserStatsReceived_t))
    );
    assert_eq!(
        ::std::mem::align_of::<UserStatsReceived_t>(),
        4usize,
        concat!("Alignment of ", stringify!(UserStatsReceived_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nGameID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UserStatsReceived_t),
            "::",
            stringify!(m_nGameID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UserStatsReceived_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDUser) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UserStatsReceived_t),
            "::",
            stringify!(m_steamIDUser)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct UserStatsStored_t {
    pub m_nGameID: uint64,
    pub m_eResult: EResult,
}
pub const UserStatsStored_t_k_iCallback: UserStatsStored_t__bindgen_ty_1 =
    UserStatsStored_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum UserStatsStored_t__bindgen_ty_1 {
    k_iCallback = 1102,
}
#[test]
fn bindgen_test_layout_UserStatsStored_t() {
    const UNINIT: ::std::mem::MaybeUninit<UserStatsStored_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<UserStatsStored_t>(),
        12usize,
        concat!("Size of: ", stringify!(UserStatsStored_t))
    );
    assert_eq!(
        ::std::mem::align_of::<UserStatsStored_t>(),
        4usize,
        concat!("Alignment of ", stringify!(UserStatsStored_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nGameID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UserStatsStored_t),
            "::",
            stringify!(m_nGameID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UserStatsStored_t),
            "::",
            stringify!(m_eResult)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct UserAchievementStored_t {
    pub m_nGameID: uint64,
    pub m_bGroupAchievement: bool,
    pub m_rgchAchievementName: [::std::os::raw::c_char; 128usize],
    pub m_nCurProgress: uint32,
    pub m_nMaxProgress: uint32,
}
pub const UserAchievementStored_t_k_iCallback: UserAchievementStored_t__bindgen_ty_1 =
    UserAchievementStored_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum UserAchievementStored_t__bindgen_ty_1 {
    k_iCallback = 1103,
}
#[test]
fn bindgen_test_layout_UserAchievementStored_t() {
    const UNINIT: ::std::mem::MaybeUninit<UserAchievementStored_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<UserAchievementStored_t>(),
        148usize,
        concat!("Size of: ", stringify!(UserAchievementStored_t))
    );
    assert_eq!(
        ::std::mem::align_of::<UserAchievementStored_t>(),
        4usize,
        concat!("Alignment of ", stringify!(UserAchievementStored_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nGameID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UserAchievementStored_t),
            "::",
            stringify!(m_nGameID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bGroupAchievement) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UserAchievementStored_t),
            "::",
            stringify!(m_bGroupAchievement)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchAchievementName) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(UserAchievementStored_t),
            "::",
            stringify!(m_rgchAchievementName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nCurProgress) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(UserAchievementStored_t),
            "::",
            stringify!(m_nCurProgress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nMaxProgress) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(UserAchievementStored_t),
            "::",
            stringify!(m_nMaxProgress)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct LeaderboardFindResult_t {
    pub m_hSteamLeaderboard: SteamLeaderboard_t,
    pub m_bLeaderboardFound: uint8,
}
pub const LeaderboardFindResult_t_k_iCallback: LeaderboardFindResult_t__bindgen_ty_1 =
    LeaderboardFindResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum LeaderboardFindResult_t__bindgen_ty_1 {
    k_iCallback = 1104,
}
#[test]
fn bindgen_test_layout_LeaderboardFindResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<LeaderboardFindResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LeaderboardFindResult_t>(),
        12usize,
        concat!("Size of: ", stringify!(LeaderboardFindResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LeaderboardFindResult_t>(),
        4usize,
        concat!("Alignment of ", stringify!(LeaderboardFindResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hSteamLeaderboard) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardFindResult_t),
            "::",
            stringify!(m_hSteamLeaderboard)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bLeaderboardFound) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardFindResult_t),
            "::",
            stringify!(m_bLeaderboardFound)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct LeaderboardScoresDownloaded_t {
    pub m_hSteamLeaderboard: SteamLeaderboard_t,
    pub m_hSteamLeaderboardEntries: SteamLeaderboardEntries_t,
    pub m_cEntryCount: ::std::os::raw::c_int,
}
pub const LeaderboardScoresDownloaded_t_k_iCallback: LeaderboardScoresDownloaded_t__bindgen_ty_1 =
    LeaderboardScoresDownloaded_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum LeaderboardScoresDownloaded_t__bindgen_ty_1 {
    k_iCallback = 1105,
}
#[test]
fn bindgen_test_layout_LeaderboardScoresDownloaded_t() {
    const UNINIT: ::std::mem::MaybeUninit<LeaderboardScoresDownloaded_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LeaderboardScoresDownloaded_t>(),
        20usize,
        concat!("Size of: ", stringify!(LeaderboardScoresDownloaded_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LeaderboardScoresDownloaded_t>(),
        4usize,
        concat!("Alignment of ", stringify!(LeaderboardScoresDownloaded_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hSteamLeaderboard) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardScoresDownloaded_t),
            "::",
            stringify!(m_hSteamLeaderboard)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hSteamLeaderboardEntries) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardScoresDownloaded_t),
            "::",
            stringify!(m_hSteamLeaderboardEntries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cEntryCount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardScoresDownloaded_t),
            "::",
            stringify!(m_cEntryCount)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct LeaderboardScoreUploaded_t {
    pub m_bSuccess: uint8,
    pub m_hSteamLeaderboard: SteamLeaderboard_t,
    pub m_nScore: int32,
    pub m_bScoreChanged: uint8,
    pub m_nGlobalRankNew: ::std::os::raw::c_int,
    pub m_nGlobalRankPrevious: ::std::os::raw::c_int,
}
pub const LeaderboardScoreUploaded_t_k_iCallback: LeaderboardScoreUploaded_t__bindgen_ty_1 =
    LeaderboardScoreUploaded_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum LeaderboardScoreUploaded_t__bindgen_ty_1 {
    k_iCallback = 1106,
}
#[test]
fn bindgen_test_layout_LeaderboardScoreUploaded_t() {
    const UNINIT: ::std::mem::MaybeUninit<LeaderboardScoreUploaded_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LeaderboardScoreUploaded_t>(),
        28usize,
        concat!("Size of: ", stringify!(LeaderboardScoreUploaded_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LeaderboardScoreUploaded_t>(),
        4usize,
        concat!("Alignment of ", stringify!(LeaderboardScoreUploaded_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bSuccess) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardScoreUploaded_t),
            "::",
            stringify!(m_bSuccess)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hSteamLeaderboard) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardScoreUploaded_t),
            "::",
            stringify!(m_hSteamLeaderboard)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nScore) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardScoreUploaded_t),
            "::",
            stringify!(m_nScore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bScoreChanged) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardScoreUploaded_t),
            "::",
            stringify!(m_bScoreChanged)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nGlobalRankNew) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardScoreUploaded_t),
            "::",
            stringify!(m_nGlobalRankNew)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nGlobalRankPrevious) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardScoreUploaded_t),
            "::",
            stringify!(m_nGlobalRankPrevious)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NumberOfCurrentPlayers_t {
    pub m_bSuccess: uint8,
    pub m_cPlayers: int32,
}
pub const NumberOfCurrentPlayers_t_k_iCallback: NumberOfCurrentPlayers_t__bindgen_ty_1 =
    NumberOfCurrentPlayers_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum NumberOfCurrentPlayers_t__bindgen_ty_1 {
    k_iCallback = 1107,
}
#[test]
fn bindgen_test_layout_NumberOfCurrentPlayers_t() {
    const UNINIT: ::std::mem::MaybeUninit<NumberOfCurrentPlayers_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NumberOfCurrentPlayers_t>(),
        8usize,
        concat!("Size of: ", stringify!(NumberOfCurrentPlayers_t))
    );
    assert_eq!(
        ::std::mem::align_of::<NumberOfCurrentPlayers_t>(),
        4usize,
        concat!("Alignment of ", stringify!(NumberOfCurrentPlayers_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bSuccess) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NumberOfCurrentPlayers_t),
            "::",
            stringify!(m_bSuccess)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cPlayers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NumberOfCurrentPlayers_t),
            "::",
            stringify!(m_cPlayers)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct UserStatsUnloaded_t {
    pub m_steamIDUser: CSteamID,
}
pub const UserStatsUnloaded_t_k_iCallback: UserStatsUnloaded_t__bindgen_ty_1 =
    UserStatsUnloaded_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum UserStatsUnloaded_t__bindgen_ty_1 {
    k_iCallback = 1108,
}
#[test]
fn bindgen_test_layout_UserStatsUnloaded_t() {
    const UNINIT: ::std::mem::MaybeUninit<UserStatsUnloaded_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<UserStatsUnloaded_t>(),
        8usize,
        concat!("Size of: ", stringify!(UserStatsUnloaded_t))
    );
    assert_eq!(
        ::std::mem::align_of::<UserStatsUnloaded_t>(),
        1usize,
        concat!("Alignment of ", stringify!(UserStatsUnloaded_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDUser) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UserStatsUnloaded_t),
            "::",
            stringify!(m_steamIDUser)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct UserAchievementIconFetched_t {
    pub m_nGameID: CGameID,
    pub m_rgchAchievementName: [::std::os::raw::c_char; 128usize],
    pub m_bAchieved: bool,
    pub m_nIconHandle: ::std::os::raw::c_int,
}
pub const UserAchievementIconFetched_t_k_iCallback: UserAchievementIconFetched_t__bindgen_ty_1 =
    UserAchievementIconFetched_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum UserAchievementIconFetched_t__bindgen_ty_1 {
    k_iCallback = 1109,
}
#[test]
fn bindgen_test_layout_UserAchievementIconFetched_t() {
    const UNINIT: ::std::mem::MaybeUninit<UserAchievementIconFetched_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<UserAchievementIconFetched_t>(),
        144usize,
        concat!("Size of: ", stringify!(UserAchievementIconFetched_t))
    );
    assert_eq!(
        ::std::mem::align_of::<UserAchievementIconFetched_t>(),
        4usize,
        concat!("Alignment of ", stringify!(UserAchievementIconFetched_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nGameID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UserAchievementIconFetched_t),
            "::",
            stringify!(m_nGameID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchAchievementName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UserAchievementIconFetched_t),
            "::",
            stringify!(m_rgchAchievementName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bAchieved) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(UserAchievementIconFetched_t),
            "::",
            stringify!(m_bAchieved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nIconHandle) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(UserAchievementIconFetched_t),
            "::",
            stringify!(m_nIconHandle)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct GlobalAchievementPercentagesReady_t {
    pub m_nGameID: uint64,
    pub m_eResult: EResult,
}
pub const GlobalAchievementPercentagesReady_t_k_iCallback:
    GlobalAchievementPercentagesReady_t__bindgen_ty_1 =
    GlobalAchievementPercentagesReady_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GlobalAchievementPercentagesReady_t__bindgen_ty_1 {
    k_iCallback = 1110,
}
#[test]
fn bindgen_test_layout_GlobalAchievementPercentagesReady_t() {
    const UNINIT: ::std::mem::MaybeUninit<GlobalAchievementPercentagesReady_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GlobalAchievementPercentagesReady_t>(),
        12usize,
        concat!("Size of: ", stringify!(GlobalAchievementPercentagesReady_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GlobalAchievementPercentagesReady_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(GlobalAchievementPercentagesReady_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nGameID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GlobalAchievementPercentagesReady_t),
            "::",
            stringify!(m_nGameID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GlobalAchievementPercentagesReady_t),
            "::",
            stringify!(m_eResult)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct LeaderboardUGCSet_t {
    pub m_eResult: EResult,
    pub m_hSteamLeaderboard: SteamLeaderboard_t,
}
pub const LeaderboardUGCSet_t_k_iCallback: LeaderboardUGCSet_t__bindgen_ty_1 =
    LeaderboardUGCSet_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum LeaderboardUGCSet_t__bindgen_ty_1 {
    k_iCallback = 1111,
}
#[test]
fn bindgen_test_layout_LeaderboardUGCSet_t() {
    const UNINIT: ::std::mem::MaybeUninit<LeaderboardUGCSet_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LeaderboardUGCSet_t>(),
        12usize,
        concat!("Size of: ", stringify!(LeaderboardUGCSet_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LeaderboardUGCSet_t>(),
        4usize,
        concat!("Alignment of ", stringify!(LeaderboardUGCSet_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardUGCSet_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hSteamLeaderboard) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardUGCSet_t),
            "::",
            stringify!(m_hSteamLeaderboard)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct GlobalStatsReceived_t {
    pub m_nGameID: uint64,
    pub m_eResult: EResult,
}
pub const GlobalStatsReceived_t_k_iCallback: GlobalStatsReceived_t__bindgen_ty_1 =
    GlobalStatsReceived_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GlobalStatsReceived_t__bindgen_ty_1 {
    k_iCallback = 1112,
}
#[test]
fn bindgen_test_layout_GlobalStatsReceived_t() {
    const UNINIT: ::std::mem::MaybeUninit<GlobalStatsReceived_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GlobalStatsReceived_t>(),
        12usize,
        concat!("Size of: ", stringify!(GlobalStatsReceived_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GlobalStatsReceived_t>(),
        4usize,
        concat!("Alignment of ", stringify!(GlobalStatsReceived_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nGameID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GlobalStatsReceived_t),
            "::",
            stringify!(m_nGameID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GlobalStatsReceived_t),
            "::",
            stringify!(m_eResult)
        )
    );
}
pub const k_cubAppProofOfPurchaseKeyMax: ::std::os::raw::c_int = 240;
#[repr(C)]
pub struct ISteamApps__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamApps {
    pub vtable_: *const ISteamApps__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamApps() {
    assert_eq!(
        ::std::mem::size_of::<ISteamApps>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamApps))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamApps>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamApps))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DlcInstalled_t {
    pub m_nAppID: AppId_t,
}
pub const DlcInstalled_t_k_iCallback: DlcInstalled_t__bindgen_ty_1 =
    DlcInstalled_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum DlcInstalled_t__bindgen_ty_1 {
    k_iCallback = 1005,
}
#[test]
fn bindgen_test_layout_DlcInstalled_t() {
    const UNINIT: ::std::mem::MaybeUninit<DlcInstalled_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DlcInstalled_t>(),
        4usize,
        concat!("Size of: ", stringify!(DlcInstalled_t))
    );
    assert_eq!(
        ::std::mem::align_of::<DlcInstalled_t>(),
        4usize,
        concat!("Alignment of ", stringify!(DlcInstalled_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nAppID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DlcInstalled_t),
            "::",
            stringify!(m_nAppID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NewUrlLaunchParameters_t {
    pub _address: u8,
}
pub const NewUrlLaunchParameters_t_k_iCallback: NewUrlLaunchParameters_t__bindgen_ty_1 =
    NewUrlLaunchParameters_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum NewUrlLaunchParameters_t__bindgen_ty_1 {
    k_iCallback = 1014,
}
#[test]
fn bindgen_test_layout_NewUrlLaunchParameters_t() {
    assert_eq!(
        ::std::mem::size_of::<NewUrlLaunchParameters_t>(),
        1usize,
        concat!("Size of: ", stringify!(NewUrlLaunchParameters_t))
    );
    assert_eq!(
        ::std::mem::align_of::<NewUrlLaunchParameters_t>(),
        1usize,
        concat!("Alignment of ", stringify!(NewUrlLaunchParameters_t))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AppProofOfPurchaseKeyResponse_t {
    pub m_eResult: EResult,
    pub m_nAppID: uint32,
    pub m_cchKeyLength: uint32,
    pub m_rgchKey: [::std::os::raw::c_char; 240usize],
}
pub const AppProofOfPurchaseKeyResponse_t_k_iCallback:
    AppProofOfPurchaseKeyResponse_t__bindgen_ty_1 =
    AppProofOfPurchaseKeyResponse_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AppProofOfPurchaseKeyResponse_t__bindgen_ty_1 {
    k_iCallback = 1021,
}
#[test]
fn bindgen_test_layout_AppProofOfPurchaseKeyResponse_t() {
    const UNINIT: ::std::mem::MaybeUninit<AppProofOfPurchaseKeyResponse_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AppProofOfPurchaseKeyResponse_t>(),
        252usize,
        concat!("Size of: ", stringify!(AppProofOfPurchaseKeyResponse_t))
    );
    assert_eq!(
        ::std::mem::align_of::<AppProofOfPurchaseKeyResponse_t>(),
        4usize,
        concat!("Alignment of ", stringify!(AppProofOfPurchaseKeyResponse_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AppProofOfPurchaseKeyResponse_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nAppID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AppProofOfPurchaseKeyResponse_t),
            "::",
            stringify!(m_nAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cchKeyLength) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AppProofOfPurchaseKeyResponse_t),
            "::",
            stringify!(m_cchKeyLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchKey) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AppProofOfPurchaseKeyResponse_t),
            "::",
            stringify!(m_rgchKey)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct FileDetailsResult_t {
    pub m_eResult: EResult,
    pub m_ulFileSize: uint64,
    pub m_FileSHA: [uint8; 20usize],
    pub m_unFlags: uint32,
}
pub const FileDetailsResult_t_k_iCallback: FileDetailsResult_t__bindgen_ty_1 =
    FileDetailsResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum FileDetailsResult_t__bindgen_ty_1 {
    k_iCallback = 1023,
}
#[test]
fn bindgen_test_layout_FileDetailsResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<FileDetailsResult_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FileDetailsResult_t>(),
        36usize,
        concat!("Size of: ", stringify!(FileDetailsResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<FileDetailsResult_t>(),
        4usize,
        concat!("Alignment of ", stringify!(FileDetailsResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FileDetailsResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulFileSize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FileDetailsResult_t),
            "::",
            stringify!(m_ulFileSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_FileSHA) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FileDetailsResult_t),
            "::",
            stringify!(m_FileSHA)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unFlags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FileDetailsResult_t),
            "::",
            stringify!(m_unFlags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TimedTrialStatus_t {
    pub m_unAppID: AppId_t,
    pub m_bIsOffline: bool,
    pub m_unSecondsAllowed: uint32,
    pub m_unSecondsPlayed: uint32,
}
pub const TimedTrialStatus_t_k_iCallback: TimedTrialStatus_t__bindgen_ty_1 =
    TimedTrialStatus_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum TimedTrialStatus_t__bindgen_ty_1 {
    k_iCallback = 1030,
}
#[test]
fn bindgen_test_layout_TimedTrialStatus_t() {
    const UNINIT: ::std::mem::MaybeUninit<TimedTrialStatus_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TimedTrialStatus_t>(),
        16usize,
        concat!("Size of: ", stringify!(TimedTrialStatus_t))
    );
    assert_eq!(
        ::std::mem::align_of::<TimedTrialStatus_t>(),
        4usize,
        concat!("Alignment of ", stringify!(TimedTrialStatus_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unAppID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TimedTrialStatus_t),
            "::",
            stringify!(m_unAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bIsOffline) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TimedTrialStatus_t),
            "::",
            stringify!(m_bIsOffline)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unSecondsAllowed) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TimedTrialStatus_t),
            "::",
            stringify!(m_unSecondsAllowed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unSecondsPlayed) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TimedTrialStatus_t),
            "::",
            stringify!(m_unSecondsPlayed)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EP2PSessionError {
    k_EP2PSessionErrorNone = 0,
    k_EP2PSessionErrorNoRightsToApp = 2,
    k_EP2PSessionErrorTimeout = 4,
    k_EP2PSessionErrorNotRunningApp_DELETED = 1,
    k_EP2PSessionErrorDestinationNotLoggedIn_DELETED = 3,
    k_EP2PSessionErrorMax = 5,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EP2PSend {
    k_EP2PSendUnreliable = 0,
    k_EP2PSendUnreliableNoDelay = 1,
    k_EP2PSendReliable = 2,
    k_EP2PSendReliableWithBuffering = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct P2PSessionState_t {
    pub m_bConnectionActive: uint8,
    pub m_bConnecting: uint8,
    pub m_eP2PSessionError: uint8,
    pub m_bUsingRelay: uint8,
    pub m_nBytesQueuedForSend: int32,
    pub m_nPacketsQueuedForSend: int32,
    pub m_nRemoteIP: uint32,
    pub m_nRemotePort: uint16,
}
#[test]
fn bindgen_test_layout_P2PSessionState_t() {
    const UNINIT: ::std::mem::MaybeUninit<P2PSessionState_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<P2PSessionState_t>(),
        20usize,
        concat!("Size of: ", stringify!(P2PSessionState_t))
    );
    assert_eq!(
        ::std::mem::align_of::<P2PSessionState_t>(),
        4usize,
        concat!("Alignment of ", stringify!(P2PSessionState_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bConnectionActive) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(P2PSessionState_t),
            "::",
            stringify!(m_bConnectionActive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bConnecting) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(P2PSessionState_t),
            "::",
            stringify!(m_bConnecting)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eP2PSessionError) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(P2PSessionState_t),
            "::",
            stringify!(m_eP2PSessionError)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bUsingRelay) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(P2PSessionState_t),
            "::",
            stringify!(m_bUsingRelay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nBytesQueuedForSend) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(P2PSessionState_t),
            "::",
            stringify!(m_nBytesQueuedForSend)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPacketsQueuedForSend) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(P2PSessionState_t),
            "::",
            stringify!(m_nPacketsQueuedForSend)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nRemoteIP) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(P2PSessionState_t),
            "::",
            stringify!(m_nRemoteIP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nRemotePort) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(P2PSessionState_t),
            "::",
            stringify!(m_nRemotePort)
        )
    );
}
pub type SNetSocket_t = uint32;
pub type SNetListenSocket_t = uint32;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESNetSocketState {
    k_ESNetSocketStateInvalid = 0,
    k_ESNetSocketStateConnected = 1,
    k_ESNetSocketStateInitiated = 10,
    k_ESNetSocketStateLocalCandidatesFound = 11,
    k_ESNetSocketStateReceivedRemoteCandidates = 12,
    k_ESNetSocketStateChallengeHandshake = 15,
    k_ESNetSocketStateDisconnecting = 21,
    k_ESNetSocketStateLocalDisconnect = 22,
    k_ESNetSocketStateTimeoutDuringConnect = 23,
    k_ESNetSocketStateRemoteEndDisconnected = 24,
    k_ESNetSocketStateConnectionBroken = 25,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESNetSocketConnectionType {
    k_ESNetSocketConnectionTypeNotConnected = 0,
    k_ESNetSocketConnectionTypeUDP = 1,
    k_ESNetSocketConnectionTypeUDPRelay = 2,
}
#[repr(C)]
pub struct ISteamNetworking__bindgen_vtable(::std::os::raw::c_void);
#[doc = "      the Steamworks SDK.  Please see ISteamNetworkingSockets and\n      ISteamNetworkingMessages"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamNetworking {
    pub vtable_: *const ISteamNetworking__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamNetworking() {
    assert_eq!(
        ::std::mem::size_of::<ISteamNetworking>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamNetworking))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamNetworking>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamNetworking))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct P2PSessionRequest_t {
    pub m_steamIDRemote: CSteamID,
}
pub const P2PSessionRequest_t_k_iCallback: P2PSessionRequest_t__bindgen_ty_1 =
    P2PSessionRequest_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum P2PSessionRequest_t__bindgen_ty_1 {
    k_iCallback = 1202,
}
#[test]
fn bindgen_test_layout_P2PSessionRequest_t() {
    const UNINIT: ::std::mem::MaybeUninit<P2PSessionRequest_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<P2PSessionRequest_t>(),
        8usize,
        concat!("Size of: ", stringify!(P2PSessionRequest_t))
    );
    assert_eq!(
        ::std::mem::align_of::<P2PSessionRequest_t>(),
        1usize,
        concat!("Alignment of ", stringify!(P2PSessionRequest_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDRemote) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(P2PSessionRequest_t),
            "::",
            stringify!(m_steamIDRemote)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct P2PSessionConnectFail_t {
    pub m_steamIDRemote: CSteamID,
    pub m_eP2PSessionError: uint8,
}
pub const P2PSessionConnectFail_t_k_iCallback: P2PSessionConnectFail_t__bindgen_ty_1 =
    P2PSessionConnectFail_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum P2PSessionConnectFail_t__bindgen_ty_1 {
    k_iCallback = 1203,
}
#[test]
fn bindgen_test_layout_P2PSessionConnectFail_t() {
    const UNINIT: ::std::mem::MaybeUninit<P2PSessionConnectFail_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<P2PSessionConnectFail_t>(),
        9usize,
        concat!("Size of: ", stringify!(P2PSessionConnectFail_t))
    );
    assert_eq!(
        ::std::mem::align_of::<P2PSessionConnectFail_t>(),
        1usize,
        concat!("Alignment of ", stringify!(P2PSessionConnectFail_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDRemote) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(P2PSessionConnectFail_t),
            "::",
            stringify!(m_steamIDRemote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eP2PSessionError) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(P2PSessionConnectFail_t),
            "::",
            stringify!(m_eP2PSessionError)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SocketStatusCallback_t {
    pub m_hSocket: SNetSocket_t,
    pub m_hListenSocket: SNetListenSocket_t,
    pub m_steamIDRemote: CSteamID,
    pub m_eSNetSocketState: ::std::os::raw::c_int,
}
pub const SocketStatusCallback_t_k_iCallback: SocketStatusCallback_t__bindgen_ty_1 =
    SocketStatusCallback_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SocketStatusCallback_t__bindgen_ty_1 {
    k_iCallback = 1201,
}
#[test]
fn bindgen_test_layout_SocketStatusCallback_t() {
    const UNINIT: ::std::mem::MaybeUninit<SocketStatusCallback_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SocketStatusCallback_t>(),
        20usize,
        concat!("Size of: ", stringify!(SocketStatusCallback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SocketStatusCallback_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SocketStatusCallback_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hSocket) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketStatusCallback_t),
            "::",
            stringify!(m_hSocket)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hListenSocket) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketStatusCallback_t),
            "::",
            stringify!(m_hListenSocket)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDRemote) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketStatusCallback_t),
            "::",
            stringify!(m_steamIDRemote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eSNetSocketState) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketStatusCallback_t),
            "::",
            stringify!(m_eSNetSocketState)
        )
    );
}
pub const k_nScreenshotMaxTaggedUsers: uint32 = 32;
pub const k_nScreenshotMaxTaggedPublishedFiles: uint32 = 32;
pub const k_cubUFSTagTypeMax: ::std::os::raw::c_int = 255;
pub const k_cubUFSTagValueMax: ::std::os::raw::c_int = 255;
pub const k_ScreenshotThumbWidth: ::std::os::raw::c_int = 200;
pub type ScreenshotHandle = uint32;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EVRScreenshotType {
    k_EVRScreenshotType_None = 0,
    k_EVRScreenshotType_Mono = 1,
    k_EVRScreenshotType_Stereo = 2,
    k_EVRScreenshotType_MonoCubemap = 3,
    k_EVRScreenshotType_MonoPanorama = 4,
    k_EVRScreenshotType_StereoPanorama = 5,
}
#[repr(C)]
pub struct ISteamScreenshots__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamScreenshots {
    pub vtable_: *const ISteamScreenshots__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamScreenshots() {
    assert_eq!(
        ::std::mem::size_of::<ISteamScreenshots>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamScreenshots))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamScreenshots>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamScreenshots))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScreenshotReady_t {
    pub m_hLocal: ScreenshotHandle,
    pub m_eResult: EResult,
}
pub const ScreenshotReady_t_k_iCallback: ScreenshotReady_t__bindgen_ty_1 =
    ScreenshotReady_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ScreenshotReady_t__bindgen_ty_1 {
    k_iCallback = 2301,
}
#[test]
fn bindgen_test_layout_ScreenshotReady_t() {
    const UNINIT: ::std::mem::MaybeUninit<ScreenshotReady_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ScreenshotReady_t>(),
        8usize,
        concat!("Size of: ", stringify!(ScreenshotReady_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ScreenshotReady_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ScreenshotReady_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hLocal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ScreenshotReady_t),
            "::",
            stringify!(m_hLocal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ScreenshotReady_t),
            "::",
            stringify!(m_eResult)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScreenshotRequested_t {
    pub _address: u8,
}
pub const ScreenshotRequested_t_k_iCallback: ScreenshotRequested_t__bindgen_ty_1 =
    ScreenshotRequested_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ScreenshotRequested_t__bindgen_ty_1 {
    k_iCallback = 2302,
}
#[test]
fn bindgen_test_layout_ScreenshotRequested_t() {
    assert_eq!(
        ::std::mem::size_of::<ScreenshotRequested_t>(),
        1usize,
        concat!("Size of: ", stringify!(ScreenshotRequested_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ScreenshotRequested_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ScreenshotRequested_t))
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AudioPlayback_Status {
    AudioPlayback_Undefined = 0,
    AudioPlayback_Playing = 1,
    AudioPlayback_Paused = 2,
    AudioPlayback_Idle = 3,
}
#[repr(C)]
pub struct ISteamMusic__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamMusic {
    pub vtable_: *const ISteamMusic__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamMusic() {
    assert_eq!(
        ::std::mem::size_of::<ISteamMusic>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamMusic))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamMusic>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamMusic))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PlaybackStatusHasChanged_t {
    pub _address: u8,
}
pub const PlaybackStatusHasChanged_t_k_iCallback: PlaybackStatusHasChanged_t__bindgen_ty_1 =
    PlaybackStatusHasChanged_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum PlaybackStatusHasChanged_t__bindgen_ty_1 {
    k_iCallback = 4001,
}
#[test]
fn bindgen_test_layout_PlaybackStatusHasChanged_t() {
    assert_eq!(
        ::std::mem::size_of::<PlaybackStatusHasChanged_t>(),
        1usize,
        concat!("Size of: ", stringify!(PlaybackStatusHasChanged_t))
    );
    assert_eq!(
        ::std::mem::align_of::<PlaybackStatusHasChanged_t>(),
        1usize,
        concat!("Alignment of ", stringify!(PlaybackStatusHasChanged_t))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VolumeHasChanged_t {
    pub m_flNewVolume: f32,
}
pub const VolumeHasChanged_t_k_iCallback: VolumeHasChanged_t__bindgen_ty_1 =
    VolumeHasChanged_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VolumeHasChanged_t__bindgen_ty_1 {
    k_iCallback = 4002,
}
#[test]
fn bindgen_test_layout_VolumeHasChanged_t() {
    const UNINIT: ::std::mem::MaybeUninit<VolumeHasChanged_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VolumeHasChanged_t>(),
        4usize,
        concat!("Size of: ", stringify!(VolumeHasChanged_t))
    );
    assert_eq!(
        ::std::mem::align_of::<VolumeHasChanged_t>(),
        4usize,
        concat!("Alignment of ", stringify!(VolumeHasChanged_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_flNewVolume) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VolumeHasChanged_t),
            "::",
            stringify!(m_flNewVolume)
        )
    );
}
#[repr(C)]
pub struct ISteamMusicRemote__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamMusicRemote {
    pub vtable_: *const ISteamMusicRemote__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamMusicRemote() {
    assert_eq!(
        ::std::mem::size_of::<ISteamMusicRemote>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamMusicRemote))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamMusicRemote>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamMusicRemote))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MusicPlayerRemoteWillActivate_t {
    pub _address: u8,
}
pub const MusicPlayerRemoteWillActivate_t_k_iCallback:
    MusicPlayerRemoteWillActivate_t__bindgen_ty_1 =
    MusicPlayerRemoteWillActivate_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum MusicPlayerRemoteWillActivate_t__bindgen_ty_1 {
    k_iCallback = 4101,
}
#[test]
fn bindgen_test_layout_MusicPlayerRemoteWillActivate_t() {
    assert_eq!(
        ::std::mem::size_of::<MusicPlayerRemoteWillActivate_t>(),
        1usize,
        concat!("Size of: ", stringify!(MusicPlayerRemoteWillActivate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<MusicPlayerRemoteWillActivate_t>(),
        1usize,
        concat!("Alignment of ", stringify!(MusicPlayerRemoteWillActivate_t))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MusicPlayerRemoteWillDeactivate_t {
    pub _address: u8,
}
pub const MusicPlayerRemoteWillDeactivate_t_k_iCallback:
    MusicPlayerRemoteWillDeactivate_t__bindgen_ty_1 =
    MusicPlayerRemoteWillDeactivate_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum MusicPlayerRemoteWillDeactivate_t__bindgen_ty_1 {
    k_iCallback = 4102,
}
#[test]
fn bindgen_test_layout_MusicPlayerRemoteWillDeactivate_t() {
    assert_eq!(
        ::std::mem::size_of::<MusicPlayerRemoteWillDeactivate_t>(),
        1usize,
        concat!("Size of: ", stringify!(MusicPlayerRemoteWillDeactivate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<MusicPlayerRemoteWillDeactivate_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(MusicPlayerRemoteWillDeactivate_t)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MusicPlayerRemoteToFront_t {
    pub _address: u8,
}
pub const MusicPlayerRemoteToFront_t_k_iCallback: MusicPlayerRemoteToFront_t__bindgen_ty_1 =
    MusicPlayerRemoteToFront_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum MusicPlayerRemoteToFront_t__bindgen_ty_1 {
    k_iCallback = 4103,
}
#[test]
fn bindgen_test_layout_MusicPlayerRemoteToFront_t() {
    assert_eq!(
        ::std::mem::size_of::<MusicPlayerRemoteToFront_t>(),
        1usize,
        concat!("Size of: ", stringify!(MusicPlayerRemoteToFront_t))
    );
    assert_eq!(
        ::std::mem::align_of::<MusicPlayerRemoteToFront_t>(),
        1usize,
        concat!("Alignment of ", stringify!(MusicPlayerRemoteToFront_t))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MusicPlayerWillQuit_t {
    pub _address: u8,
}
pub const MusicPlayerWillQuit_t_k_iCallback: MusicPlayerWillQuit_t__bindgen_ty_1 =
    MusicPlayerWillQuit_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum MusicPlayerWillQuit_t__bindgen_ty_1 {
    k_iCallback = 4104,
}
#[test]
fn bindgen_test_layout_MusicPlayerWillQuit_t() {
    assert_eq!(
        ::std::mem::size_of::<MusicPlayerWillQuit_t>(),
        1usize,
        concat!("Size of: ", stringify!(MusicPlayerWillQuit_t))
    );
    assert_eq!(
        ::std::mem::align_of::<MusicPlayerWillQuit_t>(),
        1usize,
        concat!("Alignment of ", stringify!(MusicPlayerWillQuit_t))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MusicPlayerWantsPlay_t {
    pub _address: u8,
}
pub const MusicPlayerWantsPlay_t_k_iCallback: MusicPlayerWantsPlay_t__bindgen_ty_1 =
    MusicPlayerWantsPlay_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum MusicPlayerWantsPlay_t__bindgen_ty_1 {
    k_iCallback = 4105,
}
#[test]
fn bindgen_test_layout_MusicPlayerWantsPlay_t() {
    assert_eq!(
        ::std::mem::size_of::<MusicPlayerWantsPlay_t>(),
        1usize,
        concat!("Size of: ", stringify!(MusicPlayerWantsPlay_t))
    );
    assert_eq!(
        ::std::mem::align_of::<MusicPlayerWantsPlay_t>(),
        1usize,
        concat!("Alignment of ", stringify!(MusicPlayerWantsPlay_t))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MusicPlayerWantsPause_t {
    pub _address: u8,
}
pub const MusicPlayerWantsPause_t_k_iCallback: MusicPlayerWantsPause_t__bindgen_ty_1 =
    MusicPlayerWantsPause_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum MusicPlayerWantsPause_t__bindgen_ty_1 {
    k_iCallback = 4106,
}
#[test]
fn bindgen_test_layout_MusicPlayerWantsPause_t() {
    assert_eq!(
        ::std::mem::size_of::<MusicPlayerWantsPause_t>(),
        1usize,
        concat!("Size of: ", stringify!(MusicPlayerWantsPause_t))
    );
    assert_eq!(
        ::std::mem::align_of::<MusicPlayerWantsPause_t>(),
        1usize,
        concat!("Alignment of ", stringify!(MusicPlayerWantsPause_t))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MusicPlayerWantsPlayPrevious_t {
    pub _address: u8,
}
pub const MusicPlayerWantsPlayPrevious_t_k_iCallback: MusicPlayerWantsPlayPrevious_t__bindgen_ty_1 =
    MusicPlayerWantsPlayPrevious_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum MusicPlayerWantsPlayPrevious_t__bindgen_ty_1 {
    k_iCallback = 4107,
}
#[test]
fn bindgen_test_layout_MusicPlayerWantsPlayPrevious_t() {
    assert_eq!(
        ::std::mem::size_of::<MusicPlayerWantsPlayPrevious_t>(),
        1usize,
        concat!("Size of: ", stringify!(MusicPlayerWantsPlayPrevious_t))
    );
    assert_eq!(
        ::std::mem::align_of::<MusicPlayerWantsPlayPrevious_t>(),
        1usize,
        concat!("Alignment of ", stringify!(MusicPlayerWantsPlayPrevious_t))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MusicPlayerWantsPlayNext_t {
    pub _address: u8,
}
pub const MusicPlayerWantsPlayNext_t_k_iCallback: MusicPlayerWantsPlayNext_t__bindgen_ty_1 =
    MusicPlayerWantsPlayNext_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum MusicPlayerWantsPlayNext_t__bindgen_ty_1 {
    k_iCallback = 4108,
}
#[test]
fn bindgen_test_layout_MusicPlayerWantsPlayNext_t() {
    assert_eq!(
        ::std::mem::size_of::<MusicPlayerWantsPlayNext_t>(),
        1usize,
        concat!("Size of: ", stringify!(MusicPlayerWantsPlayNext_t))
    );
    assert_eq!(
        ::std::mem::align_of::<MusicPlayerWantsPlayNext_t>(),
        1usize,
        concat!("Alignment of ", stringify!(MusicPlayerWantsPlayNext_t))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MusicPlayerWantsShuffled_t {
    pub m_bShuffled: bool,
}
pub const MusicPlayerWantsShuffled_t_k_iCallback: MusicPlayerWantsShuffled_t__bindgen_ty_1 =
    MusicPlayerWantsShuffled_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum MusicPlayerWantsShuffled_t__bindgen_ty_1 {
    k_iCallback = 4109,
}
#[test]
fn bindgen_test_layout_MusicPlayerWantsShuffled_t() {
    const UNINIT: ::std::mem::MaybeUninit<MusicPlayerWantsShuffled_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MusicPlayerWantsShuffled_t>(),
        1usize,
        concat!("Size of: ", stringify!(MusicPlayerWantsShuffled_t))
    );
    assert_eq!(
        ::std::mem::align_of::<MusicPlayerWantsShuffled_t>(),
        1usize,
        concat!("Alignment of ", stringify!(MusicPlayerWantsShuffled_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bShuffled) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MusicPlayerWantsShuffled_t),
            "::",
            stringify!(m_bShuffled)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MusicPlayerWantsLooped_t {
    pub m_bLooped: bool,
}
pub const MusicPlayerWantsLooped_t_k_iCallback: MusicPlayerWantsLooped_t__bindgen_ty_1 =
    MusicPlayerWantsLooped_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum MusicPlayerWantsLooped_t__bindgen_ty_1 {
    k_iCallback = 4110,
}
#[test]
fn bindgen_test_layout_MusicPlayerWantsLooped_t() {
    const UNINIT: ::std::mem::MaybeUninit<MusicPlayerWantsLooped_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MusicPlayerWantsLooped_t>(),
        1usize,
        concat!("Size of: ", stringify!(MusicPlayerWantsLooped_t))
    );
    assert_eq!(
        ::std::mem::align_of::<MusicPlayerWantsLooped_t>(),
        1usize,
        concat!("Alignment of ", stringify!(MusicPlayerWantsLooped_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bLooped) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MusicPlayerWantsLooped_t),
            "::",
            stringify!(m_bLooped)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MusicPlayerWantsVolume_t {
    pub m_flNewVolume: f32,
}
pub const MusicPlayerWantsVolume_t_k_iCallback: MusicPlayerWantsVolume_t__bindgen_ty_1 =
    MusicPlayerWantsVolume_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum MusicPlayerWantsVolume_t__bindgen_ty_1 {
    k_iCallback = 4011,
}
#[test]
fn bindgen_test_layout_MusicPlayerWantsVolume_t() {
    const UNINIT: ::std::mem::MaybeUninit<MusicPlayerWantsVolume_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MusicPlayerWantsVolume_t>(),
        4usize,
        concat!("Size of: ", stringify!(MusicPlayerWantsVolume_t))
    );
    assert_eq!(
        ::std::mem::align_of::<MusicPlayerWantsVolume_t>(),
        4usize,
        concat!("Alignment of ", stringify!(MusicPlayerWantsVolume_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_flNewVolume) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MusicPlayerWantsVolume_t),
            "::",
            stringify!(m_flNewVolume)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MusicPlayerSelectsQueueEntry_t {
    pub nID: ::std::os::raw::c_int,
}
pub const MusicPlayerSelectsQueueEntry_t_k_iCallback: MusicPlayerSelectsQueueEntry_t__bindgen_ty_1 =
    MusicPlayerSelectsQueueEntry_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum MusicPlayerSelectsQueueEntry_t__bindgen_ty_1 {
    k_iCallback = 4012,
}
#[test]
fn bindgen_test_layout_MusicPlayerSelectsQueueEntry_t() {
    const UNINIT: ::std::mem::MaybeUninit<MusicPlayerSelectsQueueEntry_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MusicPlayerSelectsQueueEntry_t>(),
        4usize,
        concat!("Size of: ", stringify!(MusicPlayerSelectsQueueEntry_t))
    );
    assert_eq!(
        ::std::mem::align_of::<MusicPlayerSelectsQueueEntry_t>(),
        4usize,
        concat!("Alignment of ", stringify!(MusicPlayerSelectsQueueEntry_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MusicPlayerSelectsQueueEntry_t),
            "::",
            stringify!(nID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MusicPlayerSelectsPlaylistEntry_t {
    pub nID: ::std::os::raw::c_int,
}
pub const MusicPlayerSelectsPlaylistEntry_t_k_iCallback:
    MusicPlayerSelectsPlaylistEntry_t__bindgen_ty_1 =
    MusicPlayerSelectsPlaylistEntry_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum MusicPlayerSelectsPlaylistEntry_t__bindgen_ty_1 {
    k_iCallback = 4013,
}
#[test]
fn bindgen_test_layout_MusicPlayerSelectsPlaylistEntry_t() {
    const UNINIT: ::std::mem::MaybeUninit<MusicPlayerSelectsPlaylistEntry_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MusicPlayerSelectsPlaylistEntry_t>(),
        4usize,
        concat!("Size of: ", stringify!(MusicPlayerSelectsPlaylistEntry_t))
    );
    assert_eq!(
        ::std::mem::align_of::<MusicPlayerSelectsPlaylistEntry_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MusicPlayerSelectsPlaylistEntry_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MusicPlayerSelectsPlaylistEntry_t),
            "::",
            stringify!(nID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MusicPlayerWantsPlayingRepeatStatus_t {
    pub m_nPlayingRepeatStatus: ::std::os::raw::c_int,
}
pub const MusicPlayerWantsPlayingRepeatStatus_t_k_iCallback:
    MusicPlayerWantsPlayingRepeatStatus_t__bindgen_ty_1 =
    MusicPlayerWantsPlayingRepeatStatus_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum MusicPlayerWantsPlayingRepeatStatus_t__bindgen_ty_1 {
    k_iCallback = 4114,
}
#[test]
fn bindgen_test_layout_MusicPlayerWantsPlayingRepeatStatus_t() {
    const UNINIT: ::std::mem::MaybeUninit<MusicPlayerWantsPlayingRepeatStatus_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MusicPlayerWantsPlayingRepeatStatus_t>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(MusicPlayerWantsPlayingRepeatStatus_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MusicPlayerWantsPlayingRepeatStatus_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MusicPlayerWantsPlayingRepeatStatus_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPlayingRepeatStatus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MusicPlayerWantsPlayingRepeatStatus_t),
            "::",
            stringify!(m_nPlayingRepeatStatus)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EHTTPMethod {
    k_EHTTPMethodInvalid = 0,
    k_EHTTPMethodGET = 1,
    k_EHTTPMethodHEAD = 2,
    k_EHTTPMethodPOST = 3,
    k_EHTTPMethodPUT = 4,
    k_EHTTPMethodDELETE = 5,
    k_EHTTPMethodOPTIONS = 6,
    k_EHTTPMethodPATCH = 7,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EHTTPStatusCode {
    k_EHTTPStatusCodeInvalid = 0,
    k_EHTTPStatusCode100Continue = 100,
    k_EHTTPStatusCode101SwitchingProtocols = 101,
    k_EHTTPStatusCode200OK = 200,
    k_EHTTPStatusCode201Created = 201,
    k_EHTTPStatusCode202Accepted = 202,
    k_EHTTPStatusCode203NonAuthoritative = 203,
    k_EHTTPStatusCode204NoContent = 204,
    k_EHTTPStatusCode205ResetContent = 205,
    k_EHTTPStatusCode206PartialContent = 206,
    k_EHTTPStatusCode300MultipleChoices = 300,
    k_EHTTPStatusCode301MovedPermanently = 301,
    k_EHTTPStatusCode302Found = 302,
    k_EHTTPStatusCode303SeeOther = 303,
    k_EHTTPStatusCode304NotModified = 304,
    k_EHTTPStatusCode305UseProxy = 305,
    k_EHTTPStatusCode307TemporaryRedirect = 307,
    k_EHTTPStatusCode308PermanentRedirect = 308,
    k_EHTTPStatusCode400BadRequest = 400,
    k_EHTTPStatusCode401Unauthorized = 401,
    k_EHTTPStatusCode402PaymentRequired = 402,
    k_EHTTPStatusCode403Forbidden = 403,
    k_EHTTPStatusCode404NotFound = 404,
    k_EHTTPStatusCode405MethodNotAllowed = 405,
    k_EHTTPStatusCode406NotAcceptable = 406,
    k_EHTTPStatusCode407ProxyAuthRequired = 407,
    k_EHTTPStatusCode408RequestTimeout = 408,
    k_EHTTPStatusCode409Conflict = 409,
    k_EHTTPStatusCode410Gone = 410,
    k_EHTTPStatusCode411LengthRequired = 411,
    k_EHTTPStatusCode412PreconditionFailed = 412,
    k_EHTTPStatusCode413RequestEntityTooLarge = 413,
    k_EHTTPStatusCode414RequestURITooLong = 414,
    k_EHTTPStatusCode415UnsupportedMediaType = 415,
    k_EHTTPStatusCode416RequestedRangeNotSatisfiable = 416,
    k_EHTTPStatusCode417ExpectationFailed = 417,
    k_EHTTPStatusCode4xxUnknown = 418,
    k_EHTTPStatusCode429TooManyRequests = 429,
    k_EHTTPStatusCode444ConnectionClosed = 444,
    k_EHTTPStatusCode500InternalServerError = 500,
    k_EHTTPStatusCode501NotImplemented = 501,
    k_EHTTPStatusCode502BadGateway = 502,
    k_EHTTPStatusCode503ServiceUnavailable = 503,
    k_EHTTPStatusCode504GatewayTimeout = 504,
    k_EHTTPStatusCode505HTTPVersionNotSupported = 505,
    k_EHTTPStatusCode5xxUnknown = 599,
}
pub type HTTPRequestHandle = uint32;
pub type HTTPCookieContainerHandle = uint32;
#[repr(C)]
pub struct ISteamHTTP__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamHTTP {
    pub vtable_: *const ISteamHTTP__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamHTTP() {
    assert_eq!(
        ::std::mem::size_of::<ISteamHTTP>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamHTTP))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamHTTP>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamHTTP))
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct HTTPRequestCompleted_t {
    pub m_hRequest: HTTPRequestHandle,
    pub m_ulContextValue: uint64,
    pub m_bRequestSuccessful: bool,
    pub m_eStatusCode: EHTTPStatusCode,
    pub m_unBodySize: uint32,
}
pub const HTTPRequestCompleted_t_k_iCallback: HTTPRequestCompleted_t__bindgen_ty_1 =
    HTTPRequestCompleted_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HTTPRequestCompleted_t__bindgen_ty_1 {
    k_iCallback = 2101,
}
#[test]
fn bindgen_test_layout_HTTPRequestCompleted_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTTPRequestCompleted_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTTPRequestCompleted_t>(),
        24usize,
        concat!("Size of: ", stringify!(HTTPRequestCompleted_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTTPRequestCompleted_t>(),
        4usize,
        concat!("Alignment of ", stringify!(HTTPRequestCompleted_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hRequest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTTPRequestCompleted_t),
            "::",
            stringify!(m_hRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulContextValue) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HTTPRequestCompleted_t),
            "::",
            stringify!(m_ulContextValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bRequestSuccessful) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HTTPRequestCompleted_t),
            "::",
            stringify!(m_bRequestSuccessful)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eStatusCode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HTTPRequestCompleted_t),
            "::",
            stringify!(m_eStatusCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unBodySize) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HTTPRequestCompleted_t),
            "::",
            stringify!(m_unBodySize)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct HTTPRequestHeadersReceived_t {
    pub m_hRequest: HTTPRequestHandle,
    pub m_ulContextValue: uint64,
}
pub const HTTPRequestHeadersReceived_t_k_iCallback: HTTPRequestHeadersReceived_t__bindgen_ty_1 =
    HTTPRequestHeadersReceived_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HTTPRequestHeadersReceived_t__bindgen_ty_1 {
    k_iCallback = 2102,
}
#[test]
fn bindgen_test_layout_HTTPRequestHeadersReceived_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTTPRequestHeadersReceived_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTTPRequestHeadersReceived_t>(),
        12usize,
        concat!("Size of: ", stringify!(HTTPRequestHeadersReceived_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTTPRequestHeadersReceived_t>(),
        4usize,
        concat!("Alignment of ", stringify!(HTTPRequestHeadersReceived_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hRequest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTTPRequestHeadersReceived_t),
            "::",
            stringify!(m_hRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulContextValue) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HTTPRequestHeadersReceived_t),
            "::",
            stringify!(m_ulContextValue)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct HTTPRequestDataReceived_t {
    pub m_hRequest: HTTPRequestHandle,
    pub m_ulContextValue: uint64,
    pub m_cOffset: uint32,
    pub m_cBytesReceived: uint32,
}
pub const HTTPRequestDataReceived_t_k_iCallback: HTTPRequestDataReceived_t__bindgen_ty_1 =
    HTTPRequestDataReceived_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HTTPRequestDataReceived_t__bindgen_ty_1 {
    k_iCallback = 2103,
}
#[test]
fn bindgen_test_layout_HTTPRequestDataReceived_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTTPRequestDataReceived_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTTPRequestDataReceived_t>(),
        20usize,
        concat!("Size of: ", stringify!(HTTPRequestDataReceived_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTTPRequestDataReceived_t>(),
        4usize,
        concat!("Alignment of ", stringify!(HTTPRequestDataReceived_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hRequest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTTPRequestDataReceived_t),
            "::",
            stringify!(m_hRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulContextValue) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HTTPRequestDataReceived_t),
            "::",
            stringify!(m_ulContextValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cOffset) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HTTPRequestDataReceived_t),
            "::",
            stringify!(m_cOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cBytesReceived) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HTTPRequestDataReceived_t),
            "::",
            stringify!(m_cBytesReceived)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EInputSourceMode {
    k_EInputSourceMode_None = 0,
    k_EInputSourceMode_Dpad = 1,
    k_EInputSourceMode_Buttons = 2,
    k_EInputSourceMode_FourButtons = 3,
    k_EInputSourceMode_AbsoluteMouse = 4,
    k_EInputSourceMode_RelativeMouse = 5,
    k_EInputSourceMode_JoystickMove = 6,
    k_EInputSourceMode_JoystickMouse = 7,
    k_EInputSourceMode_JoystickCamera = 8,
    k_EInputSourceMode_ScrollWheel = 9,
    k_EInputSourceMode_Trigger = 10,
    k_EInputSourceMode_TouchMenu = 11,
    k_EInputSourceMode_MouseJoystick = 12,
    k_EInputSourceMode_MouseRegion = 13,
    k_EInputSourceMode_RadialMenu = 14,
    k_EInputSourceMode_SingleButton = 15,
    k_EInputSourceMode_Switches = 16,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EInputActionOrigin {
    k_EInputActionOrigin_None = 0,
    k_EInputActionOrigin_SteamController_A = 1,
    k_EInputActionOrigin_SteamController_B = 2,
    k_EInputActionOrigin_SteamController_X = 3,
    k_EInputActionOrigin_SteamController_Y = 4,
    k_EInputActionOrigin_SteamController_LeftBumper = 5,
    k_EInputActionOrigin_SteamController_RightBumper = 6,
    k_EInputActionOrigin_SteamController_LeftGrip = 7,
    k_EInputActionOrigin_SteamController_RightGrip = 8,
    k_EInputActionOrigin_SteamController_Start = 9,
    k_EInputActionOrigin_SteamController_Back = 10,
    k_EInputActionOrigin_SteamController_LeftPad_Touch = 11,
    k_EInputActionOrigin_SteamController_LeftPad_Swipe = 12,
    k_EInputActionOrigin_SteamController_LeftPad_Click = 13,
    k_EInputActionOrigin_SteamController_LeftPad_DPadNorth = 14,
    k_EInputActionOrigin_SteamController_LeftPad_DPadSouth = 15,
    k_EInputActionOrigin_SteamController_LeftPad_DPadWest = 16,
    k_EInputActionOrigin_SteamController_LeftPad_DPadEast = 17,
    k_EInputActionOrigin_SteamController_RightPad_Touch = 18,
    k_EInputActionOrigin_SteamController_RightPad_Swipe = 19,
    k_EInputActionOrigin_SteamController_RightPad_Click = 20,
    k_EInputActionOrigin_SteamController_RightPad_DPadNorth = 21,
    k_EInputActionOrigin_SteamController_RightPad_DPadSouth = 22,
    k_EInputActionOrigin_SteamController_RightPad_DPadWest = 23,
    k_EInputActionOrigin_SteamController_RightPad_DPadEast = 24,
    k_EInputActionOrigin_SteamController_LeftTrigger_Pull = 25,
    k_EInputActionOrigin_SteamController_LeftTrigger_Click = 26,
    k_EInputActionOrigin_SteamController_RightTrigger_Pull = 27,
    k_EInputActionOrigin_SteamController_RightTrigger_Click = 28,
    k_EInputActionOrigin_SteamController_LeftStick_Move = 29,
    k_EInputActionOrigin_SteamController_LeftStick_Click = 30,
    k_EInputActionOrigin_SteamController_LeftStick_DPadNorth = 31,
    k_EInputActionOrigin_SteamController_LeftStick_DPadSouth = 32,
    k_EInputActionOrigin_SteamController_LeftStick_DPadWest = 33,
    k_EInputActionOrigin_SteamController_LeftStick_DPadEast = 34,
    k_EInputActionOrigin_SteamController_Gyro_Move = 35,
    k_EInputActionOrigin_SteamController_Gyro_Pitch = 36,
    k_EInputActionOrigin_SteamController_Gyro_Yaw = 37,
    k_EInputActionOrigin_SteamController_Gyro_Roll = 38,
    k_EInputActionOrigin_SteamController_Reserved0 = 39,
    k_EInputActionOrigin_SteamController_Reserved1 = 40,
    k_EInputActionOrigin_SteamController_Reserved2 = 41,
    k_EInputActionOrigin_SteamController_Reserved3 = 42,
    k_EInputActionOrigin_SteamController_Reserved4 = 43,
    k_EInputActionOrigin_SteamController_Reserved5 = 44,
    k_EInputActionOrigin_SteamController_Reserved6 = 45,
    k_EInputActionOrigin_SteamController_Reserved7 = 46,
    k_EInputActionOrigin_SteamController_Reserved8 = 47,
    k_EInputActionOrigin_SteamController_Reserved9 = 48,
    k_EInputActionOrigin_SteamController_Reserved10 = 49,
    k_EInputActionOrigin_PS4_X = 50,
    k_EInputActionOrigin_PS4_Circle = 51,
    k_EInputActionOrigin_PS4_Triangle = 52,
    k_EInputActionOrigin_PS4_Square = 53,
    k_EInputActionOrigin_PS4_LeftBumper = 54,
    k_EInputActionOrigin_PS4_RightBumper = 55,
    k_EInputActionOrigin_PS4_Options = 56,
    k_EInputActionOrigin_PS4_Share = 57,
    k_EInputActionOrigin_PS4_LeftPad_Touch = 58,
    k_EInputActionOrigin_PS4_LeftPad_Swipe = 59,
    k_EInputActionOrigin_PS4_LeftPad_Click = 60,
    k_EInputActionOrigin_PS4_LeftPad_DPadNorth = 61,
    k_EInputActionOrigin_PS4_LeftPad_DPadSouth = 62,
    k_EInputActionOrigin_PS4_LeftPad_DPadWest = 63,
    k_EInputActionOrigin_PS4_LeftPad_DPadEast = 64,
    k_EInputActionOrigin_PS4_RightPad_Touch = 65,
    k_EInputActionOrigin_PS4_RightPad_Swipe = 66,
    k_EInputActionOrigin_PS4_RightPad_Click = 67,
    k_EInputActionOrigin_PS4_RightPad_DPadNorth = 68,
    k_EInputActionOrigin_PS4_RightPad_DPadSouth = 69,
    k_EInputActionOrigin_PS4_RightPad_DPadWest = 70,
    k_EInputActionOrigin_PS4_RightPad_DPadEast = 71,
    k_EInputActionOrigin_PS4_CenterPad_Touch = 72,
    k_EInputActionOrigin_PS4_CenterPad_Swipe = 73,
    k_EInputActionOrigin_PS4_CenterPad_Click = 74,
    k_EInputActionOrigin_PS4_CenterPad_DPadNorth = 75,
    k_EInputActionOrigin_PS4_CenterPad_DPadSouth = 76,
    k_EInputActionOrigin_PS4_CenterPad_DPadWest = 77,
    k_EInputActionOrigin_PS4_CenterPad_DPadEast = 78,
    k_EInputActionOrigin_PS4_LeftTrigger_Pull = 79,
    k_EInputActionOrigin_PS4_LeftTrigger_Click = 80,
    k_EInputActionOrigin_PS4_RightTrigger_Pull = 81,
    k_EInputActionOrigin_PS4_RightTrigger_Click = 82,
    k_EInputActionOrigin_PS4_LeftStick_Move = 83,
    k_EInputActionOrigin_PS4_LeftStick_Click = 84,
    k_EInputActionOrigin_PS4_LeftStick_DPadNorth = 85,
    k_EInputActionOrigin_PS4_LeftStick_DPadSouth = 86,
    k_EInputActionOrigin_PS4_LeftStick_DPadWest = 87,
    k_EInputActionOrigin_PS4_LeftStick_DPadEast = 88,
    k_EInputActionOrigin_PS4_RightStick_Move = 89,
    k_EInputActionOrigin_PS4_RightStick_Click = 90,
    k_EInputActionOrigin_PS4_RightStick_DPadNorth = 91,
    k_EInputActionOrigin_PS4_RightStick_DPadSouth = 92,
    k_EInputActionOrigin_PS4_RightStick_DPadWest = 93,
    k_EInputActionOrigin_PS4_RightStick_DPadEast = 94,
    k_EInputActionOrigin_PS4_DPad_North = 95,
    k_EInputActionOrigin_PS4_DPad_South = 96,
    k_EInputActionOrigin_PS4_DPad_West = 97,
    k_EInputActionOrigin_PS4_DPad_East = 98,
    k_EInputActionOrigin_PS4_Gyro_Move = 99,
    k_EInputActionOrigin_PS4_Gyro_Pitch = 100,
    k_EInputActionOrigin_PS4_Gyro_Yaw = 101,
    k_EInputActionOrigin_PS4_Gyro_Roll = 102,
    k_EInputActionOrigin_PS4_DPad_Move = 103,
    k_EInputActionOrigin_PS4_Reserved1 = 104,
    k_EInputActionOrigin_PS4_Reserved2 = 105,
    k_EInputActionOrigin_PS4_Reserved3 = 106,
    k_EInputActionOrigin_PS4_Reserved4 = 107,
    k_EInputActionOrigin_PS4_Reserved5 = 108,
    k_EInputActionOrigin_PS4_Reserved6 = 109,
    k_EInputActionOrigin_PS4_Reserved7 = 110,
    k_EInputActionOrigin_PS4_Reserved8 = 111,
    k_EInputActionOrigin_PS4_Reserved9 = 112,
    k_EInputActionOrigin_PS4_Reserved10 = 113,
    k_EInputActionOrigin_XBoxOne_A = 114,
    k_EInputActionOrigin_XBoxOne_B = 115,
    k_EInputActionOrigin_XBoxOne_X = 116,
    k_EInputActionOrigin_XBoxOne_Y = 117,
    k_EInputActionOrigin_XBoxOne_LeftBumper = 118,
    k_EInputActionOrigin_XBoxOne_RightBumper = 119,
    k_EInputActionOrigin_XBoxOne_Menu = 120,
    k_EInputActionOrigin_XBoxOne_View = 121,
    k_EInputActionOrigin_XBoxOne_LeftTrigger_Pull = 122,
    k_EInputActionOrigin_XBoxOne_LeftTrigger_Click = 123,
    k_EInputActionOrigin_XBoxOne_RightTrigger_Pull = 124,
    k_EInputActionOrigin_XBoxOne_RightTrigger_Click = 125,
    k_EInputActionOrigin_XBoxOne_LeftStick_Move = 126,
    k_EInputActionOrigin_XBoxOne_LeftStick_Click = 127,
    k_EInputActionOrigin_XBoxOne_LeftStick_DPadNorth = 128,
    k_EInputActionOrigin_XBoxOne_LeftStick_DPadSouth = 129,
    k_EInputActionOrigin_XBoxOne_LeftStick_DPadWest = 130,
    k_EInputActionOrigin_XBoxOne_LeftStick_DPadEast = 131,
    k_EInputActionOrigin_XBoxOne_RightStick_Move = 132,
    k_EInputActionOrigin_XBoxOne_RightStick_Click = 133,
    k_EInputActionOrigin_XBoxOne_RightStick_DPadNorth = 134,
    k_EInputActionOrigin_XBoxOne_RightStick_DPadSouth = 135,
    k_EInputActionOrigin_XBoxOne_RightStick_DPadWest = 136,
    k_EInputActionOrigin_XBoxOne_RightStick_DPadEast = 137,
    k_EInputActionOrigin_XBoxOne_DPad_North = 138,
    k_EInputActionOrigin_XBoxOne_DPad_South = 139,
    k_EInputActionOrigin_XBoxOne_DPad_West = 140,
    k_EInputActionOrigin_XBoxOne_DPad_East = 141,
    k_EInputActionOrigin_XBoxOne_DPad_Move = 142,
    k_EInputActionOrigin_XBoxOne_LeftGrip_Lower = 143,
    k_EInputActionOrigin_XBoxOne_LeftGrip_Upper = 144,
    k_EInputActionOrigin_XBoxOne_RightGrip_Lower = 145,
    k_EInputActionOrigin_XBoxOne_RightGrip_Upper = 146,
    k_EInputActionOrigin_XBoxOne_Share = 147,
    k_EInputActionOrigin_XBoxOne_Reserved6 = 148,
    k_EInputActionOrigin_XBoxOne_Reserved7 = 149,
    k_EInputActionOrigin_XBoxOne_Reserved8 = 150,
    k_EInputActionOrigin_XBoxOne_Reserved9 = 151,
    k_EInputActionOrigin_XBoxOne_Reserved10 = 152,
    k_EInputActionOrigin_XBox360_A = 153,
    k_EInputActionOrigin_XBox360_B = 154,
    k_EInputActionOrigin_XBox360_X = 155,
    k_EInputActionOrigin_XBox360_Y = 156,
    k_EInputActionOrigin_XBox360_LeftBumper = 157,
    k_EInputActionOrigin_XBox360_RightBumper = 158,
    k_EInputActionOrigin_XBox360_Start = 159,
    k_EInputActionOrigin_XBox360_Back = 160,
    k_EInputActionOrigin_XBox360_LeftTrigger_Pull = 161,
    k_EInputActionOrigin_XBox360_LeftTrigger_Click = 162,
    k_EInputActionOrigin_XBox360_RightTrigger_Pull = 163,
    k_EInputActionOrigin_XBox360_RightTrigger_Click = 164,
    k_EInputActionOrigin_XBox360_LeftStick_Move = 165,
    k_EInputActionOrigin_XBox360_LeftStick_Click = 166,
    k_EInputActionOrigin_XBox360_LeftStick_DPadNorth = 167,
    k_EInputActionOrigin_XBox360_LeftStick_DPadSouth = 168,
    k_EInputActionOrigin_XBox360_LeftStick_DPadWest = 169,
    k_EInputActionOrigin_XBox360_LeftStick_DPadEast = 170,
    k_EInputActionOrigin_XBox360_RightStick_Move = 171,
    k_EInputActionOrigin_XBox360_RightStick_Click = 172,
    k_EInputActionOrigin_XBox360_RightStick_DPadNorth = 173,
    k_EInputActionOrigin_XBox360_RightStick_DPadSouth = 174,
    k_EInputActionOrigin_XBox360_RightStick_DPadWest = 175,
    k_EInputActionOrigin_XBox360_RightStick_DPadEast = 176,
    k_EInputActionOrigin_XBox360_DPad_North = 177,
    k_EInputActionOrigin_XBox360_DPad_South = 178,
    k_EInputActionOrigin_XBox360_DPad_West = 179,
    k_EInputActionOrigin_XBox360_DPad_East = 180,
    k_EInputActionOrigin_XBox360_DPad_Move = 181,
    k_EInputActionOrigin_XBox360_Reserved1 = 182,
    k_EInputActionOrigin_XBox360_Reserved2 = 183,
    k_EInputActionOrigin_XBox360_Reserved3 = 184,
    k_EInputActionOrigin_XBox360_Reserved4 = 185,
    k_EInputActionOrigin_XBox360_Reserved5 = 186,
    k_EInputActionOrigin_XBox360_Reserved6 = 187,
    k_EInputActionOrigin_XBox360_Reserved7 = 188,
    k_EInputActionOrigin_XBox360_Reserved8 = 189,
    k_EInputActionOrigin_XBox360_Reserved9 = 190,
    k_EInputActionOrigin_XBox360_Reserved10 = 191,
    k_EInputActionOrigin_Switch_A = 192,
    k_EInputActionOrigin_Switch_B = 193,
    k_EInputActionOrigin_Switch_X = 194,
    k_EInputActionOrigin_Switch_Y = 195,
    k_EInputActionOrigin_Switch_LeftBumper = 196,
    k_EInputActionOrigin_Switch_RightBumper = 197,
    k_EInputActionOrigin_Switch_Plus = 198,
    k_EInputActionOrigin_Switch_Minus = 199,
    k_EInputActionOrigin_Switch_Capture = 200,
    k_EInputActionOrigin_Switch_LeftTrigger_Pull = 201,
    k_EInputActionOrigin_Switch_LeftTrigger_Click = 202,
    k_EInputActionOrigin_Switch_RightTrigger_Pull = 203,
    k_EInputActionOrigin_Switch_RightTrigger_Click = 204,
    k_EInputActionOrigin_Switch_LeftStick_Move = 205,
    k_EInputActionOrigin_Switch_LeftStick_Click = 206,
    k_EInputActionOrigin_Switch_LeftStick_DPadNorth = 207,
    k_EInputActionOrigin_Switch_LeftStick_DPadSouth = 208,
    k_EInputActionOrigin_Switch_LeftStick_DPadWest = 209,
    k_EInputActionOrigin_Switch_LeftStick_DPadEast = 210,
    k_EInputActionOrigin_Switch_RightStick_Move = 211,
    k_EInputActionOrigin_Switch_RightStick_Click = 212,
    k_EInputActionOrigin_Switch_RightStick_DPadNorth = 213,
    k_EInputActionOrigin_Switch_RightStick_DPadSouth = 214,
    k_EInputActionOrigin_Switch_RightStick_DPadWest = 215,
    k_EInputActionOrigin_Switch_RightStick_DPadEast = 216,
    k_EInputActionOrigin_Switch_DPad_North = 217,
    k_EInputActionOrigin_Switch_DPad_South = 218,
    k_EInputActionOrigin_Switch_DPad_West = 219,
    k_EInputActionOrigin_Switch_DPad_East = 220,
    k_EInputActionOrigin_Switch_ProGyro_Move = 221,
    k_EInputActionOrigin_Switch_ProGyro_Pitch = 222,
    k_EInputActionOrigin_Switch_ProGyro_Yaw = 223,
    k_EInputActionOrigin_Switch_ProGyro_Roll = 224,
    k_EInputActionOrigin_Switch_DPad_Move = 225,
    k_EInputActionOrigin_Switch_Reserved1 = 226,
    k_EInputActionOrigin_Switch_Reserved2 = 227,
    k_EInputActionOrigin_Switch_Reserved3 = 228,
    k_EInputActionOrigin_Switch_Reserved4 = 229,
    k_EInputActionOrigin_Switch_Reserved5 = 230,
    k_EInputActionOrigin_Switch_Reserved6 = 231,
    k_EInputActionOrigin_Switch_Reserved7 = 232,
    k_EInputActionOrigin_Switch_Reserved8 = 233,
    k_EInputActionOrigin_Switch_Reserved9 = 234,
    k_EInputActionOrigin_Switch_Reserved10 = 235,
    k_EInputActionOrigin_Switch_RightGyro_Move = 236,
    k_EInputActionOrigin_Switch_RightGyro_Pitch = 237,
    k_EInputActionOrigin_Switch_RightGyro_Yaw = 238,
    k_EInputActionOrigin_Switch_RightGyro_Roll = 239,
    k_EInputActionOrigin_Switch_LeftGyro_Move = 240,
    k_EInputActionOrigin_Switch_LeftGyro_Pitch = 241,
    k_EInputActionOrigin_Switch_LeftGyro_Yaw = 242,
    k_EInputActionOrigin_Switch_LeftGyro_Roll = 243,
    k_EInputActionOrigin_Switch_LeftGrip_Lower = 244,
    k_EInputActionOrigin_Switch_LeftGrip_Upper = 245,
    k_EInputActionOrigin_Switch_RightGrip_Lower = 246,
    k_EInputActionOrigin_Switch_RightGrip_Upper = 247,
    k_EInputActionOrigin_Switch_JoyConButton_N = 248,
    k_EInputActionOrigin_Switch_JoyConButton_E = 249,
    k_EInputActionOrigin_Switch_JoyConButton_S = 250,
    k_EInputActionOrigin_Switch_JoyConButton_W = 251,
    k_EInputActionOrigin_Switch_Reserved15 = 252,
    k_EInputActionOrigin_Switch_Reserved16 = 253,
    k_EInputActionOrigin_Switch_Reserved17 = 254,
    k_EInputActionOrigin_Switch_Reserved18 = 255,
    k_EInputActionOrigin_Switch_Reserved19 = 256,
    k_EInputActionOrigin_Switch_Reserved20 = 257,
    k_EInputActionOrigin_PS5_X = 258,
    k_EInputActionOrigin_PS5_Circle = 259,
    k_EInputActionOrigin_PS5_Triangle = 260,
    k_EInputActionOrigin_PS5_Square = 261,
    k_EInputActionOrigin_PS5_LeftBumper = 262,
    k_EInputActionOrigin_PS5_RightBumper = 263,
    k_EInputActionOrigin_PS5_Option = 264,
    k_EInputActionOrigin_PS5_Create = 265,
    k_EInputActionOrigin_PS5_Mute = 266,
    k_EInputActionOrigin_PS5_LeftPad_Touch = 267,
    k_EInputActionOrigin_PS5_LeftPad_Swipe = 268,
    k_EInputActionOrigin_PS5_LeftPad_Click = 269,
    k_EInputActionOrigin_PS5_LeftPad_DPadNorth = 270,
    k_EInputActionOrigin_PS5_LeftPad_DPadSouth = 271,
    k_EInputActionOrigin_PS5_LeftPad_DPadWest = 272,
    k_EInputActionOrigin_PS5_LeftPad_DPadEast = 273,
    k_EInputActionOrigin_PS5_RightPad_Touch = 274,
    k_EInputActionOrigin_PS5_RightPad_Swipe = 275,
    k_EInputActionOrigin_PS5_RightPad_Click = 276,
    k_EInputActionOrigin_PS5_RightPad_DPadNorth = 277,
    k_EInputActionOrigin_PS5_RightPad_DPadSouth = 278,
    k_EInputActionOrigin_PS5_RightPad_DPadWest = 279,
    k_EInputActionOrigin_PS5_RightPad_DPadEast = 280,
    k_EInputActionOrigin_PS5_CenterPad_Touch = 281,
    k_EInputActionOrigin_PS5_CenterPad_Swipe = 282,
    k_EInputActionOrigin_PS5_CenterPad_Click = 283,
    k_EInputActionOrigin_PS5_CenterPad_DPadNorth = 284,
    k_EInputActionOrigin_PS5_CenterPad_DPadSouth = 285,
    k_EInputActionOrigin_PS5_CenterPad_DPadWest = 286,
    k_EInputActionOrigin_PS5_CenterPad_DPadEast = 287,
    k_EInputActionOrigin_PS5_LeftTrigger_Pull = 288,
    k_EInputActionOrigin_PS5_LeftTrigger_Click = 289,
    k_EInputActionOrigin_PS5_RightTrigger_Pull = 290,
    k_EInputActionOrigin_PS5_RightTrigger_Click = 291,
    k_EInputActionOrigin_PS5_LeftStick_Move = 292,
    k_EInputActionOrigin_PS5_LeftStick_Click = 293,
    k_EInputActionOrigin_PS5_LeftStick_DPadNorth = 294,
    k_EInputActionOrigin_PS5_LeftStick_DPadSouth = 295,
    k_EInputActionOrigin_PS5_LeftStick_DPadWest = 296,
    k_EInputActionOrigin_PS5_LeftStick_DPadEast = 297,
    k_EInputActionOrigin_PS5_RightStick_Move = 298,
    k_EInputActionOrigin_PS5_RightStick_Click = 299,
    k_EInputActionOrigin_PS5_RightStick_DPadNorth = 300,
    k_EInputActionOrigin_PS5_RightStick_DPadSouth = 301,
    k_EInputActionOrigin_PS5_RightStick_DPadWest = 302,
    k_EInputActionOrigin_PS5_RightStick_DPadEast = 303,
    k_EInputActionOrigin_PS5_DPad_North = 304,
    k_EInputActionOrigin_PS5_DPad_South = 305,
    k_EInputActionOrigin_PS5_DPad_West = 306,
    k_EInputActionOrigin_PS5_DPad_East = 307,
    k_EInputActionOrigin_PS5_Gyro_Move = 308,
    k_EInputActionOrigin_PS5_Gyro_Pitch = 309,
    k_EInputActionOrigin_PS5_Gyro_Yaw = 310,
    k_EInputActionOrigin_PS5_Gyro_Roll = 311,
    k_EInputActionOrigin_PS5_DPad_Move = 312,
    k_EInputActionOrigin_PS5_LeftGrip = 313,
    k_EInputActionOrigin_PS5_RightGrip = 314,
    k_EInputActionOrigin_PS5_LeftFn = 315,
    k_EInputActionOrigin_PS5_RightFn = 316,
    k_EInputActionOrigin_PS5_Reserved5 = 317,
    k_EInputActionOrigin_PS5_Reserved6 = 318,
    k_EInputActionOrigin_PS5_Reserved7 = 319,
    k_EInputActionOrigin_PS5_Reserved8 = 320,
    k_EInputActionOrigin_PS5_Reserved9 = 321,
    k_EInputActionOrigin_PS5_Reserved10 = 322,
    k_EInputActionOrigin_PS5_Reserved11 = 323,
    k_EInputActionOrigin_PS5_Reserved12 = 324,
    k_EInputActionOrigin_PS5_Reserved13 = 325,
    k_EInputActionOrigin_PS5_Reserved14 = 326,
    k_EInputActionOrigin_PS5_Reserved15 = 327,
    k_EInputActionOrigin_PS5_Reserved16 = 328,
    k_EInputActionOrigin_PS5_Reserved17 = 329,
    k_EInputActionOrigin_PS5_Reserved18 = 330,
    k_EInputActionOrigin_PS5_Reserved19 = 331,
    k_EInputActionOrigin_PS5_Reserved20 = 332,
    k_EInputActionOrigin_SteamDeck_A = 333,
    k_EInputActionOrigin_SteamDeck_B = 334,
    k_EInputActionOrigin_SteamDeck_X = 335,
    k_EInputActionOrigin_SteamDeck_Y = 336,
    k_EInputActionOrigin_SteamDeck_L1 = 337,
    k_EInputActionOrigin_SteamDeck_R1 = 338,
    k_EInputActionOrigin_SteamDeck_Menu = 339,
    k_EInputActionOrigin_SteamDeck_View = 340,
    k_EInputActionOrigin_SteamDeck_LeftPad_Touch = 341,
    k_EInputActionOrigin_SteamDeck_LeftPad_Swipe = 342,
    k_EInputActionOrigin_SteamDeck_LeftPad_Click = 343,
    k_EInputActionOrigin_SteamDeck_LeftPad_DPadNorth = 344,
    k_EInputActionOrigin_SteamDeck_LeftPad_DPadSouth = 345,
    k_EInputActionOrigin_SteamDeck_LeftPad_DPadWest = 346,
    k_EInputActionOrigin_SteamDeck_LeftPad_DPadEast = 347,
    k_EInputActionOrigin_SteamDeck_RightPad_Touch = 348,
    k_EInputActionOrigin_SteamDeck_RightPad_Swipe = 349,
    k_EInputActionOrigin_SteamDeck_RightPad_Click = 350,
    k_EInputActionOrigin_SteamDeck_RightPad_DPadNorth = 351,
    k_EInputActionOrigin_SteamDeck_RightPad_DPadSouth = 352,
    k_EInputActionOrigin_SteamDeck_RightPad_DPadWest = 353,
    k_EInputActionOrigin_SteamDeck_RightPad_DPadEast = 354,
    k_EInputActionOrigin_SteamDeck_L2_SoftPull = 355,
    k_EInputActionOrigin_SteamDeck_L2 = 356,
    k_EInputActionOrigin_SteamDeck_R2_SoftPull = 357,
    k_EInputActionOrigin_SteamDeck_R2 = 358,
    k_EInputActionOrigin_SteamDeck_LeftStick_Move = 359,
    k_EInputActionOrigin_SteamDeck_L3 = 360,
    k_EInputActionOrigin_SteamDeck_LeftStick_DPadNorth = 361,
    k_EInputActionOrigin_SteamDeck_LeftStick_DPadSouth = 362,
    k_EInputActionOrigin_SteamDeck_LeftStick_DPadWest = 363,
    k_EInputActionOrigin_SteamDeck_LeftStick_DPadEast = 364,
    k_EInputActionOrigin_SteamDeck_LeftStick_Touch = 365,
    k_EInputActionOrigin_SteamDeck_RightStick_Move = 366,
    k_EInputActionOrigin_SteamDeck_R3 = 367,
    k_EInputActionOrigin_SteamDeck_RightStick_DPadNorth = 368,
    k_EInputActionOrigin_SteamDeck_RightStick_DPadSouth = 369,
    k_EInputActionOrigin_SteamDeck_RightStick_DPadWest = 370,
    k_EInputActionOrigin_SteamDeck_RightStick_DPadEast = 371,
    k_EInputActionOrigin_SteamDeck_RightStick_Touch = 372,
    k_EInputActionOrigin_SteamDeck_L4 = 373,
    k_EInputActionOrigin_SteamDeck_R4 = 374,
    k_EInputActionOrigin_SteamDeck_L5 = 375,
    k_EInputActionOrigin_SteamDeck_R5 = 376,
    k_EInputActionOrigin_SteamDeck_DPad_Move = 377,
    k_EInputActionOrigin_SteamDeck_DPad_North = 378,
    k_EInputActionOrigin_SteamDeck_DPad_South = 379,
    k_EInputActionOrigin_SteamDeck_DPad_West = 380,
    k_EInputActionOrigin_SteamDeck_DPad_East = 381,
    k_EInputActionOrigin_SteamDeck_Gyro_Move = 382,
    k_EInputActionOrigin_SteamDeck_Gyro_Pitch = 383,
    k_EInputActionOrigin_SteamDeck_Gyro_Yaw = 384,
    k_EInputActionOrigin_SteamDeck_Gyro_Roll = 385,
    k_EInputActionOrigin_SteamDeck_Reserved1 = 386,
    k_EInputActionOrigin_SteamDeck_Reserved2 = 387,
    k_EInputActionOrigin_SteamDeck_Reserved3 = 388,
    k_EInputActionOrigin_SteamDeck_Reserved4 = 389,
    k_EInputActionOrigin_SteamDeck_Reserved5 = 390,
    k_EInputActionOrigin_SteamDeck_Reserved6 = 391,
    k_EInputActionOrigin_SteamDeck_Reserved7 = 392,
    k_EInputActionOrigin_SteamDeck_Reserved8 = 393,
    k_EInputActionOrigin_SteamDeck_Reserved9 = 394,
    k_EInputActionOrigin_SteamDeck_Reserved10 = 395,
    k_EInputActionOrigin_SteamDeck_Reserved11 = 396,
    k_EInputActionOrigin_SteamDeck_Reserved12 = 397,
    k_EInputActionOrigin_SteamDeck_Reserved13 = 398,
    k_EInputActionOrigin_SteamDeck_Reserved14 = 399,
    k_EInputActionOrigin_SteamDeck_Reserved15 = 400,
    k_EInputActionOrigin_SteamDeck_Reserved16 = 401,
    k_EInputActionOrigin_SteamDeck_Reserved17 = 402,
    k_EInputActionOrigin_SteamDeck_Reserved18 = 403,
    k_EInputActionOrigin_SteamDeck_Reserved19 = 404,
    k_EInputActionOrigin_SteamDeck_Reserved20 = 405,
    k_EInputActionOrigin_Horipad_M1 = 406,
    k_EInputActionOrigin_Horipad_M2 = 407,
    k_EInputActionOrigin_Horipad_L4 = 408,
    k_EInputActionOrigin_Horipad_R4 = 409,
    k_EInputActionOrigin_Count = 410,
    k_EInputActionOrigin_MaximumPossibleValue = 32767,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EXboxOrigin {
    k_EXboxOrigin_A = 0,
    k_EXboxOrigin_B = 1,
    k_EXboxOrigin_X = 2,
    k_EXboxOrigin_Y = 3,
    k_EXboxOrigin_LeftBumper = 4,
    k_EXboxOrigin_RightBumper = 5,
    k_EXboxOrigin_Menu = 6,
    k_EXboxOrigin_View = 7,
    k_EXboxOrigin_LeftTrigger_Pull = 8,
    k_EXboxOrigin_LeftTrigger_Click = 9,
    k_EXboxOrigin_RightTrigger_Pull = 10,
    k_EXboxOrigin_RightTrigger_Click = 11,
    k_EXboxOrigin_LeftStick_Move = 12,
    k_EXboxOrigin_LeftStick_Click = 13,
    k_EXboxOrigin_LeftStick_DPadNorth = 14,
    k_EXboxOrigin_LeftStick_DPadSouth = 15,
    k_EXboxOrigin_LeftStick_DPadWest = 16,
    k_EXboxOrigin_LeftStick_DPadEast = 17,
    k_EXboxOrigin_RightStick_Move = 18,
    k_EXboxOrigin_RightStick_Click = 19,
    k_EXboxOrigin_RightStick_DPadNorth = 20,
    k_EXboxOrigin_RightStick_DPadSouth = 21,
    k_EXboxOrigin_RightStick_DPadWest = 22,
    k_EXboxOrigin_RightStick_DPadEast = 23,
    k_EXboxOrigin_DPad_North = 24,
    k_EXboxOrigin_DPad_South = 25,
    k_EXboxOrigin_DPad_West = 26,
    k_EXboxOrigin_DPad_East = 27,
    k_EXboxOrigin_Count = 28,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamControllerPad {
    k_ESteamControllerPad_Left = 0,
    k_ESteamControllerPad_Right = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EControllerHapticLocation {
    k_EControllerHapticLocation_Left = 1,
    k_EControllerHapticLocation_Right = 2,
    k_EControllerHapticLocation_Both = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EControllerHapticType {
    k_EControllerHapticType_Off = 0,
    k_EControllerHapticType_Tick = 1,
    k_EControllerHapticType_Click = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamInputType {
    k_ESteamInputType_Unknown = 0,
    k_ESteamInputType_SteamController = 1,
    k_ESteamInputType_XBox360Controller = 2,
    k_ESteamInputType_XBoxOneController = 3,
    k_ESteamInputType_GenericGamepad = 4,
    k_ESteamInputType_PS4Controller = 5,
    k_ESteamInputType_AppleMFiController = 6,
    k_ESteamInputType_AndroidController = 7,
    k_ESteamInputType_SwitchJoyConPair = 8,
    k_ESteamInputType_SwitchJoyConSingle = 9,
    k_ESteamInputType_SwitchProController = 10,
    k_ESteamInputType_MobileTouch = 11,
    k_ESteamInputType_PS3Controller = 12,
    k_ESteamInputType_PS5Controller = 13,
    k_ESteamInputType_SteamDeckController = 14,
    k_ESteamInputType_Count = 15,
    k_ESteamInputType_MaximumPossibleValue = 255,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamInputConfigurationEnableType {
    k_ESteamInputConfigurationEnableType_None = 0,
    k_ESteamInputConfigurationEnableType_Playstation = 1,
    k_ESteamInputConfigurationEnableType_Xbox = 2,
    k_ESteamInputConfigurationEnableType_Generic = 4,
    k_ESteamInputConfigurationEnableType_Switch = 8,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamInputLEDFlag {
    k_ESteamInputLEDFlag_SetColor = 0,
    k_ESteamInputLEDFlag_RestoreUserDefault = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamInputGlyphSize {
    k_ESteamInputGlyphSize_Small = 0,
    k_ESteamInputGlyphSize_Medium = 1,
    k_ESteamInputGlyphSize_Large = 2,
    k_ESteamInputGlyphSize_Count = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamInputGlyphStyle {
    ESteamInputGlyphStyle_Knockout = 0,
    ESteamInputGlyphStyle_Light = 1,
    ESteamInputGlyphStyle_Dark = 2,
    ESteamInputGlyphStyle_NeutralColorABXY = 16,
    ESteamInputGlyphStyle_SolidABXY = 32,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamInputActionEventType {
    ESteamInputActionEventType_DigitalAction = 0,
    ESteamInputActionEventType_AnalogAction = 1,
}
pub type InputHandle_t = uint64;
pub type InputActionSetHandle_t = uint64;
pub type InputDigitalActionHandle_t = uint64;
pub type InputAnalogActionHandle_t = uint64;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct InputAnalogActionData_t {
    pub eMode: EInputSourceMode,
    pub x: f32,
    pub y: f32,
    pub bActive: bool,
}
#[test]
fn bindgen_test_layout_InputAnalogActionData_t() {
    const UNINIT: ::std::mem::MaybeUninit<InputAnalogActionData_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<InputAnalogActionData_t>(),
        13usize,
        concat!("Size of: ", stringify!(InputAnalogActionData_t))
    );
    assert_eq!(
        ::std::mem::align_of::<InputAnalogActionData_t>(),
        1usize,
        concat!("Alignment of ", stringify!(InputAnalogActionData_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eMode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InputAnalogActionData_t),
            "::",
            stringify!(eMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(InputAnalogActionData_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(InputAnalogActionData_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bActive) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(InputAnalogActionData_t),
            "::",
            stringify!(bActive)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InputDigitalActionData_t {
    pub bState: bool,
    pub bActive: bool,
}
#[test]
fn bindgen_test_layout_InputDigitalActionData_t() {
    const UNINIT: ::std::mem::MaybeUninit<InputDigitalActionData_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<InputDigitalActionData_t>(),
        2usize,
        concat!("Size of: ", stringify!(InputDigitalActionData_t))
    );
    assert_eq!(
        ::std::mem::align_of::<InputDigitalActionData_t>(),
        1usize,
        concat!("Alignment of ", stringify!(InputDigitalActionData_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InputDigitalActionData_t),
            "::",
            stringify!(bState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bActive) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(InputDigitalActionData_t),
            "::",
            stringify!(bActive)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct InputMotionData_t {
    pub rotQuatX: f32,
    pub rotQuatY: f32,
    pub rotQuatZ: f32,
    pub rotQuatW: f32,
    pub posAccelX: f32,
    pub posAccelY: f32,
    pub posAccelZ: f32,
    pub rotVelX: f32,
    pub rotVelY: f32,
    pub rotVelZ: f32,
}
#[test]
fn bindgen_test_layout_InputMotionData_t() {
    const UNINIT: ::std::mem::MaybeUninit<InputMotionData_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<InputMotionData_t>(),
        40usize,
        concat!("Size of: ", stringify!(InputMotionData_t))
    );
    assert_eq!(
        ::std::mem::align_of::<InputMotionData_t>(),
        1usize,
        concat!("Alignment of ", stringify!(InputMotionData_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotQuatX) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InputMotionData_t),
            "::",
            stringify!(rotQuatX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotQuatY) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(InputMotionData_t),
            "::",
            stringify!(rotQuatY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotQuatZ) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(InputMotionData_t),
            "::",
            stringify!(rotQuatZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotQuatW) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(InputMotionData_t),
            "::",
            stringify!(rotQuatW)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).posAccelX) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(InputMotionData_t),
            "::",
            stringify!(posAccelX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).posAccelY) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(InputMotionData_t),
            "::",
            stringify!(posAccelY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).posAccelZ) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(InputMotionData_t),
            "::",
            stringify!(posAccelZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotVelX) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(InputMotionData_t),
            "::",
            stringify!(rotVelX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotVelY) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(InputMotionData_t),
            "::",
            stringify!(rotVelY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotVelZ) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(InputMotionData_t),
            "::",
            stringify!(rotVelZ)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct SteamInputActionEvent_t {
    pub controllerHandle: InputHandle_t,
    pub eEventType: ESteamInputActionEventType,
    pub __bindgen_anon_1: SteamInputActionEvent_t__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SteamInputActionEvent_t_AnalogAction_t {
    pub actionHandle: InputAnalogActionHandle_t,
    pub analogActionData: InputAnalogActionData_t,
}
#[test]
fn bindgen_test_layout_SteamInputActionEvent_t_AnalogAction_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInputActionEvent_t_AnalogAction_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInputActionEvent_t_AnalogAction_t>(),
        21usize,
        concat!(
            "Size of: ",
            stringify!(SteamInputActionEvent_t_AnalogAction_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInputActionEvent_t_AnalogAction_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SteamInputActionEvent_t_AnalogAction_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).actionHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputActionEvent_t_AnalogAction_t),
            "::",
            stringify!(actionHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).analogActionData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputActionEvent_t_AnalogAction_t),
            "::",
            stringify!(analogActionData)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SteamInputActionEvent_t_DigitalAction_t {
    pub actionHandle: InputDigitalActionHandle_t,
    pub digitalActionData: InputDigitalActionData_t,
}
#[test]
fn bindgen_test_layout_SteamInputActionEvent_t_DigitalAction_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInputActionEvent_t_DigitalAction_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInputActionEvent_t_DigitalAction_t>(),
        10usize,
        concat!(
            "Size of: ",
            stringify!(SteamInputActionEvent_t_DigitalAction_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInputActionEvent_t_DigitalAction_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SteamInputActionEvent_t_DigitalAction_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).actionHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputActionEvent_t_DigitalAction_t),
            "::",
            stringify!(actionHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).digitalActionData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputActionEvent_t_DigitalAction_t),
            "::",
            stringify!(digitalActionData)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SteamInputActionEvent_t__bindgen_ty_1 {
    pub analogAction: SteamInputActionEvent_t_AnalogAction_t,
    pub digitalAction: SteamInputActionEvent_t_DigitalAction_t,
}
#[test]
fn bindgen_test_layout_SteamInputActionEvent_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInputActionEvent_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInputActionEvent_t__bindgen_ty_1>(),
        21usize,
        concat!(
            "Size of: ",
            stringify!(SteamInputActionEvent_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInputActionEvent_t__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SteamInputActionEvent_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).analogAction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputActionEvent_t__bindgen_ty_1),
            "::",
            stringify!(analogAction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).digitalAction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputActionEvent_t__bindgen_ty_1),
            "::",
            stringify!(digitalAction)
        )
    );
}
#[test]
fn bindgen_test_layout_SteamInputActionEvent_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInputActionEvent_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInputActionEvent_t>(),
        33usize,
        concat!("Size of: ", stringify!(SteamInputActionEvent_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInputActionEvent_t>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamInputActionEvent_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).controllerHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputActionEvent_t),
            "::",
            stringify!(controllerHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eEventType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputActionEvent_t),
            "::",
            stringify!(eEventType)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScePadTriggerEffectParam {
    _unused: [u8; 0],
}
pub type SteamInputActionEventCallbackPointer =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut SteamInputActionEvent_t)>;
#[repr(C)]
pub struct ISteamInput__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamInput {
    pub vtable_: *const ISteamInput__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamInput() {
    assert_eq!(
        ::std::mem::size_of::<ISteamInput>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamInput))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamInput>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamInput))
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct SteamInputDeviceConnected_t {
    pub m_ulConnectedDeviceHandle: InputHandle_t,
}
pub const SteamInputDeviceConnected_t_k_iCallback: SteamInputDeviceConnected_t__bindgen_ty_1 =
    SteamInputDeviceConnected_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamInputDeviceConnected_t__bindgen_ty_1 {
    k_iCallback = 2801,
}
#[test]
fn bindgen_test_layout_SteamInputDeviceConnected_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInputDeviceConnected_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInputDeviceConnected_t>(),
        8usize,
        concat!("Size of: ", stringify!(SteamInputDeviceConnected_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInputDeviceConnected_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamInputDeviceConnected_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulConnectedDeviceHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputDeviceConnected_t),
            "::",
            stringify!(m_ulConnectedDeviceHandle)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct SteamInputDeviceDisconnected_t {
    pub m_ulDisconnectedDeviceHandle: InputHandle_t,
}
pub const SteamInputDeviceDisconnected_t_k_iCallback: SteamInputDeviceDisconnected_t__bindgen_ty_1 =
    SteamInputDeviceDisconnected_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamInputDeviceDisconnected_t__bindgen_ty_1 {
    k_iCallback = 2802,
}
#[test]
fn bindgen_test_layout_SteamInputDeviceDisconnected_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInputDeviceDisconnected_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInputDeviceDisconnected_t>(),
        8usize,
        concat!("Size of: ", stringify!(SteamInputDeviceDisconnected_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInputDeviceDisconnected_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamInputDeviceDisconnected_t))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_ulDisconnectedDeviceHandle) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputDeviceDisconnected_t),
            "::",
            stringify!(m_ulDisconnectedDeviceHandle)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct SteamInputConfigurationLoaded_t {
    pub m_unAppID: AppId_t,
    pub m_ulDeviceHandle: InputHandle_t,
    pub m_ulMappingCreator: CSteamID,
    pub m_unMajorRevision: uint32,
    pub m_unMinorRevision: uint32,
    pub m_bUsesSteamInputAPI: bool,
    pub m_bUsesGamepadAPI: bool,
}
pub const SteamInputConfigurationLoaded_t_k_iCallback:
    SteamInputConfigurationLoaded_t__bindgen_ty_1 =
    SteamInputConfigurationLoaded_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamInputConfigurationLoaded_t__bindgen_ty_1 {
    k_iCallback = 2803,
}
#[test]
fn bindgen_test_layout_SteamInputConfigurationLoaded_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInputConfigurationLoaded_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInputConfigurationLoaded_t>(),
        32usize,
        concat!("Size of: ", stringify!(SteamInputConfigurationLoaded_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInputConfigurationLoaded_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamInputConfigurationLoaded_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unAppID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputConfigurationLoaded_t),
            "::",
            stringify!(m_unAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulDeviceHandle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputConfigurationLoaded_t),
            "::",
            stringify!(m_ulDeviceHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulMappingCreator) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputConfigurationLoaded_t),
            "::",
            stringify!(m_ulMappingCreator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unMajorRevision) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputConfigurationLoaded_t),
            "::",
            stringify!(m_unMajorRevision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unMinorRevision) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputConfigurationLoaded_t),
            "::",
            stringify!(m_unMinorRevision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bUsesSteamInputAPI) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputConfigurationLoaded_t),
            "::",
            stringify!(m_bUsesSteamInputAPI)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bUsesGamepadAPI) as usize - ptr as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputConfigurationLoaded_t),
            "::",
            stringify!(m_bUsesGamepadAPI)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct SteamInputGamepadSlotChange_t {
    pub m_unAppID: AppId_t,
    pub m_ulDeviceHandle: InputHandle_t,
    pub m_eDeviceType: ESteamInputType,
    pub m_nOldGamepadSlot: ::std::os::raw::c_int,
    pub m_nNewGamepadSlot: ::std::os::raw::c_int,
}
pub const SteamInputGamepadSlotChange_t_k_iCallback: SteamInputGamepadSlotChange_t__bindgen_ty_1 =
    SteamInputGamepadSlotChange_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamInputGamepadSlotChange_t__bindgen_ty_1 {
    k_iCallback = 2804,
}
#[test]
fn bindgen_test_layout_SteamInputGamepadSlotChange_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInputGamepadSlotChange_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInputGamepadSlotChange_t>(),
        24usize,
        concat!("Size of: ", stringify!(SteamInputGamepadSlotChange_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInputGamepadSlotChange_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamInputGamepadSlotChange_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unAppID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputGamepadSlotChange_t),
            "::",
            stringify!(m_unAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulDeviceHandle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputGamepadSlotChange_t),
            "::",
            stringify!(m_ulDeviceHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eDeviceType) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputGamepadSlotChange_t),
            "::",
            stringify!(m_eDeviceType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nOldGamepadSlot) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputGamepadSlotChange_t),
            "::",
            stringify!(m_nOldGamepadSlot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nNewGamepadSlot) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputGamepadSlotChange_t),
            "::",
            stringify!(m_nNewGamepadSlot)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EControllerActionOrigin {
    k_EControllerActionOrigin_None = 0,
    k_EControllerActionOrigin_A = 1,
    k_EControllerActionOrigin_B = 2,
    k_EControllerActionOrigin_X = 3,
    k_EControllerActionOrigin_Y = 4,
    k_EControllerActionOrigin_LeftBumper = 5,
    k_EControllerActionOrigin_RightBumper = 6,
    k_EControllerActionOrigin_LeftGrip = 7,
    k_EControllerActionOrigin_RightGrip = 8,
    k_EControllerActionOrigin_Start = 9,
    k_EControllerActionOrigin_Back = 10,
    k_EControllerActionOrigin_LeftPad_Touch = 11,
    k_EControllerActionOrigin_LeftPad_Swipe = 12,
    k_EControllerActionOrigin_LeftPad_Click = 13,
    k_EControllerActionOrigin_LeftPad_DPadNorth = 14,
    k_EControllerActionOrigin_LeftPad_DPadSouth = 15,
    k_EControllerActionOrigin_LeftPad_DPadWest = 16,
    k_EControllerActionOrigin_LeftPad_DPadEast = 17,
    k_EControllerActionOrigin_RightPad_Touch = 18,
    k_EControllerActionOrigin_RightPad_Swipe = 19,
    k_EControllerActionOrigin_RightPad_Click = 20,
    k_EControllerActionOrigin_RightPad_DPadNorth = 21,
    k_EControllerActionOrigin_RightPad_DPadSouth = 22,
    k_EControllerActionOrigin_RightPad_DPadWest = 23,
    k_EControllerActionOrigin_RightPad_DPadEast = 24,
    k_EControllerActionOrigin_LeftTrigger_Pull = 25,
    k_EControllerActionOrigin_LeftTrigger_Click = 26,
    k_EControllerActionOrigin_RightTrigger_Pull = 27,
    k_EControllerActionOrigin_RightTrigger_Click = 28,
    k_EControllerActionOrigin_LeftStick_Move = 29,
    k_EControllerActionOrigin_LeftStick_Click = 30,
    k_EControllerActionOrigin_LeftStick_DPadNorth = 31,
    k_EControllerActionOrigin_LeftStick_DPadSouth = 32,
    k_EControllerActionOrigin_LeftStick_DPadWest = 33,
    k_EControllerActionOrigin_LeftStick_DPadEast = 34,
    k_EControllerActionOrigin_Gyro_Move = 35,
    k_EControllerActionOrigin_Gyro_Pitch = 36,
    k_EControllerActionOrigin_Gyro_Yaw = 37,
    k_EControllerActionOrigin_Gyro_Roll = 38,
    k_EControllerActionOrigin_PS4_X = 39,
    k_EControllerActionOrigin_PS4_Circle = 40,
    k_EControllerActionOrigin_PS4_Triangle = 41,
    k_EControllerActionOrigin_PS4_Square = 42,
    k_EControllerActionOrigin_PS4_LeftBumper = 43,
    k_EControllerActionOrigin_PS4_RightBumper = 44,
    k_EControllerActionOrigin_PS4_Options = 45,
    k_EControllerActionOrigin_PS4_Share = 46,
    k_EControllerActionOrigin_PS4_LeftPad_Touch = 47,
    k_EControllerActionOrigin_PS4_LeftPad_Swipe = 48,
    k_EControllerActionOrigin_PS4_LeftPad_Click = 49,
    k_EControllerActionOrigin_PS4_LeftPad_DPadNorth = 50,
    k_EControllerActionOrigin_PS4_LeftPad_DPadSouth = 51,
    k_EControllerActionOrigin_PS4_LeftPad_DPadWest = 52,
    k_EControllerActionOrigin_PS4_LeftPad_DPadEast = 53,
    k_EControllerActionOrigin_PS4_RightPad_Touch = 54,
    k_EControllerActionOrigin_PS4_RightPad_Swipe = 55,
    k_EControllerActionOrigin_PS4_RightPad_Click = 56,
    k_EControllerActionOrigin_PS4_RightPad_DPadNorth = 57,
    k_EControllerActionOrigin_PS4_RightPad_DPadSouth = 58,
    k_EControllerActionOrigin_PS4_RightPad_DPadWest = 59,
    k_EControllerActionOrigin_PS4_RightPad_DPadEast = 60,
    k_EControllerActionOrigin_PS4_CenterPad_Touch = 61,
    k_EControllerActionOrigin_PS4_CenterPad_Swipe = 62,
    k_EControllerActionOrigin_PS4_CenterPad_Click = 63,
    k_EControllerActionOrigin_PS4_CenterPad_DPadNorth = 64,
    k_EControllerActionOrigin_PS4_CenterPad_DPadSouth = 65,
    k_EControllerActionOrigin_PS4_CenterPad_DPadWest = 66,
    k_EControllerActionOrigin_PS4_CenterPad_DPadEast = 67,
    k_EControllerActionOrigin_PS4_LeftTrigger_Pull = 68,
    k_EControllerActionOrigin_PS4_LeftTrigger_Click = 69,
    k_EControllerActionOrigin_PS4_RightTrigger_Pull = 70,
    k_EControllerActionOrigin_PS4_RightTrigger_Click = 71,
    k_EControllerActionOrigin_PS4_LeftStick_Move = 72,
    k_EControllerActionOrigin_PS4_LeftStick_Click = 73,
    k_EControllerActionOrigin_PS4_LeftStick_DPadNorth = 74,
    k_EControllerActionOrigin_PS4_LeftStick_DPadSouth = 75,
    k_EControllerActionOrigin_PS4_LeftStick_DPadWest = 76,
    k_EControllerActionOrigin_PS4_LeftStick_DPadEast = 77,
    k_EControllerActionOrigin_PS4_RightStick_Move = 78,
    k_EControllerActionOrigin_PS4_RightStick_Click = 79,
    k_EControllerActionOrigin_PS4_RightStick_DPadNorth = 80,
    k_EControllerActionOrigin_PS4_RightStick_DPadSouth = 81,
    k_EControllerActionOrigin_PS4_RightStick_DPadWest = 82,
    k_EControllerActionOrigin_PS4_RightStick_DPadEast = 83,
    k_EControllerActionOrigin_PS4_DPad_North = 84,
    k_EControllerActionOrigin_PS4_DPad_South = 85,
    k_EControllerActionOrigin_PS4_DPad_West = 86,
    k_EControllerActionOrigin_PS4_DPad_East = 87,
    k_EControllerActionOrigin_PS4_Gyro_Move = 88,
    k_EControllerActionOrigin_PS4_Gyro_Pitch = 89,
    k_EControllerActionOrigin_PS4_Gyro_Yaw = 90,
    k_EControllerActionOrigin_PS4_Gyro_Roll = 91,
    k_EControllerActionOrigin_XBoxOne_A = 92,
    k_EControllerActionOrigin_XBoxOne_B = 93,
    k_EControllerActionOrigin_XBoxOne_X = 94,
    k_EControllerActionOrigin_XBoxOne_Y = 95,
    k_EControllerActionOrigin_XBoxOne_LeftBumper = 96,
    k_EControllerActionOrigin_XBoxOne_RightBumper = 97,
    k_EControllerActionOrigin_XBoxOne_Menu = 98,
    k_EControllerActionOrigin_XBoxOne_View = 99,
    k_EControllerActionOrigin_XBoxOne_LeftTrigger_Pull = 100,
    k_EControllerActionOrigin_XBoxOne_LeftTrigger_Click = 101,
    k_EControllerActionOrigin_XBoxOne_RightTrigger_Pull = 102,
    k_EControllerActionOrigin_XBoxOne_RightTrigger_Click = 103,
    k_EControllerActionOrigin_XBoxOne_LeftStick_Move = 104,
    k_EControllerActionOrigin_XBoxOne_LeftStick_Click = 105,
    k_EControllerActionOrigin_XBoxOne_LeftStick_DPadNorth = 106,
    k_EControllerActionOrigin_XBoxOne_LeftStick_DPadSouth = 107,
    k_EControllerActionOrigin_XBoxOne_LeftStick_DPadWest = 108,
    k_EControllerActionOrigin_XBoxOne_LeftStick_DPadEast = 109,
    k_EControllerActionOrigin_XBoxOne_RightStick_Move = 110,
    k_EControllerActionOrigin_XBoxOne_RightStick_Click = 111,
    k_EControllerActionOrigin_XBoxOne_RightStick_DPadNorth = 112,
    k_EControllerActionOrigin_XBoxOne_RightStick_DPadSouth = 113,
    k_EControllerActionOrigin_XBoxOne_RightStick_DPadWest = 114,
    k_EControllerActionOrigin_XBoxOne_RightStick_DPadEast = 115,
    k_EControllerActionOrigin_XBoxOne_DPad_North = 116,
    k_EControllerActionOrigin_XBoxOne_DPad_South = 117,
    k_EControllerActionOrigin_XBoxOne_DPad_West = 118,
    k_EControllerActionOrigin_XBoxOne_DPad_East = 119,
    k_EControllerActionOrigin_XBox360_A = 120,
    k_EControllerActionOrigin_XBox360_B = 121,
    k_EControllerActionOrigin_XBox360_X = 122,
    k_EControllerActionOrigin_XBox360_Y = 123,
    k_EControllerActionOrigin_XBox360_LeftBumper = 124,
    k_EControllerActionOrigin_XBox360_RightBumper = 125,
    k_EControllerActionOrigin_XBox360_Start = 126,
    k_EControllerActionOrigin_XBox360_Back = 127,
    k_EControllerActionOrigin_XBox360_LeftTrigger_Pull = 128,
    k_EControllerActionOrigin_XBox360_LeftTrigger_Click = 129,
    k_EControllerActionOrigin_XBox360_RightTrigger_Pull = 130,
    k_EControllerActionOrigin_XBox360_RightTrigger_Click = 131,
    k_EControllerActionOrigin_XBox360_LeftStick_Move = 132,
    k_EControllerActionOrigin_XBox360_LeftStick_Click = 133,
    k_EControllerActionOrigin_XBox360_LeftStick_DPadNorth = 134,
    k_EControllerActionOrigin_XBox360_LeftStick_DPadSouth = 135,
    k_EControllerActionOrigin_XBox360_LeftStick_DPadWest = 136,
    k_EControllerActionOrigin_XBox360_LeftStick_DPadEast = 137,
    k_EControllerActionOrigin_XBox360_RightStick_Move = 138,
    k_EControllerActionOrigin_XBox360_RightStick_Click = 139,
    k_EControllerActionOrigin_XBox360_RightStick_DPadNorth = 140,
    k_EControllerActionOrigin_XBox360_RightStick_DPadSouth = 141,
    k_EControllerActionOrigin_XBox360_RightStick_DPadWest = 142,
    k_EControllerActionOrigin_XBox360_RightStick_DPadEast = 143,
    k_EControllerActionOrigin_XBox360_DPad_North = 144,
    k_EControllerActionOrigin_XBox360_DPad_South = 145,
    k_EControllerActionOrigin_XBox360_DPad_West = 146,
    k_EControllerActionOrigin_XBox360_DPad_East = 147,
    k_EControllerActionOrigin_SteamV2_A = 148,
    k_EControllerActionOrigin_SteamV2_B = 149,
    k_EControllerActionOrigin_SteamV2_X = 150,
    k_EControllerActionOrigin_SteamV2_Y = 151,
    k_EControllerActionOrigin_SteamV2_LeftBumper = 152,
    k_EControllerActionOrigin_SteamV2_RightBumper = 153,
    k_EControllerActionOrigin_SteamV2_LeftGrip_Lower = 154,
    k_EControllerActionOrigin_SteamV2_LeftGrip_Upper = 155,
    k_EControllerActionOrigin_SteamV2_RightGrip_Lower = 156,
    k_EControllerActionOrigin_SteamV2_RightGrip_Upper = 157,
    k_EControllerActionOrigin_SteamV2_LeftBumper_Pressure = 158,
    k_EControllerActionOrigin_SteamV2_RightBumper_Pressure = 159,
    k_EControllerActionOrigin_SteamV2_LeftGrip_Pressure = 160,
    k_EControllerActionOrigin_SteamV2_RightGrip_Pressure = 161,
    k_EControllerActionOrigin_SteamV2_LeftGrip_Upper_Pressure = 162,
    k_EControllerActionOrigin_SteamV2_RightGrip_Upper_Pressure = 163,
    k_EControllerActionOrigin_SteamV2_Start = 164,
    k_EControllerActionOrigin_SteamV2_Back = 165,
    k_EControllerActionOrigin_SteamV2_LeftPad_Touch = 166,
    k_EControllerActionOrigin_SteamV2_LeftPad_Swipe = 167,
    k_EControllerActionOrigin_SteamV2_LeftPad_Click = 168,
    k_EControllerActionOrigin_SteamV2_LeftPad_Pressure = 169,
    k_EControllerActionOrigin_SteamV2_LeftPad_DPadNorth = 170,
    k_EControllerActionOrigin_SteamV2_LeftPad_DPadSouth = 171,
    k_EControllerActionOrigin_SteamV2_LeftPad_DPadWest = 172,
    k_EControllerActionOrigin_SteamV2_LeftPad_DPadEast = 173,
    k_EControllerActionOrigin_SteamV2_RightPad_Touch = 174,
    k_EControllerActionOrigin_SteamV2_RightPad_Swipe = 175,
    k_EControllerActionOrigin_SteamV2_RightPad_Click = 176,
    k_EControllerActionOrigin_SteamV2_RightPad_Pressure = 177,
    k_EControllerActionOrigin_SteamV2_RightPad_DPadNorth = 178,
    k_EControllerActionOrigin_SteamV2_RightPad_DPadSouth = 179,
    k_EControllerActionOrigin_SteamV2_RightPad_DPadWest = 180,
    k_EControllerActionOrigin_SteamV2_RightPad_DPadEast = 181,
    k_EControllerActionOrigin_SteamV2_LeftTrigger_Pull = 182,
    k_EControllerActionOrigin_SteamV2_LeftTrigger_Click = 183,
    k_EControllerActionOrigin_SteamV2_RightTrigger_Pull = 184,
    k_EControllerActionOrigin_SteamV2_RightTrigger_Click = 185,
    k_EControllerActionOrigin_SteamV2_LeftStick_Move = 186,
    k_EControllerActionOrigin_SteamV2_LeftStick_Click = 187,
    k_EControllerActionOrigin_SteamV2_LeftStick_DPadNorth = 188,
    k_EControllerActionOrigin_SteamV2_LeftStick_DPadSouth = 189,
    k_EControllerActionOrigin_SteamV2_LeftStick_DPadWest = 190,
    k_EControllerActionOrigin_SteamV2_LeftStick_DPadEast = 191,
    k_EControllerActionOrigin_SteamV2_Gyro_Move = 192,
    k_EControllerActionOrigin_SteamV2_Gyro_Pitch = 193,
    k_EControllerActionOrigin_SteamV2_Gyro_Yaw = 194,
    k_EControllerActionOrigin_SteamV2_Gyro_Roll = 195,
    k_EControllerActionOrigin_Switch_A = 196,
    k_EControllerActionOrigin_Switch_B = 197,
    k_EControllerActionOrigin_Switch_X = 198,
    k_EControllerActionOrigin_Switch_Y = 199,
    k_EControllerActionOrigin_Switch_LeftBumper = 200,
    k_EControllerActionOrigin_Switch_RightBumper = 201,
    k_EControllerActionOrigin_Switch_Plus = 202,
    k_EControllerActionOrigin_Switch_Minus = 203,
    k_EControllerActionOrigin_Switch_Capture = 204,
    k_EControllerActionOrigin_Switch_LeftTrigger_Pull = 205,
    k_EControllerActionOrigin_Switch_LeftTrigger_Click = 206,
    k_EControllerActionOrigin_Switch_RightTrigger_Pull = 207,
    k_EControllerActionOrigin_Switch_RightTrigger_Click = 208,
    k_EControllerActionOrigin_Switch_LeftStick_Move = 209,
    k_EControllerActionOrigin_Switch_LeftStick_Click = 210,
    k_EControllerActionOrigin_Switch_LeftStick_DPadNorth = 211,
    k_EControllerActionOrigin_Switch_LeftStick_DPadSouth = 212,
    k_EControllerActionOrigin_Switch_LeftStick_DPadWest = 213,
    k_EControllerActionOrigin_Switch_LeftStick_DPadEast = 214,
    k_EControllerActionOrigin_Switch_RightStick_Move = 215,
    k_EControllerActionOrigin_Switch_RightStick_Click = 216,
    k_EControllerActionOrigin_Switch_RightStick_DPadNorth = 217,
    k_EControllerActionOrigin_Switch_RightStick_DPadSouth = 218,
    k_EControllerActionOrigin_Switch_RightStick_DPadWest = 219,
    k_EControllerActionOrigin_Switch_RightStick_DPadEast = 220,
    k_EControllerActionOrigin_Switch_DPad_North = 221,
    k_EControllerActionOrigin_Switch_DPad_South = 222,
    k_EControllerActionOrigin_Switch_DPad_West = 223,
    k_EControllerActionOrigin_Switch_DPad_East = 224,
    k_EControllerActionOrigin_Switch_ProGyro_Move = 225,
    k_EControllerActionOrigin_Switch_ProGyro_Pitch = 226,
    k_EControllerActionOrigin_Switch_ProGyro_Yaw = 227,
    k_EControllerActionOrigin_Switch_ProGyro_Roll = 228,
    k_EControllerActionOrigin_Switch_RightGyro_Move = 229,
    k_EControllerActionOrigin_Switch_RightGyro_Pitch = 230,
    k_EControllerActionOrigin_Switch_RightGyro_Yaw = 231,
    k_EControllerActionOrigin_Switch_RightGyro_Roll = 232,
    k_EControllerActionOrigin_Switch_LeftGyro_Move = 233,
    k_EControllerActionOrigin_Switch_LeftGyro_Pitch = 234,
    k_EControllerActionOrigin_Switch_LeftGyro_Yaw = 235,
    k_EControllerActionOrigin_Switch_LeftGyro_Roll = 236,
    k_EControllerActionOrigin_Switch_LeftGrip_Lower = 237,
    k_EControllerActionOrigin_Switch_LeftGrip_Upper = 238,
    k_EControllerActionOrigin_Switch_RightGrip_Lower = 239,
    k_EControllerActionOrigin_Switch_RightGrip_Upper = 240,
    k_EControllerActionOrigin_PS4_DPad_Move = 241,
    k_EControllerActionOrigin_XBoxOne_DPad_Move = 242,
    k_EControllerActionOrigin_XBox360_DPad_Move = 243,
    k_EControllerActionOrigin_Switch_DPad_Move = 244,
    k_EControllerActionOrigin_PS5_X = 245,
    k_EControllerActionOrigin_PS5_Circle = 246,
    k_EControllerActionOrigin_PS5_Triangle = 247,
    k_EControllerActionOrigin_PS5_Square = 248,
    k_EControllerActionOrigin_PS5_LeftBumper = 249,
    k_EControllerActionOrigin_PS5_RightBumper = 250,
    k_EControllerActionOrigin_PS5_Option = 251,
    k_EControllerActionOrigin_PS5_Create = 252,
    k_EControllerActionOrigin_PS5_Mute = 253,
    k_EControllerActionOrigin_PS5_LeftPad_Touch = 254,
    k_EControllerActionOrigin_PS5_LeftPad_Swipe = 255,
    k_EControllerActionOrigin_PS5_LeftPad_Click = 256,
    k_EControllerActionOrigin_PS5_LeftPad_DPadNorth = 257,
    k_EControllerActionOrigin_PS5_LeftPad_DPadSouth = 258,
    k_EControllerActionOrigin_PS5_LeftPad_DPadWest = 259,
    k_EControllerActionOrigin_PS5_LeftPad_DPadEast = 260,
    k_EControllerActionOrigin_PS5_RightPad_Touch = 261,
    k_EControllerActionOrigin_PS5_RightPad_Swipe = 262,
    k_EControllerActionOrigin_PS5_RightPad_Click = 263,
    k_EControllerActionOrigin_PS5_RightPad_DPadNorth = 264,
    k_EControllerActionOrigin_PS5_RightPad_DPadSouth = 265,
    k_EControllerActionOrigin_PS5_RightPad_DPadWest = 266,
    k_EControllerActionOrigin_PS5_RightPad_DPadEast = 267,
    k_EControllerActionOrigin_PS5_CenterPad_Touch = 268,
    k_EControllerActionOrigin_PS5_CenterPad_Swipe = 269,
    k_EControllerActionOrigin_PS5_CenterPad_Click = 270,
    k_EControllerActionOrigin_PS5_CenterPad_DPadNorth = 271,
    k_EControllerActionOrigin_PS5_CenterPad_DPadSouth = 272,
    k_EControllerActionOrigin_PS5_CenterPad_DPadWest = 273,
    k_EControllerActionOrigin_PS5_CenterPad_DPadEast = 274,
    k_EControllerActionOrigin_PS5_LeftTrigger_Pull = 275,
    k_EControllerActionOrigin_PS5_LeftTrigger_Click = 276,
    k_EControllerActionOrigin_PS5_RightTrigger_Pull = 277,
    k_EControllerActionOrigin_PS5_RightTrigger_Click = 278,
    k_EControllerActionOrigin_PS5_LeftStick_Move = 279,
    k_EControllerActionOrigin_PS5_LeftStick_Click = 280,
    k_EControllerActionOrigin_PS5_LeftStick_DPadNorth = 281,
    k_EControllerActionOrigin_PS5_LeftStick_DPadSouth = 282,
    k_EControllerActionOrigin_PS5_LeftStick_DPadWest = 283,
    k_EControllerActionOrigin_PS5_LeftStick_DPadEast = 284,
    k_EControllerActionOrigin_PS5_RightStick_Move = 285,
    k_EControllerActionOrigin_PS5_RightStick_Click = 286,
    k_EControllerActionOrigin_PS5_RightStick_DPadNorth = 287,
    k_EControllerActionOrigin_PS5_RightStick_DPadSouth = 288,
    k_EControllerActionOrigin_PS5_RightStick_DPadWest = 289,
    k_EControllerActionOrigin_PS5_RightStick_DPadEast = 290,
    k_EControllerActionOrigin_PS5_DPad_Move = 291,
    k_EControllerActionOrigin_PS5_DPad_North = 292,
    k_EControllerActionOrigin_PS5_DPad_South = 293,
    k_EControllerActionOrigin_PS5_DPad_West = 294,
    k_EControllerActionOrigin_PS5_DPad_East = 295,
    k_EControllerActionOrigin_PS5_Gyro_Move = 296,
    k_EControllerActionOrigin_PS5_Gyro_Pitch = 297,
    k_EControllerActionOrigin_PS5_Gyro_Yaw = 298,
    k_EControllerActionOrigin_PS5_Gyro_Roll = 299,
    k_EControllerActionOrigin_XBoxOne_LeftGrip_Lower = 300,
    k_EControllerActionOrigin_XBoxOne_LeftGrip_Upper = 301,
    k_EControllerActionOrigin_XBoxOne_RightGrip_Lower = 302,
    k_EControllerActionOrigin_XBoxOne_RightGrip_Upper = 303,
    k_EControllerActionOrigin_XBoxOne_Share = 304,
    k_EControllerActionOrigin_SteamDeck_A = 305,
    k_EControllerActionOrigin_SteamDeck_B = 306,
    k_EControllerActionOrigin_SteamDeck_X = 307,
    k_EControllerActionOrigin_SteamDeck_Y = 308,
    k_EControllerActionOrigin_SteamDeck_L1 = 309,
    k_EControllerActionOrigin_SteamDeck_R1 = 310,
    k_EControllerActionOrigin_SteamDeck_Menu = 311,
    k_EControllerActionOrigin_SteamDeck_View = 312,
    k_EControllerActionOrigin_SteamDeck_LeftPad_Touch = 313,
    k_EControllerActionOrigin_SteamDeck_LeftPad_Swipe = 314,
    k_EControllerActionOrigin_SteamDeck_LeftPad_Click = 315,
    k_EControllerActionOrigin_SteamDeck_LeftPad_DPadNorth = 316,
    k_EControllerActionOrigin_SteamDeck_LeftPad_DPadSouth = 317,
    k_EControllerActionOrigin_SteamDeck_LeftPad_DPadWest = 318,
    k_EControllerActionOrigin_SteamDeck_LeftPad_DPadEast = 319,
    k_EControllerActionOrigin_SteamDeck_RightPad_Touch = 320,
    k_EControllerActionOrigin_SteamDeck_RightPad_Swipe = 321,
    k_EControllerActionOrigin_SteamDeck_RightPad_Click = 322,
    k_EControllerActionOrigin_SteamDeck_RightPad_DPadNorth = 323,
    k_EControllerActionOrigin_SteamDeck_RightPad_DPadSouth = 324,
    k_EControllerActionOrigin_SteamDeck_RightPad_DPadWest = 325,
    k_EControllerActionOrigin_SteamDeck_RightPad_DPadEast = 326,
    k_EControllerActionOrigin_SteamDeck_L2_SoftPull = 327,
    k_EControllerActionOrigin_SteamDeck_L2 = 328,
    k_EControllerActionOrigin_SteamDeck_R2_SoftPull = 329,
    k_EControllerActionOrigin_SteamDeck_R2 = 330,
    k_EControllerActionOrigin_SteamDeck_LeftStick_Move = 331,
    k_EControllerActionOrigin_SteamDeck_L3 = 332,
    k_EControllerActionOrigin_SteamDeck_LeftStick_DPadNorth = 333,
    k_EControllerActionOrigin_SteamDeck_LeftStick_DPadSouth = 334,
    k_EControllerActionOrigin_SteamDeck_LeftStick_DPadWest = 335,
    k_EControllerActionOrigin_SteamDeck_LeftStick_DPadEast = 336,
    k_EControllerActionOrigin_SteamDeck_LeftStick_Touch = 337,
    k_EControllerActionOrigin_SteamDeck_RightStick_Move = 338,
    k_EControllerActionOrigin_SteamDeck_R3 = 339,
    k_EControllerActionOrigin_SteamDeck_RightStick_DPadNorth = 340,
    k_EControllerActionOrigin_SteamDeck_RightStick_DPadSouth = 341,
    k_EControllerActionOrigin_SteamDeck_RightStick_DPadWest = 342,
    k_EControllerActionOrigin_SteamDeck_RightStick_DPadEast = 343,
    k_EControllerActionOrigin_SteamDeck_RightStick_Touch = 344,
    k_EControllerActionOrigin_SteamDeck_L4 = 345,
    k_EControllerActionOrigin_SteamDeck_R4 = 346,
    k_EControllerActionOrigin_SteamDeck_L5 = 347,
    k_EControllerActionOrigin_SteamDeck_R5 = 348,
    k_EControllerActionOrigin_SteamDeck_DPad_Move = 349,
    k_EControllerActionOrigin_SteamDeck_DPad_North = 350,
    k_EControllerActionOrigin_SteamDeck_DPad_South = 351,
    k_EControllerActionOrigin_SteamDeck_DPad_West = 352,
    k_EControllerActionOrigin_SteamDeck_DPad_East = 353,
    k_EControllerActionOrigin_SteamDeck_Gyro_Move = 354,
    k_EControllerActionOrigin_SteamDeck_Gyro_Pitch = 355,
    k_EControllerActionOrigin_SteamDeck_Gyro_Yaw = 356,
    k_EControllerActionOrigin_SteamDeck_Gyro_Roll = 357,
    k_EControllerActionOrigin_SteamDeck_Reserved1 = 358,
    k_EControllerActionOrigin_SteamDeck_Reserved2 = 359,
    k_EControllerActionOrigin_SteamDeck_Reserved3 = 360,
    k_EControllerActionOrigin_SteamDeck_Reserved4 = 361,
    k_EControllerActionOrigin_SteamDeck_Reserved5 = 362,
    k_EControllerActionOrigin_SteamDeck_Reserved6 = 363,
    k_EControllerActionOrigin_SteamDeck_Reserved7 = 364,
    k_EControllerActionOrigin_SteamDeck_Reserved8 = 365,
    k_EControllerActionOrigin_SteamDeck_Reserved9 = 366,
    k_EControllerActionOrigin_SteamDeck_Reserved10 = 367,
    k_EControllerActionOrigin_SteamDeck_Reserved11 = 368,
    k_EControllerActionOrigin_SteamDeck_Reserved12 = 369,
    k_EControllerActionOrigin_SteamDeck_Reserved13 = 370,
    k_EControllerActionOrigin_SteamDeck_Reserved14 = 371,
    k_EControllerActionOrigin_SteamDeck_Reserved15 = 372,
    k_EControllerActionOrigin_SteamDeck_Reserved16 = 373,
    k_EControllerActionOrigin_SteamDeck_Reserved17 = 374,
    k_EControllerActionOrigin_SteamDeck_Reserved18 = 375,
    k_EControllerActionOrigin_SteamDeck_Reserved19 = 376,
    k_EControllerActionOrigin_SteamDeck_Reserved20 = 377,
    k_EControllerActionOrigin_Switch_JoyConButton_N = 378,
    k_EControllerActionOrigin_Switch_JoyConButton_E = 379,
    k_EControllerActionOrigin_Switch_JoyConButton_S = 380,
    k_EControllerActionOrigin_Switch_JoyConButton_W = 381,
    k_EControllerActionOrigin_PS5_LeftGrip = 382,
    k_EControllerActionOrigin_PS5_RightGrip = 383,
    k_EControllerActionOrigin_PS5_LeftFn = 384,
    k_EControllerActionOrigin_PS5_RightFn = 385,
    k_EControllerActionOrigin_Horipad_M1 = 386,
    k_EControllerActionOrigin_Horipad_M2 = 387,
    k_EControllerActionOrigin_Horipad_L4 = 388,
    k_EControllerActionOrigin_Horipad_R4 = 389,
    k_EControllerActionOrigin_Count = 390,
    k_EControllerActionOrigin_MaximumPossibleValue = 32767,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamControllerLEDFlag {
    k_ESteamControllerLEDFlag_SetColor = 0,
    k_ESteamControllerLEDFlag_RestoreUserDefault = 1,
}
pub type ControllerHandle_t = uint64;
pub type ControllerActionSetHandle_t = uint64;
pub type ControllerDigitalActionHandle_t = uint64;
pub type ControllerAnalogActionHandle_t = uint64;
#[repr(C)]
pub struct ISteamController__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamController {
    pub vtable_: *const ISteamController__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamController() {
    assert_eq!(
        ::std::mem::size_of::<ISteamController>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamController))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamController>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamController))
    );
}
pub type UGCQueryHandle_t = uint64;
pub type UGCUpdateHandle_t = uint64;
pub const k_UGCQueryHandleInvalid: UGCQueryHandle_t = 18446744073709551615;
pub const k_UGCUpdateHandleInvalid: UGCUpdateHandle_t = 18446744073709551615;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EUGCMatchingUGCType {
    k_EUGCMatchingUGCType_Items = 0,
    k_EUGCMatchingUGCType_Items_Mtx = 1,
    k_EUGCMatchingUGCType_Items_ReadyToUse = 2,
    k_EUGCMatchingUGCType_Collections = 3,
    k_EUGCMatchingUGCType_Artwork = 4,
    k_EUGCMatchingUGCType_Videos = 5,
    k_EUGCMatchingUGCType_Screenshots = 6,
    k_EUGCMatchingUGCType_AllGuides = 7,
    k_EUGCMatchingUGCType_WebGuides = 8,
    k_EUGCMatchingUGCType_IntegratedGuides = 9,
    k_EUGCMatchingUGCType_UsableInGame = 10,
    k_EUGCMatchingUGCType_ControllerBindings = 11,
    k_EUGCMatchingUGCType_GameManagedItems = 12,
    k_EUGCMatchingUGCType_All = -1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EUserUGCList {
    k_EUserUGCList_Published = 0,
    k_EUserUGCList_VotedOn = 1,
    k_EUserUGCList_VotedUp = 2,
    k_EUserUGCList_VotedDown = 3,
    k_EUserUGCList_WillVoteLater = 4,
    k_EUserUGCList_Favorited = 5,
    k_EUserUGCList_Subscribed = 6,
    k_EUserUGCList_UsedOrPlayed = 7,
    k_EUserUGCList_Followed = 8,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EUserUGCListSortOrder {
    k_EUserUGCListSortOrder_CreationOrderDesc = 0,
    k_EUserUGCListSortOrder_CreationOrderAsc = 1,
    k_EUserUGCListSortOrder_TitleAsc = 2,
    k_EUserUGCListSortOrder_LastUpdatedDesc = 3,
    k_EUserUGCListSortOrder_SubscriptionDateDesc = 4,
    k_EUserUGCListSortOrder_VoteScoreDesc = 5,
    k_EUserUGCListSortOrder_ForModeration = 6,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EUGCQuery {
    k_EUGCQuery_RankedByVote = 0,
    k_EUGCQuery_RankedByPublicationDate = 1,
    k_EUGCQuery_AcceptedForGameRankedByAcceptanceDate = 2,
    k_EUGCQuery_RankedByTrend = 3,
    k_EUGCQuery_FavoritedByFriendsRankedByPublicationDate = 4,
    k_EUGCQuery_CreatedByFriendsRankedByPublicationDate = 5,
    k_EUGCQuery_RankedByNumTimesReported = 6,
    k_EUGCQuery_CreatedByFollowedUsersRankedByPublicationDate = 7,
    k_EUGCQuery_NotYetRated = 8,
    k_EUGCQuery_RankedByTotalVotesAsc = 9,
    k_EUGCQuery_RankedByVotesUp = 10,
    k_EUGCQuery_RankedByTextSearch = 11,
    k_EUGCQuery_RankedByTotalUniqueSubscriptions = 12,
    k_EUGCQuery_RankedByPlaytimeTrend = 13,
    k_EUGCQuery_RankedByTotalPlaytime = 14,
    k_EUGCQuery_RankedByAveragePlaytimeTrend = 15,
    k_EUGCQuery_RankedByLifetimeAveragePlaytime = 16,
    k_EUGCQuery_RankedByPlaytimeSessionsTrend = 17,
    k_EUGCQuery_RankedByLifetimePlaytimeSessions = 18,
    k_EUGCQuery_RankedByLastUpdatedDate = 19,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EItemUpdateStatus {
    k_EItemUpdateStatusInvalid = 0,
    k_EItemUpdateStatusPreparingConfig = 1,
    k_EItemUpdateStatusPreparingContent = 2,
    k_EItemUpdateStatusUploadingContent = 3,
    k_EItemUpdateStatusUploadingPreviewFile = 4,
    k_EItemUpdateStatusCommittingChanges = 5,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EItemState {
    k_EItemStateNone = 0,
    k_EItemStateSubscribed = 1,
    k_EItemStateLegacyItem = 2,
    k_EItemStateInstalled = 4,
    k_EItemStateNeedsUpdate = 8,
    k_EItemStateDownloading = 16,
    k_EItemStateDownloadPending = 32,
    k_EItemStateDisabledLocally = 64,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EItemStatistic {
    k_EItemStatistic_NumSubscriptions = 0,
    k_EItemStatistic_NumFavorites = 1,
    k_EItemStatistic_NumFollowers = 2,
    k_EItemStatistic_NumUniqueSubscriptions = 3,
    k_EItemStatistic_NumUniqueFavorites = 4,
    k_EItemStatistic_NumUniqueFollowers = 5,
    k_EItemStatistic_NumUniqueWebsiteViews = 6,
    k_EItemStatistic_ReportScore = 7,
    k_EItemStatistic_NumSecondsPlayed = 8,
    k_EItemStatistic_NumPlaytimeSessions = 9,
    k_EItemStatistic_NumComments = 10,
    k_EItemStatistic_NumSecondsPlayedDuringTimePeriod = 11,
    k_EItemStatistic_NumPlaytimeSessionsDuringTimePeriod = 12,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EItemPreviewType {
    k_EItemPreviewType_Image = 0,
    k_EItemPreviewType_YouTubeVideo = 1,
    k_EItemPreviewType_Sketchfab = 2,
    k_EItemPreviewType_EnvironmentMap_HorizontalCross = 3,
    k_EItemPreviewType_EnvironmentMap_LatLong = 4,
    k_EItemPreviewType_Clip = 5,
    k_EItemPreviewType_ReservedMax = 255,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EUGCContentDescriptorID {
    k_EUGCContentDescriptor_NudityOrSexualContent = 1,
    k_EUGCContentDescriptor_FrequentViolenceOrGore = 2,
    k_EUGCContentDescriptor_AdultOnlySexualContent = 3,
    k_EUGCContentDescriptor_GratuitousSexualContent = 4,
    k_EUGCContentDescriptor_AnyMatureContent = 5,
}
pub const kNumUGCResultsPerPage: uint32 = 50;
pub const k_cchDeveloperMetadataMax: uint32 = 5000;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct SteamUGCDetails_t {
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_eResult: EResult,
    pub m_eFileType: EWorkshopFileType,
    pub m_nCreatorAppID: AppId_t,
    pub m_nConsumerAppID: AppId_t,
    pub m_rgchTitle: [::std::os::raw::c_char; 129usize],
    pub m_rgchDescription: [::std::os::raw::c_char; 8000usize],
    pub m_ulSteamIDOwner: uint64,
    pub m_rtimeCreated: uint32,
    pub m_rtimeUpdated: uint32,
    pub m_rtimeAddedToUserList: uint32,
    pub m_eVisibility: ERemoteStoragePublishedFileVisibility,
    pub m_bBanned: bool,
    pub m_bAcceptedForUse: bool,
    pub m_bTagsTruncated: bool,
    pub m_rgchTags: [::std::os::raw::c_char; 1025usize],
    pub m_hFile: UGCHandle_t,
    pub m_hPreviewFile: UGCHandle_t,
    pub m_pchFileName: [::std::os::raw::c_char; 260usize],
    pub m_nFileSize: int32,
    pub m_nPreviewFileSize: int32,
    pub m_rgchURL: [::std::os::raw::c_char; 256usize],
    pub m_unVotesUp: uint32,
    pub m_unVotesDown: uint32,
    pub m_flScore: f32,
    pub m_unNumChildren: uint32,
    pub m_ulTotalFilesSize: uint64,
}
#[test]
fn bindgen_test_layout_SteamUGCDetails_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamUGCDetails_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamUGCDetails_t>(),
        9772usize,
        concat!("Size of: ", stringify!(SteamUGCDetails_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamUGCDetails_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamUGCDetails_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eFileType) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_eFileType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nCreatorAppID) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_nCreatorAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nConsumerAppID) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_nConsumerAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchTitle) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_rgchTitle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchDescription) as usize - ptr as usize },
        153usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_rgchDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDOwner) as usize - ptr as usize },
        8156usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_ulSteamIDOwner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rtimeCreated) as usize - ptr as usize },
        8164usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_rtimeCreated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rtimeUpdated) as usize - ptr as usize },
        8168usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_rtimeUpdated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rtimeAddedToUserList) as usize - ptr as usize },
        8172usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_rtimeAddedToUserList)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eVisibility) as usize - ptr as usize },
        8176usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_eVisibility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bBanned) as usize - ptr as usize },
        8180usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_bBanned)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bAcceptedForUse) as usize - ptr as usize },
        8181usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_bAcceptedForUse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bTagsTruncated) as usize - ptr as usize },
        8182usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_bTagsTruncated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchTags) as usize - ptr as usize },
        8183usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_rgchTags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hFile) as usize - ptr as usize },
        9208usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_hFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hPreviewFile) as usize - ptr as usize },
        9216usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_hPreviewFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pchFileName) as usize - ptr as usize },
        9224usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_pchFileName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nFileSize) as usize - ptr as usize },
        9484usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_nFileSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPreviewFileSize) as usize - ptr as usize },
        9488usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_nPreviewFileSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchURL) as usize - ptr as usize },
        9492usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_rgchURL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unVotesUp) as usize - ptr as usize },
        9748usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_unVotesUp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unVotesDown) as usize - ptr as usize },
        9752usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_unVotesDown)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_flScore) as usize - ptr as usize },
        9756usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_flScore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unNumChildren) as usize - ptr as usize },
        9760usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_unNumChildren)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulTotalFilesSize) as usize - ptr as usize },
        9764usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_ulTotalFilesSize)
        )
    );
}
#[repr(C)]
pub struct ISteamUGC__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamUGC {
    pub vtable_: *const ISteamUGC__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamUGC() {
    assert_eq!(
        ::std::mem::size_of::<ISteamUGC>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamUGC))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamUGC>(),
        4usize,
        concat!("Alignment of ", stringify!(ISteamUGC))
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct SteamUGCQueryCompleted_t {
    pub m_handle: UGCQueryHandle_t,
    pub m_eResult: EResult,
    pub m_unNumResultsReturned: uint32,
    pub m_unTotalMatchingResults: uint32,
    pub m_bCachedData: bool,
    pub m_rgchNextCursor: [::std::os::raw::c_char; 256usize],
}
pub const SteamUGCQueryCompleted_t_k_iCallback: SteamUGCQueryCompleted_t__bindgen_ty_1 =
    SteamUGCQueryCompleted_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamUGCQueryCompleted_t__bindgen_ty_1 {
    k_iCallback = 3401,
}
#[test]
fn bindgen_test_layout_SteamUGCQueryCompleted_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamUGCQueryCompleted_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamUGCQueryCompleted_t>(),
        280usize,
        concat!("Size of: ", stringify!(SteamUGCQueryCompleted_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamUGCQueryCompleted_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamUGCQueryCompleted_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCQueryCompleted_t),
            "::",
            stringify!(m_handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCQueryCompleted_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unNumResultsReturned) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCQueryCompleted_t),
            "::",
            stringify!(m_unNumResultsReturned)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unTotalMatchingResults) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCQueryCompleted_t),
            "::",
            stringify!(m_unTotalMatchingResults)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bCachedData) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCQueryCompleted_t),
            "::",
            stringify!(m_bCachedData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchNextCursor) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCQueryCompleted_t),
            "::",
            stringify!(m_rgchNextCursor)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamUGCRequestUGCDetailsResult_t {
    pub m_details: SteamUGCDetails_t,
    pub m_bCachedData: bool,
}
pub const SteamUGCRequestUGCDetailsResult_t_k_iCallback:
    SteamUGCRequestUGCDetailsResult_t__bindgen_ty_1 =
    SteamUGCRequestUGCDetailsResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamUGCRequestUGCDetailsResult_t__bindgen_ty_1 {
    k_iCallback = 3402,
}
#[test]
fn bindgen_test_layout_SteamUGCRequestUGCDetailsResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamUGCRequestUGCDetailsResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamUGCRequestUGCDetailsResult_t>(),
        9776usize,
        concat!("Size of: ", stringify!(SteamUGCRequestUGCDetailsResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamUGCRequestUGCDetailsResult_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SteamUGCRequestUGCDetailsResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_details) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCRequestUGCDetailsResult_t),
            "::",
            stringify!(m_details)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bCachedData) as usize - ptr as usize },
        9772usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCRequestUGCDetailsResult_t),
            "::",
            stringify!(m_bCachedData)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct CreateItemResult_t {
    pub m_eResult: EResult,
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_bUserNeedsToAcceptWorkshopLegalAgreement: bool,
}
pub const CreateItemResult_t_k_iCallback: CreateItemResult_t__bindgen_ty_1 =
    CreateItemResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CreateItemResult_t__bindgen_ty_1 {
    k_iCallback = 3403,
}
#[test]
fn bindgen_test_layout_CreateItemResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<CreateItemResult_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CreateItemResult_t>(),
        16usize,
        concat!("Size of: ", stringify!(CreateItemResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<CreateItemResult_t>(),
        4usize,
        concat!("Alignment of ", stringify!(CreateItemResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateItemResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateItemResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_bUserNeedsToAcceptWorkshopLegalAgreement) as usize
                - ptr as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateItemResult_t),
            "::",
            stringify!(m_bUserNeedsToAcceptWorkshopLegalAgreement)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct SubmitItemUpdateResult_t {
    pub m_eResult: EResult,
    pub m_bUserNeedsToAcceptWorkshopLegalAgreement: bool,
    pub m_nPublishedFileId: PublishedFileId_t,
}
pub const SubmitItemUpdateResult_t_k_iCallback: SubmitItemUpdateResult_t__bindgen_ty_1 =
    SubmitItemUpdateResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SubmitItemUpdateResult_t__bindgen_ty_1 {
    k_iCallback = 3404,
}
#[test]
fn bindgen_test_layout_SubmitItemUpdateResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<SubmitItemUpdateResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SubmitItemUpdateResult_t>(),
        16usize,
        concat!("Size of: ", stringify!(SubmitItemUpdateResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SubmitItemUpdateResult_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SubmitItemUpdateResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubmitItemUpdateResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_bUserNeedsToAcceptWorkshopLegalAgreement) as usize
                - ptr as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SubmitItemUpdateResult_t),
            "::",
            stringify!(m_bUserNeedsToAcceptWorkshopLegalAgreement)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SubmitItemUpdateResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct ItemInstalled_t {
    pub m_unAppID: AppId_t,
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_hLegacyContent: UGCHandle_t,
    pub m_unManifestID: uint64,
}
pub const ItemInstalled_t_k_iCallback: ItemInstalled_t__bindgen_ty_1 =
    ItemInstalled_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ItemInstalled_t__bindgen_ty_1 {
    k_iCallback = 3405,
}
#[test]
fn bindgen_test_layout_ItemInstalled_t() {
    const UNINIT: ::std::mem::MaybeUninit<ItemInstalled_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ItemInstalled_t>(),
        28usize,
        concat!("Size of: ", stringify!(ItemInstalled_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ItemInstalled_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ItemInstalled_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unAppID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ItemInstalled_t),
            "::",
            stringify!(m_unAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ItemInstalled_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hLegacyContent) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ItemInstalled_t),
            "::",
            stringify!(m_hLegacyContent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unManifestID) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ItemInstalled_t),
            "::",
            stringify!(m_unManifestID)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct DownloadItemResult_t {
    pub m_unAppID: AppId_t,
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_eResult: EResult,
}
pub const DownloadItemResult_t_k_iCallback: DownloadItemResult_t__bindgen_ty_1 =
    DownloadItemResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum DownloadItemResult_t__bindgen_ty_1 {
    k_iCallback = 3406,
}
#[test]
fn bindgen_test_layout_DownloadItemResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<DownloadItemResult_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DownloadItemResult_t>(),
        16usize,
        concat!("Size of: ", stringify!(DownloadItemResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<DownloadItemResult_t>(),
        4usize,
        concat!("Alignment of ", stringify!(DownloadItemResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unAppID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DownloadItemResult_t),
            "::",
            stringify!(m_unAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DownloadItemResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DownloadItemResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct UserFavoriteItemsListChanged_t {
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_eResult: EResult,
    pub m_bWasAddRequest: bool,
}
pub const UserFavoriteItemsListChanged_t_k_iCallback: UserFavoriteItemsListChanged_t__bindgen_ty_1 =
    UserFavoriteItemsListChanged_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum UserFavoriteItemsListChanged_t__bindgen_ty_1 {
    k_iCallback = 3407,
}
#[test]
fn bindgen_test_layout_UserFavoriteItemsListChanged_t() {
    const UNINIT: ::std::mem::MaybeUninit<UserFavoriteItemsListChanged_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<UserFavoriteItemsListChanged_t>(),
        16usize,
        concat!("Size of: ", stringify!(UserFavoriteItemsListChanged_t))
    );
    assert_eq!(
        ::std::mem::align_of::<UserFavoriteItemsListChanged_t>(),
        4usize,
        concat!("Alignment of ", stringify!(UserFavoriteItemsListChanged_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UserFavoriteItemsListChanged_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UserFavoriteItemsListChanged_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bWasAddRequest) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UserFavoriteItemsListChanged_t),
            "::",
            stringify!(m_bWasAddRequest)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct SetUserItemVoteResult_t {
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_eResult: EResult,
    pub m_bVoteUp: bool,
}
pub const SetUserItemVoteResult_t_k_iCallback: SetUserItemVoteResult_t__bindgen_ty_1 =
    SetUserItemVoteResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SetUserItemVoteResult_t__bindgen_ty_1 {
    k_iCallback = 3408,
}
#[test]
fn bindgen_test_layout_SetUserItemVoteResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<SetUserItemVoteResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SetUserItemVoteResult_t>(),
        16usize,
        concat!("Size of: ", stringify!(SetUserItemVoteResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SetUserItemVoteResult_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SetUserItemVoteResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SetUserItemVoteResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SetUserItemVoteResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bVoteUp) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SetUserItemVoteResult_t),
            "::",
            stringify!(m_bVoteUp)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct GetUserItemVoteResult_t {
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_eResult: EResult,
    pub m_bVotedUp: bool,
    pub m_bVotedDown: bool,
    pub m_bVoteSkipped: bool,
}
pub const GetUserItemVoteResult_t_k_iCallback: GetUserItemVoteResult_t__bindgen_ty_1 =
    GetUserItemVoteResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GetUserItemVoteResult_t__bindgen_ty_1 {
    k_iCallback = 3409,
}
#[test]
fn bindgen_test_layout_GetUserItemVoteResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<GetUserItemVoteResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GetUserItemVoteResult_t>(),
        16usize,
        concat!("Size of: ", stringify!(GetUserItemVoteResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GetUserItemVoteResult_t>(),
        4usize,
        concat!("Alignment of ", stringify!(GetUserItemVoteResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GetUserItemVoteResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GetUserItemVoteResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bVotedUp) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GetUserItemVoteResult_t),
            "::",
            stringify!(m_bVotedUp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bVotedDown) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(GetUserItemVoteResult_t),
            "::",
            stringify!(m_bVotedDown)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bVoteSkipped) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(GetUserItemVoteResult_t),
            "::",
            stringify!(m_bVoteSkipped)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StartPlaytimeTrackingResult_t {
    pub m_eResult: EResult,
}
pub const StartPlaytimeTrackingResult_t_k_iCallback: StartPlaytimeTrackingResult_t__bindgen_ty_1 =
    StartPlaytimeTrackingResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum StartPlaytimeTrackingResult_t__bindgen_ty_1 {
    k_iCallback = 3410,
}
#[test]
fn bindgen_test_layout_StartPlaytimeTrackingResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<StartPlaytimeTrackingResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<StartPlaytimeTrackingResult_t>(),
        4usize,
        concat!("Size of: ", stringify!(StartPlaytimeTrackingResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<StartPlaytimeTrackingResult_t>(),
        4usize,
        concat!("Alignment of ", stringify!(StartPlaytimeTrackingResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(StartPlaytimeTrackingResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StopPlaytimeTrackingResult_t {
    pub m_eResult: EResult,
}
pub const StopPlaytimeTrackingResult_t_k_iCallback: StopPlaytimeTrackingResult_t__bindgen_ty_1 =
    StopPlaytimeTrackingResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum StopPlaytimeTrackingResult_t__bindgen_ty_1 {
    k_iCallback = 3411,
}
#[test]
fn bindgen_test_layout_StopPlaytimeTrackingResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<StopPlaytimeTrackingResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<StopPlaytimeTrackingResult_t>(),
        4usize,
        concat!("Size of: ", stringify!(StopPlaytimeTrackingResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<StopPlaytimeTrackingResult_t>(),
        4usize,
        concat!("Alignment of ", stringify!(StopPlaytimeTrackingResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(StopPlaytimeTrackingResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct AddUGCDependencyResult_t {
    pub m_eResult: EResult,
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_nChildPublishedFileId: PublishedFileId_t,
}
pub const AddUGCDependencyResult_t_k_iCallback: AddUGCDependencyResult_t__bindgen_ty_1 =
    AddUGCDependencyResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AddUGCDependencyResult_t__bindgen_ty_1 {
    k_iCallback = 3412,
}
#[test]
fn bindgen_test_layout_AddUGCDependencyResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<AddUGCDependencyResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AddUGCDependencyResult_t>(),
        20usize,
        concat!("Size of: ", stringify!(AddUGCDependencyResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<AddUGCDependencyResult_t>(),
        4usize,
        concat!("Alignment of ", stringify!(AddUGCDependencyResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AddUGCDependencyResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AddUGCDependencyResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nChildPublishedFileId) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AddUGCDependencyResult_t),
            "::",
            stringify!(m_nChildPublishedFileId)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct RemoveUGCDependencyResult_t {
    pub m_eResult: EResult,
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_nChildPublishedFileId: PublishedFileId_t,
}
pub const RemoveUGCDependencyResult_t_k_iCallback: RemoveUGCDependencyResult_t__bindgen_ty_1 =
    RemoveUGCDependencyResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RemoveUGCDependencyResult_t__bindgen_ty_1 {
    k_iCallback = 3413,
}
#[test]
fn bindgen_test_layout_RemoveUGCDependencyResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoveUGCDependencyResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoveUGCDependencyResult_t>(),
        20usize,
        concat!("Size of: ", stringify!(RemoveUGCDependencyResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<RemoveUGCDependencyResult_t>(),
        4usize,
        concat!("Alignment of ", stringify!(RemoveUGCDependencyResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoveUGCDependencyResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoveUGCDependencyResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nChildPublishedFileId) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoveUGCDependencyResult_t),
            "::",
            stringify!(m_nChildPublishedFileId)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct AddAppDependencyResult_t {
    pub m_eResult: EResult,
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_nAppID: AppId_t,
}
pub const AddAppDependencyResult_t_k_iCallback: AddAppDependencyResult_t__bindgen_ty_1 =
    AddAppDependencyResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AddAppDependencyResult_t__bindgen_ty_1 {
    k_iCallback = 3414,
}
#[test]
fn bindgen_test_layout_AddAppDependencyResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<AddAppDependencyResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AddAppDependencyResult_t>(),
        16usize,
        concat!("Size of: ", stringify!(AddAppDependencyResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<AddAppDependencyResult_t>(),
        4usize,
        concat!("Alignment of ", stringify!(AddAppDependencyResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AddAppDependencyResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AddAppDependencyResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nAppID) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AddAppDependencyResult_t),
            "::",
            stringify!(m_nAppID)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct RemoveAppDependencyResult_t {
    pub m_eResult: EResult,
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_nAppID: AppId_t,
}
pub const RemoveAppDependencyResult_t_k_iCallback: RemoveAppDependencyResult_t__bindgen_ty_1 =
    RemoveAppDependencyResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RemoveAppDependencyResult_t__bindgen_ty_1 {
    k_iCallback = 3415,
}
#[test]
fn bindgen_test_layout_RemoveAppDependencyResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoveAppDependencyResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoveAppDependencyResult_t>(),
        16usize,
        concat!("Size of: ", stringify!(RemoveAppDependencyResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<RemoveAppDependencyResult_t>(),
        4usize,
        concat!("Alignment of ", stringify!(RemoveAppDependencyResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoveAppDependencyResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoveAppDependencyResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nAppID) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoveAppDependencyResult_t),
            "::",
            stringify!(m_nAppID)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct GetAppDependenciesResult_t {
    pub m_eResult: EResult,
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_rgAppIDs: [AppId_t; 32usize],
    pub m_nNumAppDependencies: uint32,
    pub m_nTotalNumAppDependencies: uint32,
}
pub const GetAppDependenciesResult_t_k_iCallback: GetAppDependenciesResult_t__bindgen_ty_1 =
    GetAppDependenciesResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GetAppDependenciesResult_t__bindgen_ty_1 {
    k_iCallback = 3416,
}
#[test]
fn bindgen_test_layout_GetAppDependenciesResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<GetAppDependenciesResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GetAppDependenciesResult_t>(),
        148usize,
        concat!("Size of: ", stringify!(GetAppDependenciesResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GetAppDependenciesResult_t>(),
        4usize,
        concat!("Alignment of ", stringify!(GetAppDependenciesResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GetAppDependenciesResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GetAppDependenciesResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgAppIDs) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GetAppDependenciesResult_t),
            "::",
            stringify!(m_rgAppIDs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nNumAppDependencies) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(GetAppDependenciesResult_t),
            "::",
            stringify!(m_nNumAppDependencies)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nTotalNumAppDependencies) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(GetAppDependenciesResult_t),
            "::",
            stringify!(m_nTotalNumAppDependencies)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct DeleteItemResult_t {
    pub m_eResult: EResult,
    pub m_nPublishedFileId: PublishedFileId_t,
}
pub const DeleteItemResult_t_k_iCallback: DeleteItemResult_t__bindgen_ty_1 =
    DeleteItemResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum DeleteItemResult_t__bindgen_ty_1 {
    k_iCallback = 3417,
}
#[test]
fn bindgen_test_layout_DeleteItemResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<DeleteItemResult_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DeleteItemResult_t>(),
        12usize,
        concat!("Size of: ", stringify!(DeleteItemResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<DeleteItemResult_t>(),
        4usize,
        concat!("Alignment of ", stringify!(DeleteItemResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DeleteItemResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DeleteItemResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UserSubscribedItemsListChanged_t {
    pub m_nAppID: AppId_t,
}
pub const UserSubscribedItemsListChanged_t_k_iCallback:
    UserSubscribedItemsListChanged_t__bindgen_ty_1 =
    UserSubscribedItemsListChanged_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum UserSubscribedItemsListChanged_t__bindgen_ty_1 {
    k_iCallback = 3418,
}
#[test]
fn bindgen_test_layout_UserSubscribedItemsListChanged_t() {
    const UNINIT: ::std::mem::MaybeUninit<UserSubscribedItemsListChanged_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<UserSubscribedItemsListChanged_t>(),
        4usize,
        concat!("Size of: ", stringify!(UserSubscribedItemsListChanged_t))
    );
    assert_eq!(
        ::std::mem::align_of::<UserSubscribedItemsListChanged_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(UserSubscribedItemsListChanged_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nAppID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UserSubscribedItemsListChanged_t),
            "::",
            stringify!(m_nAppID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WorkshopEULAStatus_t {
    pub m_eResult: EResult,
    pub m_nAppID: AppId_t,
    pub m_unVersion: uint32,
    pub m_rtAction: RTime32,
    pub m_bAccepted: bool,
    pub m_bNeedsAction: bool,
}
pub const WorkshopEULAStatus_t_k_iCallback: WorkshopEULAStatus_t__bindgen_ty_1 =
    WorkshopEULAStatus_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum WorkshopEULAStatus_t__bindgen_ty_1 {
    k_iCallback = 3420,
}
#[test]
fn bindgen_test_layout_WorkshopEULAStatus_t() {
    const UNINIT: ::std::mem::MaybeUninit<WorkshopEULAStatus_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<WorkshopEULAStatus_t>(),
        20usize,
        concat!("Size of: ", stringify!(WorkshopEULAStatus_t))
    );
    assert_eq!(
        ::std::mem::align_of::<WorkshopEULAStatus_t>(),
        4usize,
        concat!("Alignment of ", stringify!(WorkshopEULAStatus_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WorkshopEULAStatus_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nAppID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WorkshopEULAStatus_t),
            "::",
            stringify!(m_nAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unVersion) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WorkshopEULAStatus_t),
            "::",
            stringify!(m_unVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rtAction) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(WorkshopEULAStatus_t),
            "::",
            stringify!(m_rtAction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bAccepted) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WorkshopEULAStatus_t),
            "::",
            stringify!(m_bAccepted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bNeedsAction) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(WorkshopEULAStatus_t),
            "::",
            stringify!(m_bNeedsAction)
        )
    );
}
pub type HHTMLBrowser = uint32;
pub const INVALID_HTMLBROWSER: uint32 = 0;
#[repr(C)]
pub struct ISteamHTMLSurface__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct ISteamHTMLSurface {
    pub vtable_: *const ISteamHTMLSurface__bindgen_vtable,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ISteamHTMLSurface_EHTMLMouseButton {
    eHTMLMouseButton_Left = 0,
    eHTMLMouseButton_Right = 1,
    eHTMLMouseButton_Middle = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ISteamHTMLSurface_EHTMLMouseCursor {
    k_EHTMLMouseCursor_User = 0,
    k_EHTMLMouseCursor_None = 1,
    k_EHTMLMouseCursor_Arrow = 2,
    k_EHTMLMouseCursor_IBeam = 3,
    k_EHTMLMouseCursor_Hourglass = 4,
    k_EHTMLMouseCursor_WaitArrow = 5,
    k_EHTMLMouseCursor_Crosshair = 6,
    k_EHTMLMouseCursor_Up = 7,
    k_EHTMLMouseCursor_SizeNW = 8,
    k_EHTMLMouseCursor_SizeSE = 9,
    k_EHTMLMouseCursor_SizeNE = 10,
    k_EHTMLMouseCursor_SizeSW = 11,
    k_EHTMLMouseCursor_SizeW = 12,
    k_EHTMLMouseCursor_SizeE = 13,
    k_EHTMLMouseCursor_SizeN = 14,
    k_EHTMLMouseCursor_SizeS = 15,
    k_EHTMLMouseCursor_SizeWE = 16,
    k_EHTMLMouseCursor_SizeNS = 17,
    k_EHTMLMouseCursor_SizeAll = 18,
    k_EHTMLMouseCursor_No = 19,
    k_EHTMLMouseCursor_Hand = 20,
    k_EHTMLMouseCursor_Blank = 21,
    k_EHTMLMouseCursor_MiddlePan = 22,
    k_EHTMLMouseCursor_NorthPan = 23,
    k_EHTMLMouseCursor_NorthEastPan = 24,
    k_EHTMLMouseCursor_EastPan = 25,
    k_EHTMLMouseCursor_SouthEastPan = 26,
    k_EHTMLMouseCursor_SouthPan = 27,
    k_EHTMLMouseCursor_SouthWestPan = 28,
    k_EHTMLMouseCursor_WestPan = 29,
    k_EHTMLMouseCursor_NorthWestPan = 30,
    k_EHTMLMouseCursor_Alias = 31,
    k_EHTMLMouseCursor_Cell = 32,
    k_EHTMLMouseCursor_ColResize = 33,
    k_EHTMLMouseCursor_CopyCur = 34,
    k_EHTMLMouseCursor_VerticalText = 35,
    k_EHTMLMouseCursor_RowResize = 36,
    k_EHTMLMouseCursor_ZoomIn = 37,
    k_EHTMLMouseCursor_ZoomOut = 38,
    k_EHTMLMouseCursor_Help = 39,
    k_EHTMLMouseCursor_Custom = 40,
    k_EHTMLMouseCursor_SizeNWSE = 41,
    k_EHTMLMouseCursor_SizeNESW = 42,
    k_EHTMLMouseCursor_last = 43,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ISteamHTMLSurface_EHTMLKeyModifiers {
    k_eHTMLKeyModifier_None = 0,
    k_eHTMLKeyModifier_AltDown = 1,
    k_eHTMLKeyModifier_CtrlDown = 2,
    k_eHTMLKeyModifier_ShiftDown = 4,
}
#[test]
fn bindgen_test_layout_ISteamHTMLSurface() {
    assert_eq!(
        ::std::mem::size_of::<ISteamHTMLSurface>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamHTMLSurface))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamHTMLSurface>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamHTMLSurface))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTML_BrowserReady_t {
    pub unBrowserHandle: HHTMLBrowser,
}
pub const HTML_BrowserReady_t_k_iCallback: HTML_BrowserReady_t__bindgen_ty_1 =
    HTML_BrowserReady_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HTML_BrowserReady_t__bindgen_ty_1 {
    k_iCallback = 4501,
}
#[test]
fn bindgen_test_layout_HTML_BrowserReady_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_BrowserReady_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_BrowserReady_t>(),
        4usize,
        concat!("Size of: ", stringify!(HTML_BrowserReady_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_BrowserReady_t>(),
        4usize,
        concat!("Alignment of ", stringify!(HTML_BrowserReady_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_BrowserReady_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct HTML_NeedsPaint_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub pBGRA: *const ::std::os::raw::c_char,
    pub unWide: uint32,
    pub unTall: uint32,
    pub unUpdateX: uint32,
    pub unUpdateY: uint32,
    pub unUpdateWide: uint32,
    pub unUpdateTall: uint32,
    pub unScrollX: uint32,
    pub unScrollY: uint32,
    pub flPageScale: f32,
    pub unPageSerial: uint32,
}
pub const HTML_NeedsPaint_t_k_iCallback: HTML_NeedsPaint_t__bindgen_ty_1 =
    HTML_NeedsPaint_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HTML_NeedsPaint_t__bindgen_ty_1 {
    k_iCallback = 4502,
}
#[test]
fn bindgen_test_layout_HTML_NeedsPaint_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_NeedsPaint_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_NeedsPaint_t>(),
        52usize,
        concat!("Size of: ", stringify!(HTML_NeedsPaint_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_NeedsPaint_t>(),
        4usize,
        concat!("Alignment of ", stringify!(HTML_NeedsPaint_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NeedsPaint_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pBGRA) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NeedsPaint_t),
            "::",
            stringify!(pBGRA)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unWide) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NeedsPaint_t),
            "::",
            stringify!(unWide)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unTall) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NeedsPaint_t),
            "::",
            stringify!(unTall)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unUpdateX) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NeedsPaint_t),
            "::",
            stringify!(unUpdateX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unUpdateY) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NeedsPaint_t),
            "::",
            stringify!(unUpdateY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unUpdateWide) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NeedsPaint_t),
            "::",
            stringify!(unUpdateWide)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unUpdateTall) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NeedsPaint_t),
            "::",
            stringify!(unUpdateTall)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unScrollX) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NeedsPaint_t),
            "::",
            stringify!(unScrollX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unScrollY) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NeedsPaint_t),
            "::",
            stringify!(unScrollY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flPageScale) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NeedsPaint_t),
            "::",
            stringify!(flPageScale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unPageSerial) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NeedsPaint_t),
            "::",
            stringify!(unPageSerial)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct HTML_StartRequest_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub pchURL: *const ::std::os::raw::c_char,
    pub pchTarget: *const ::std::os::raw::c_char,
    pub pchPostData: *const ::std::os::raw::c_char,
    pub bIsRedirect: bool,
}
pub const HTML_StartRequest_t_k_iCallback: HTML_StartRequest_t__bindgen_ty_1 =
    HTML_StartRequest_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HTML_StartRequest_t__bindgen_ty_1 {
    k_iCallback = 4503,
}
#[test]
fn bindgen_test_layout_HTML_StartRequest_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_StartRequest_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_StartRequest_t>(),
        32usize,
        concat!("Size of: ", stringify!(HTML_StartRequest_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_StartRequest_t>(),
        4usize,
        concat!("Alignment of ", stringify!(HTML_StartRequest_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_StartRequest_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchURL) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_StartRequest_t),
            "::",
            stringify!(pchURL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchTarget) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_StartRequest_t),
            "::",
            stringify!(pchTarget)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchPostData) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_StartRequest_t),
            "::",
            stringify!(pchPostData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bIsRedirect) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_StartRequest_t),
            "::",
            stringify!(bIsRedirect)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTML_CloseBrowser_t {
    pub unBrowserHandle: HHTMLBrowser,
}
pub const HTML_CloseBrowser_t_k_iCallback: HTML_CloseBrowser_t__bindgen_ty_1 =
    HTML_CloseBrowser_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HTML_CloseBrowser_t__bindgen_ty_1 {
    k_iCallback = 4504,
}
#[test]
fn bindgen_test_layout_HTML_CloseBrowser_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_CloseBrowser_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_CloseBrowser_t>(),
        4usize,
        concat!("Size of: ", stringify!(HTML_CloseBrowser_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_CloseBrowser_t>(),
        4usize,
        concat!("Alignment of ", stringify!(HTML_CloseBrowser_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_CloseBrowser_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct HTML_URLChanged_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub pchURL: *const ::std::os::raw::c_char,
    pub pchPostData: *const ::std::os::raw::c_char,
    pub bIsRedirect: bool,
    pub pchPageTitle: *const ::std::os::raw::c_char,
    pub bNewNavigation: bool,
}
pub const HTML_URLChanged_t_k_iCallback: HTML_URLChanged_t__bindgen_ty_1 =
    HTML_URLChanged_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HTML_URLChanged_t__bindgen_ty_1 {
    k_iCallback = 4505,
}
#[test]
fn bindgen_test_layout_HTML_URLChanged_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_URLChanged_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_URLChanged_t>(),
        36usize,
        concat!("Size of: ", stringify!(HTML_URLChanged_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_URLChanged_t>(),
        4usize,
        concat!("Alignment of ", stringify!(HTML_URLChanged_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_URLChanged_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchURL) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_URLChanged_t),
            "::",
            stringify!(pchURL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchPostData) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_URLChanged_t),
            "::",
            stringify!(pchPostData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bIsRedirect) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_URLChanged_t),
            "::",
            stringify!(bIsRedirect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchPageTitle) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_URLChanged_t),
            "::",
            stringify!(pchPageTitle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bNewNavigation) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_URLChanged_t),
            "::",
            stringify!(bNewNavigation)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct HTML_FinishedRequest_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub pchURL: *const ::std::os::raw::c_char,
    pub pchPageTitle: *const ::std::os::raw::c_char,
}
pub const HTML_FinishedRequest_t_k_iCallback: HTML_FinishedRequest_t__bindgen_ty_1 =
    HTML_FinishedRequest_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HTML_FinishedRequest_t__bindgen_ty_1 {
    k_iCallback = 4506,
}
#[test]
fn bindgen_test_layout_HTML_FinishedRequest_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_FinishedRequest_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_FinishedRequest_t>(),
        20usize,
        concat!("Size of: ", stringify!(HTML_FinishedRequest_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_FinishedRequest_t>(),
        4usize,
        concat!("Alignment of ", stringify!(HTML_FinishedRequest_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_FinishedRequest_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchURL) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_FinishedRequest_t),
            "::",
            stringify!(pchURL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchPageTitle) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_FinishedRequest_t),
            "::",
            stringify!(pchPageTitle)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct HTML_OpenLinkInNewTab_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub pchURL: *const ::std::os::raw::c_char,
}
pub const HTML_OpenLinkInNewTab_t_k_iCallback: HTML_OpenLinkInNewTab_t__bindgen_ty_1 =
    HTML_OpenLinkInNewTab_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HTML_OpenLinkInNewTab_t__bindgen_ty_1 {
    k_iCallback = 4507,
}
#[test]
fn bindgen_test_layout_HTML_OpenLinkInNewTab_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_OpenLinkInNewTab_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_OpenLinkInNewTab_t>(),
        12usize,
        concat!("Size of: ", stringify!(HTML_OpenLinkInNewTab_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_OpenLinkInNewTab_t>(),
        4usize,
        concat!("Alignment of ", stringify!(HTML_OpenLinkInNewTab_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_OpenLinkInNewTab_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchURL) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_OpenLinkInNewTab_t),
            "::",
            stringify!(pchURL)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct HTML_ChangedTitle_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub pchTitle: *const ::std::os::raw::c_char,
}
pub const HTML_ChangedTitle_t_k_iCallback: HTML_ChangedTitle_t__bindgen_ty_1 =
    HTML_ChangedTitle_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HTML_ChangedTitle_t__bindgen_ty_1 {
    k_iCallback = 4508,
}
#[test]
fn bindgen_test_layout_HTML_ChangedTitle_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_ChangedTitle_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_ChangedTitle_t>(),
        12usize,
        concat!("Size of: ", stringify!(HTML_ChangedTitle_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_ChangedTitle_t>(),
        4usize,
        concat!("Alignment of ", stringify!(HTML_ChangedTitle_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_ChangedTitle_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchTitle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_ChangedTitle_t),
            "::",
            stringify!(pchTitle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTML_SearchResults_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub unResults: uint32,
    pub unCurrentMatch: uint32,
}
pub const HTML_SearchResults_t_k_iCallback: HTML_SearchResults_t__bindgen_ty_1 =
    HTML_SearchResults_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HTML_SearchResults_t__bindgen_ty_1 {
    k_iCallback = 4509,
}
#[test]
fn bindgen_test_layout_HTML_SearchResults_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_SearchResults_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_SearchResults_t>(),
        12usize,
        concat!("Size of: ", stringify!(HTML_SearchResults_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_SearchResults_t>(),
        4usize,
        concat!("Alignment of ", stringify!(HTML_SearchResults_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_SearchResults_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unResults) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_SearchResults_t),
            "::",
            stringify!(unResults)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unCurrentMatch) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_SearchResults_t),
            "::",
            stringify!(unCurrentMatch)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTML_CanGoBackAndForward_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub bCanGoBack: bool,
    pub bCanGoForward: bool,
}
pub const HTML_CanGoBackAndForward_t_k_iCallback: HTML_CanGoBackAndForward_t__bindgen_ty_1 =
    HTML_CanGoBackAndForward_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HTML_CanGoBackAndForward_t__bindgen_ty_1 {
    k_iCallback = 4510,
}
#[test]
fn bindgen_test_layout_HTML_CanGoBackAndForward_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_CanGoBackAndForward_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_CanGoBackAndForward_t>(),
        8usize,
        concat!("Size of: ", stringify!(HTML_CanGoBackAndForward_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_CanGoBackAndForward_t>(),
        4usize,
        concat!("Alignment of ", stringify!(HTML_CanGoBackAndForward_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_CanGoBackAndForward_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bCanGoBack) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_CanGoBackAndForward_t),
            "::",
            stringify!(bCanGoBack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bCanGoForward) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_CanGoBackAndForward_t),
            "::",
            stringify!(bCanGoForward)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTML_HorizontalScroll_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub unScrollMax: uint32,
    pub unScrollCurrent: uint32,
    pub flPageScale: f32,
    pub bVisible: bool,
    pub unPageSize: uint32,
}
pub const HTML_HorizontalScroll_t_k_iCallback: HTML_HorizontalScroll_t__bindgen_ty_1 =
    HTML_HorizontalScroll_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HTML_HorizontalScroll_t__bindgen_ty_1 {
    k_iCallback = 4511,
}
#[test]
fn bindgen_test_layout_HTML_HorizontalScroll_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_HorizontalScroll_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_HorizontalScroll_t>(),
        24usize,
        concat!("Size of: ", stringify!(HTML_HorizontalScroll_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_HorizontalScroll_t>(),
        4usize,
        concat!("Alignment of ", stringify!(HTML_HorizontalScroll_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_HorizontalScroll_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unScrollMax) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_HorizontalScroll_t),
            "::",
            stringify!(unScrollMax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unScrollCurrent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_HorizontalScroll_t),
            "::",
            stringify!(unScrollCurrent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flPageScale) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_HorizontalScroll_t),
            "::",
            stringify!(flPageScale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bVisible) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_HorizontalScroll_t),
            "::",
            stringify!(bVisible)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unPageSize) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_HorizontalScroll_t),
            "::",
            stringify!(unPageSize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTML_VerticalScroll_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub unScrollMax: uint32,
    pub unScrollCurrent: uint32,
    pub flPageScale: f32,
    pub bVisible: bool,
    pub unPageSize: uint32,
}
pub const HTML_VerticalScroll_t_k_iCallback: HTML_VerticalScroll_t__bindgen_ty_1 =
    HTML_VerticalScroll_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HTML_VerticalScroll_t__bindgen_ty_1 {
    k_iCallback = 4512,
}
#[test]
fn bindgen_test_layout_HTML_VerticalScroll_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_VerticalScroll_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_VerticalScroll_t>(),
        24usize,
        concat!("Size of: ", stringify!(HTML_VerticalScroll_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_VerticalScroll_t>(),
        4usize,
        concat!("Alignment of ", stringify!(HTML_VerticalScroll_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_VerticalScroll_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unScrollMax) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_VerticalScroll_t),
            "::",
            stringify!(unScrollMax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unScrollCurrent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_VerticalScroll_t),
            "::",
            stringify!(unScrollCurrent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flPageScale) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_VerticalScroll_t),
            "::",
            stringify!(flPageScale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bVisible) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_VerticalScroll_t),
            "::",
            stringify!(bVisible)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unPageSize) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_VerticalScroll_t),
            "::",
            stringify!(unPageSize)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct HTML_LinkAtPosition_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub x: uint32,
    pub y: uint32,
    pub pchURL: *const ::std::os::raw::c_char,
    pub bInput: bool,
    pub bLiveLink: bool,
}
pub const HTML_LinkAtPosition_t_k_iCallback: HTML_LinkAtPosition_t__bindgen_ty_1 =
    HTML_LinkAtPosition_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HTML_LinkAtPosition_t__bindgen_ty_1 {
    k_iCallback = 4513,
}
#[test]
fn bindgen_test_layout_HTML_LinkAtPosition_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_LinkAtPosition_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_LinkAtPosition_t>(),
        24usize,
        concat!("Size of: ", stringify!(HTML_LinkAtPosition_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_LinkAtPosition_t>(),
        4usize,
        concat!("Alignment of ", stringify!(HTML_LinkAtPosition_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_LinkAtPosition_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_LinkAtPosition_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_LinkAtPosition_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchURL) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_LinkAtPosition_t),
            "::",
            stringify!(pchURL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bInput) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_LinkAtPosition_t),
            "::",
            stringify!(bInput)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bLiveLink) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_LinkAtPosition_t),
            "::",
            stringify!(bLiveLink)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct HTML_JSAlert_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub pchMessage: *const ::std::os::raw::c_char,
}
pub const HTML_JSAlert_t_k_iCallback: HTML_JSAlert_t__bindgen_ty_1 =
    HTML_JSAlert_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HTML_JSAlert_t__bindgen_ty_1 {
    k_iCallback = 4514,
}
#[test]
fn bindgen_test_layout_HTML_JSAlert_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_JSAlert_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_JSAlert_t>(),
        12usize,
        concat!("Size of: ", stringify!(HTML_JSAlert_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_JSAlert_t>(),
        4usize,
        concat!("Alignment of ", stringify!(HTML_JSAlert_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_JSAlert_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchMessage) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_JSAlert_t),
            "::",
            stringify!(pchMessage)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct HTML_JSConfirm_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub pchMessage: *const ::std::os::raw::c_char,
}
pub const HTML_JSConfirm_t_k_iCallback: HTML_JSConfirm_t__bindgen_ty_1 =
    HTML_JSConfirm_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HTML_JSConfirm_t__bindgen_ty_1 {
    k_iCallback = 4515,
}
#[test]
fn bindgen_test_layout_HTML_JSConfirm_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_JSConfirm_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_JSConfirm_t>(),
        12usize,
        concat!("Size of: ", stringify!(HTML_JSConfirm_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_JSConfirm_t>(),
        4usize,
        concat!("Alignment of ", stringify!(HTML_JSConfirm_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_JSConfirm_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchMessage) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_JSConfirm_t),
            "::",
            stringify!(pchMessage)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct HTML_FileOpenDialog_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub pchTitle: *const ::std::os::raw::c_char,
    pub pchInitialFile: *const ::std::os::raw::c_char,
}
pub const HTML_FileOpenDialog_t_k_iCallback: HTML_FileOpenDialog_t__bindgen_ty_1 =
    HTML_FileOpenDialog_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HTML_FileOpenDialog_t__bindgen_ty_1 {
    k_iCallback = 4516,
}
#[test]
fn bindgen_test_layout_HTML_FileOpenDialog_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_FileOpenDialog_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_FileOpenDialog_t>(),
        20usize,
        concat!("Size of: ", stringify!(HTML_FileOpenDialog_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_FileOpenDialog_t>(),
        4usize,
        concat!("Alignment of ", stringify!(HTML_FileOpenDialog_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_FileOpenDialog_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchTitle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_FileOpenDialog_t),
            "::",
            stringify!(pchTitle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchInitialFile) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_FileOpenDialog_t),
            "::",
            stringify!(pchInitialFile)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct HTML_NewWindow_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub pchURL: *const ::std::os::raw::c_char,
    pub unX: uint32,
    pub unY: uint32,
    pub unWide: uint32,
    pub unTall: uint32,
    pub unNewWindow_BrowserHandle_IGNORE: HHTMLBrowser,
}
pub const HTML_NewWindow_t_k_iCallback: HTML_NewWindow_t__bindgen_ty_1 =
    HTML_NewWindow_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HTML_NewWindow_t__bindgen_ty_1 {
    k_iCallback = 4521,
}
#[test]
fn bindgen_test_layout_HTML_NewWindow_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_NewWindow_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_NewWindow_t>(),
        32usize,
        concat!("Size of: ", stringify!(HTML_NewWindow_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_NewWindow_t>(),
        4usize,
        concat!("Alignment of ", stringify!(HTML_NewWindow_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NewWindow_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchURL) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NewWindow_t),
            "::",
            stringify!(pchURL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unX) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NewWindow_t),
            "::",
            stringify!(unX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unY) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NewWindow_t),
            "::",
            stringify!(unY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unWide) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NewWindow_t),
            "::",
            stringify!(unWide)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unTall) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NewWindow_t),
            "::",
            stringify!(unTall)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).unNewWindow_BrowserHandle_IGNORE) as usize - ptr as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NewWindow_t),
            "::",
            stringify!(unNewWindow_BrowserHandle_IGNORE)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTML_SetCursor_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub eMouseCursor: uint32,
}
pub const HTML_SetCursor_t_k_iCallback: HTML_SetCursor_t__bindgen_ty_1 =
    HTML_SetCursor_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HTML_SetCursor_t__bindgen_ty_1 {
    k_iCallback = 4522,
}
#[test]
fn bindgen_test_layout_HTML_SetCursor_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_SetCursor_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_SetCursor_t>(),
        8usize,
        concat!("Size of: ", stringify!(HTML_SetCursor_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_SetCursor_t>(),
        4usize,
        concat!("Alignment of ", stringify!(HTML_SetCursor_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_SetCursor_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eMouseCursor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_SetCursor_t),
            "::",
            stringify!(eMouseCursor)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct HTML_StatusText_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub pchMsg: *const ::std::os::raw::c_char,
}
pub const HTML_StatusText_t_k_iCallback: HTML_StatusText_t__bindgen_ty_1 =
    HTML_StatusText_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HTML_StatusText_t__bindgen_ty_1 {
    k_iCallback = 4523,
}
#[test]
fn bindgen_test_layout_HTML_StatusText_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_StatusText_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_StatusText_t>(),
        12usize,
        concat!("Size of: ", stringify!(HTML_StatusText_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_StatusText_t>(),
        4usize,
        concat!("Alignment of ", stringify!(HTML_StatusText_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_StatusText_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchMsg) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_StatusText_t),
            "::",
            stringify!(pchMsg)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct HTML_ShowToolTip_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub pchMsg: *const ::std::os::raw::c_char,
}
pub const HTML_ShowToolTip_t_k_iCallback: HTML_ShowToolTip_t__bindgen_ty_1 =
    HTML_ShowToolTip_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HTML_ShowToolTip_t__bindgen_ty_1 {
    k_iCallback = 4524,
}
#[test]
fn bindgen_test_layout_HTML_ShowToolTip_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_ShowToolTip_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_ShowToolTip_t>(),
        12usize,
        concat!("Size of: ", stringify!(HTML_ShowToolTip_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_ShowToolTip_t>(),
        4usize,
        concat!("Alignment of ", stringify!(HTML_ShowToolTip_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_ShowToolTip_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchMsg) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_ShowToolTip_t),
            "::",
            stringify!(pchMsg)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct HTML_UpdateToolTip_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub pchMsg: *const ::std::os::raw::c_char,
}
pub const HTML_UpdateToolTip_t_k_iCallback: HTML_UpdateToolTip_t__bindgen_ty_1 =
    HTML_UpdateToolTip_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HTML_UpdateToolTip_t__bindgen_ty_1 {
    k_iCallback = 4525,
}
#[test]
fn bindgen_test_layout_HTML_UpdateToolTip_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_UpdateToolTip_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_UpdateToolTip_t>(),
        12usize,
        concat!("Size of: ", stringify!(HTML_UpdateToolTip_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_UpdateToolTip_t>(),
        4usize,
        concat!("Alignment of ", stringify!(HTML_UpdateToolTip_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_UpdateToolTip_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchMsg) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_UpdateToolTip_t),
            "::",
            stringify!(pchMsg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTML_HideToolTip_t {
    pub unBrowserHandle: HHTMLBrowser,
}
pub const HTML_HideToolTip_t_k_iCallback: HTML_HideToolTip_t__bindgen_ty_1 =
    HTML_HideToolTip_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HTML_HideToolTip_t__bindgen_ty_1 {
    k_iCallback = 4526,
}
#[test]
fn bindgen_test_layout_HTML_HideToolTip_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_HideToolTip_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_HideToolTip_t>(),
        4usize,
        concat!("Size of: ", stringify!(HTML_HideToolTip_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_HideToolTip_t>(),
        4usize,
        concat!("Alignment of ", stringify!(HTML_HideToolTip_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_HideToolTip_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTML_BrowserRestarted_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub unOldBrowserHandle: HHTMLBrowser,
}
pub const HTML_BrowserRestarted_t_k_iCallback: HTML_BrowserRestarted_t__bindgen_ty_1 =
    HTML_BrowserRestarted_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HTML_BrowserRestarted_t__bindgen_ty_1 {
    k_iCallback = 4527,
}
#[test]
fn bindgen_test_layout_HTML_BrowserRestarted_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_BrowserRestarted_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_BrowserRestarted_t>(),
        8usize,
        concat!("Size of: ", stringify!(HTML_BrowserRestarted_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_BrowserRestarted_t>(),
        4usize,
        concat!("Alignment of ", stringify!(HTML_BrowserRestarted_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_BrowserRestarted_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unOldBrowserHandle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_BrowserRestarted_t),
            "::",
            stringify!(unOldBrowserHandle)
        )
    );
}
pub type SteamItemInstanceID_t = uint64;
extern "C" {
    #[link_name = "\u{1}_ZL28k_SteamItemInstanceIDInvalid"]
    pub static k_SteamItemInstanceIDInvalid: SteamItemInstanceID_t;
}
pub type SteamItemDef_t = int32;
impl ESteamItemFlags {
    pub const k_ESteamItemNoTrade: ESteamItemFlags = ESteamItemFlags(1);
}
impl ESteamItemFlags {
    pub const k_ESteamItemRemoved: ESteamItemFlags = ESteamItemFlags(256);
}
impl ESteamItemFlags {
    pub const k_ESteamItemConsumed: ESteamItemFlags = ESteamItemFlags(512);
}
impl ::std::ops::BitOr<ESteamItemFlags> for ESteamItemFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ESteamItemFlags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ESteamItemFlags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ESteamItemFlags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ESteamItemFlags> for ESteamItemFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ESteamItemFlags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ESteamItemFlags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ESteamItemFlags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ESteamItemFlags(pub ::std::os::raw::c_uint);
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct SteamItemDetails_t {
    pub m_itemId: SteamItemInstanceID_t,
    pub m_iDefinition: SteamItemDef_t,
    pub m_unQuantity: uint16,
    pub m_unFlags: uint16,
}
#[test]
fn bindgen_test_layout_SteamItemDetails_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamItemDetails_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamItemDetails_t>(),
        16usize,
        concat!("Size of: ", stringify!(SteamItemDetails_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamItemDetails_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamItemDetails_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_itemId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamItemDetails_t),
            "::",
            stringify!(m_itemId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_iDefinition) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamItemDetails_t),
            "::",
            stringify!(m_iDefinition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unQuantity) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamItemDetails_t),
            "::",
            stringify!(m_unQuantity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unFlags) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamItemDetails_t),
            "::",
            stringify!(m_unFlags)
        )
    );
}
pub type SteamInventoryResult_t = int32;
pub const k_SteamInventoryResultInvalid: SteamInventoryResult_t = -1;
pub type SteamInventoryUpdateHandle_t = uint64;
pub const k_SteamInventoryUpdateHandleInvalid: SteamInventoryUpdateHandle_t = 18446744073709551615;
#[repr(C)]
pub struct ISteamInventory__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamInventory {
    pub vtable_: *const ISteamInventory__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamInventory() {
    assert_eq!(
        ::std::mem::size_of::<ISteamInventory>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamInventory))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamInventory>(),
        4usize,
        concat!("Alignment of ", stringify!(ISteamInventory))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamInventoryResultReady_t {
    pub m_handle: SteamInventoryResult_t,
    pub m_result: EResult,
}
pub const SteamInventoryResultReady_t_k_iCallback: SteamInventoryResultReady_t__bindgen_ty_1 =
    SteamInventoryResultReady_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamInventoryResultReady_t__bindgen_ty_1 {
    k_iCallback = 4700,
}
#[test]
fn bindgen_test_layout_SteamInventoryResultReady_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInventoryResultReady_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInventoryResultReady_t>(),
        8usize,
        concat!("Size of: ", stringify!(SteamInventoryResultReady_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInventoryResultReady_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamInventoryResultReady_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInventoryResultReady_t),
            "::",
            stringify!(m_handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_result) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInventoryResultReady_t),
            "::",
            stringify!(m_result)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamInventoryFullUpdate_t {
    pub m_handle: SteamInventoryResult_t,
}
pub const SteamInventoryFullUpdate_t_k_iCallback: SteamInventoryFullUpdate_t__bindgen_ty_1 =
    SteamInventoryFullUpdate_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamInventoryFullUpdate_t__bindgen_ty_1 {
    k_iCallback = 4701,
}
#[test]
fn bindgen_test_layout_SteamInventoryFullUpdate_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInventoryFullUpdate_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInventoryFullUpdate_t>(),
        4usize,
        concat!("Size of: ", stringify!(SteamInventoryFullUpdate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInventoryFullUpdate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamInventoryFullUpdate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInventoryFullUpdate_t),
            "::",
            stringify!(m_handle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamInventoryDefinitionUpdate_t {
    pub _address: u8,
}
pub const SteamInventoryDefinitionUpdate_t_k_iCallback:
    SteamInventoryDefinitionUpdate_t__bindgen_ty_1 =
    SteamInventoryDefinitionUpdate_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamInventoryDefinitionUpdate_t__bindgen_ty_1 {
    k_iCallback = 4702,
}
#[test]
fn bindgen_test_layout_SteamInventoryDefinitionUpdate_t() {
    assert_eq!(
        ::std::mem::size_of::<SteamInventoryDefinitionUpdate_t>(),
        1usize,
        concat!("Size of: ", stringify!(SteamInventoryDefinitionUpdate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInventoryDefinitionUpdate_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SteamInventoryDefinitionUpdate_t)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SteamInventoryEligiblePromoItemDefIDs_t {
    pub m_result: EResult,
    pub m_steamID: CSteamID,
    pub m_numEligiblePromoItemDefs: ::std::os::raw::c_int,
    pub m_bCachedData: bool,
}
pub const SteamInventoryEligiblePromoItemDefIDs_t_k_iCallback:
    SteamInventoryEligiblePromoItemDefIDs_t__bindgen_ty_1 =
    SteamInventoryEligiblePromoItemDefIDs_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamInventoryEligiblePromoItemDefIDs_t__bindgen_ty_1 {
    k_iCallback = 4703,
}
#[test]
fn bindgen_test_layout_SteamInventoryEligiblePromoItemDefIDs_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInventoryEligiblePromoItemDefIDs_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInventoryEligiblePromoItemDefIDs_t>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(SteamInventoryEligiblePromoItemDefIDs_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInventoryEligiblePromoItemDefIDs_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SteamInventoryEligiblePromoItemDefIDs_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_result) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInventoryEligiblePromoItemDefIDs_t),
            "::",
            stringify!(m_result)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInventoryEligiblePromoItemDefIDs_t),
            "::",
            stringify!(m_steamID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_numEligiblePromoItemDefs) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInventoryEligiblePromoItemDefIDs_t),
            "::",
            stringify!(m_numEligiblePromoItemDefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bCachedData) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInventoryEligiblePromoItemDefIDs_t),
            "::",
            stringify!(m_bCachedData)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct SteamInventoryStartPurchaseResult_t {
    pub m_result: EResult,
    pub m_ulOrderID: uint64,
    pub m_ulTransID: uint64,
}
pub const SteamInventoryStartPurchaseResult_t_k_iCallback:
    SteamInventoryStartPurchaseResult_t__bindgen_ty_1 =
    SteamInventoryStartPurchaseResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamInventoryStartPurchaseResult_t__bindgen_ty_1 {
    k_iCallback = 4704,
}
#[test]
fn bindgen_test_layout_SteamInventoryStartPurchaseResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInventoryStartPurchaseResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInventoryStartPurchaseResult_t>(),
        20usize,
        concat!("Size of: ", stringify!(SteamInventoryStartPurchaseResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInventoryStartPurchaseResult_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SteamInventoryStartPurchaseResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_result) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInventoryStartPurchaseResult_t),
            "::",
            stringify!(m_result)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulOrderID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInventoryStartPurchaseResult_t),
            "::",
            stringify!(m_ulOrderID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulTransID) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInventoryStartPurchaseResult_t),
            "::",
            stringify!(m_ulTransID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamInventoryRequestPricesResult_t {
    pub m_result: EResult,
    pub m_rgchCurrency: [::std::os::raw::c_char; 4usize],
}
pub const SteamInventoryRequestPricesResult_t_k_iCallback:
    SteamInventoryRequestPricesResult_t__bindgen_ty_1 =
    SteamInventoryRequestPricesResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamInventoryRequestPricesResult_t__bindgen_ty_1 {
    k_iCallback = 4705,
}
#[test]
fn bindgen_test_layout_SteamInventoryRequestPricesResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInventoryRequestPricesResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInventoryRequestPricesResult_t>(),
        8usize,
        concat!("Size of: ", stringify!(SteamInventoryRequestPricesResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInventoryRequestPricesResult_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SteamInventoryRequestPricesResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_result) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInventoryRequestPricesResult_t),
            "::",
            stringify!(m_result)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchCurrency) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInventoryRequestPricesResult_t),
            "::",
            stringify!(m_rgchCurrency)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ETimelineGameMode {
    k_ETimelineGameMode_Invalid = 0,
    k_ETimelineGameMode_Playing = 1,
    k_ETimelineGameMode_Staging = 2,
    k_ETimelineGameMode_Menus = 3,
    k_ETimelineGameMode_LoadingScreen = 4,
    k_ETimelineGameMode_Max = 5,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ETimelineEventClipPriority {
    k_ETimelineEventClipPriority_Invalid = 0,
    k_ETimelineEventClipPriority_None = 1,
    k_ETimelineEventClipPriority_Standard = 2,
    k_ETimelineEventClipPriority_Featured = 3,
}
pub const k_unMaxTimelinePriority: uint32 = 1000;
pub const k_unTimelinePriority_KeepCurrentValue: uint32 = 1000000;
pub const k_flMaxTimelineEventDuration: f32 = 600.0;
pub const k_cchMaxPhaseIDLength: uint32 = 64;
pub type TimelineEventHandle_t = uint64;
#[repr(C)]
pub struct ISteamTimeline__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamTimeline {
    pub vtable_: *const ISteamTimeline__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamTimeline() {
    assert_eq!(
        ::std::mem::size_of::<ISteamTimeline>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamTimeline))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamTimeline>(),
        4usize,
        concat!("Alignment of ", stringify!(ISteamTimeline))
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct SteamTimelineGamePhaseRecordingExists_t {
    pub m_rgchPhaseID: [::std::os::raw::c_char; 64usize],
    pub m_ulRecordingMS: uint64,
    pub m_ulLongestClipMS: uint64,
    pub m_unClipCount: uint32,
    pub m_unScreenshotCount: uint32,
}
pub const SteamTimelineGamePhaseRecordingExists_t_k_iCallback:
    SteamTimelineGamePhaseRecordingExists_t__bindgen_ty_1 =
    SteamTimelineGamePhaseRecordingExists_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamTimelineGamePhaseRecordingExists_t__bindgen_ty_1 {
    k_iCallback = 6001,
}
#[test]
fn bindgen_test_layout_SteamTimelineGamePhaseRecordingExists_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamTimelineGamePhaseRecordingExists_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamTimelineGamePhaseRecordingExists_t>(),
        88usize,
        concat!(
            "Size of: ",
            stringify!(SteamTimelineGamePhaseRecordingExists_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamTimelineGamePhaseRecordingExists_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SteamTimelineGamePhaseRecordingExists_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchPhaseID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamTimelineGamePhaseRecordingExists_t),
            "::",
            stringify!(m_rgchPhaseID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulRecordingMS) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamTimelineGamePhaseRecordingExists_t),
            "::",
            stringify!(m_ulRecordingMS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulLongestClipMS) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamTimelineGamePhaseRecordingExists_t),
            "::",
            stringify!(m_ulLongestClipMS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unClipCount) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamTimelineGamePhaseRecordingExists_t),
            "::",
            stringify!(m_unClipCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unScreenshotCount) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamTimelineGamePhaseRecordingExists_t),
            "::",
            stringify!(m_unScreenshotCount)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct SteamTimelineEventRecordingExists_t {
    pub m_ulEventID: uint64,
    pub m_bRecordingExists: bool,
}
pub const SteamTimelineEventRecordingExists_t_k_iCallback:
    SteamTimelineEventRecordingExists_t__bindgen_ty_1 =
    SteamTimelineEventRecordingExists_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamTimelineEventRecordingExists_t__bindgen_ty_1 {
    k_iCallback = 6002,
}
#[test]
fn bindgen_test_layout_SteamTimelineEventRecordingExists_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamTimelineEventRecordingExists_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamTimelineEventRecordingExists_t>(),
        12usize,
        concat!("Size of: ", stringify!(SteamTimelineEventRecordingExists_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamTimelineEventRecordingExists_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SteamTimelineEventRecordingExists_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulEventID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamTimelineEventRecordingExists_t),
            "::",
            stringify!(m_ulEventID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bRecordingExists) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamTimelineEventRecordingExists_t),
            "::",
            stringify!(m_bRecordingExists)
        )
    );
}
#[repr(C)]
pub struct ISteamVideo__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamVideo {
    pub vtable_: *const ISteamVideo__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamVideo() {
    assert_eq!(
        ::std::mem::size_of::<ISteamVideo>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamVideo))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamVideo>(),
        4usize,
        concat!("Alignment of ", stringify!(ISteamVideo))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GetVideoURLResult_t {
    pub m_eResult: EResult,
    pub m_unVideoAppID: AppId_t,
    pub m_rgchURL: [::std::os::raw::c_char; 256usize],
}
pub const GetVideoURLResult_t_k_iCallback: GetVideoURLResult_t__bindgen_ty_1 =
    GetVideoURLResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GetVideoURLResult_t__bindgen_ty_1 {
    k_iCallback = 4611,
}
#[test]
fn bindgen_test_layout_GetVideoURLResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<GetVideoURLResult_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GetVideoURLResult_t>(),
        264usize,
        concat!("Size of: ", stringify!(GetVideoURLResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GetVideoURLResult_t>(),
        4usize,
        concat!("Alignment of ", stringify!(GetVideoURLResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GetVideoURLResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unVideoAppID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GetVideoURLResult_t),
            "::",
            stringify!(m_unVideoAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchURL) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GetVideoURLResult_t),
            "::",
            stringify!(m_rgchURL)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GetOPFSettingsResult_t {
    pub m_eResult: EResult,
    pub m_unVideoAppID: AppId_t,
}
pub const GetOPFSettingsResult_t_k_iCallback: GetOPFSettingsResult_t__bindgen_ty_1 =
    GetOPFSettingsResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GetOPFSettingsResult_t__bindgen_ty_1 {
    k_iCallback = 4624,
}
#[test]
fn bindgen_test_layout_GetOPFSettingsResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<GetOPFSettingsResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GetOPFSettingsResult_t>(),
        8usize,
        concat!("Size of: ", stringify!(GetOPFSettingsResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GetOPFSettingsResult_t>(),
        4usize,
        concat!("Alignment of ", stringify!(GetOPFSettingsResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GetOPFSettingsResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unVideoAppID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GetOPFSettingsResult_t),
            "::",
            stringify!(m_unVideoAppID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BroadcastUploadStart_t {
    pub m_bIsRTMP: bool,
}
pub const BroadcastUploadStart_t_k_iCallback: BroadcastUploadStart_t__bindgen_ty_1 =
    BroadcastUploadStart_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum BroadcastUploadStart_t__bindgen_ty_1 {
    k_iCallback = 4604,
}
#[test]
fn bindgen_test_layout_BroadcastUploadStart_t() {
    const UNINIT: ::std::mem::MaybeUninit<BroadcastUploadStart_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BroadcastUploadStart_t>(),
        1usize,
        concat!("Size of: ", stringify!(BroadcastUploadStart_t))
    );
    assert_eq!(
        ::std::mem::align_of::<BroadcastUploadStart_t>(),
        1usize,
        concat!("Alignment of ", stringify!(BroadcastUploadStart_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bIsRTMP) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BroadcastUploadStart_t),
            "::",
            stringify!(m_bIsRTMP)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BroadcastUploadStop_t {
    pub m_eResult: EBroadcastUploadResult,
}
pub const BroadcastUploadStop_t_k_iCallback: BroadcastUploadStop_t__bindgen_ty_1 =
    BroadcastUploadStop_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum BroadcastUploadStop_t__bindgen_ty_1 {
    k_iCallback = 4605,
}
#[test]
fn bindgen_test_layout_BroadcastUploadStop_t() {
    const UNINIT: ::std::mem::MaybeUninit<BroadcastUploadStop_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BroadcastUploadStop_t>(),
        4usize,
        concat!("Size of: ", stringify!(BroadcastUploadStop_t))
    );
    assert_eq!(
        ::std::mem::align_of::<BroadcastUploadStop_t>(),
        4usize,
        concat!("Alignment of ", stringify!(BroadcastUploadStop_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BroadcastUploadStop_t),
            "::",
            stringify!(m_eResult)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EParentalFeature {
    k_EFeatureInvalid = 0,
    k_EFeatureStore = 1,
    k_EFeatureCommunity = 2,
    k_EFeatureProfile = 3,
    k_EFeatureFriends = 4,
    k_EFeatureNews = 5,
    k_EFeatureTrading = 6,
    k_EFeatureSettings = 7,
    k_EFeatureConsole = 8,
    k_EFeatureBrowser = 9,
    k_EFeatureParentalSetup = 10,
    k_EFeatureLibrary = 11,
    k_EFeatureTest = 12,
    k_EFeatureSiteLicense = 13,
    k_EFeatureKioskMode_Deprecated = 14,
    k_EFeatureBlockAlways = 15,
    k_EFeatureMax = 16,
}
#[repr(C)]
pub struct ISteamParentalSettings__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamParentalSettings {
    pub vtable_: *const ISteamParentalSettings__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamParentalSettings() {
    assert_eq!(
        ::std::mem::size_of::<ISteamParentalSettings>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamParentalSettings))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamParentalSettings>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamParentalSettings))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamParentalSettingsChanged_t {
    pub _address: u8,
}
pub const SteamParentalSettingsChanged_t_k_iCallback: SteamParentalSettingsChanged_t__bindgen_ty_1 =
    SteamParentalSettingsChanged_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamParentalSettingsChanged_t__bindgen_ty_1 {
    k_iCallback = 5001,
}
#[test]
fn bindgen_test_layout_SteamParentalSettingsChanged_t() {
    assert_eq!(
        ::std::mem::size_of::<SteamParentalSettingsChanged_t>(),
        1usize,
        concat!("Size of: ", stringify!(SteamParentalSettingsChanged_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamParentalSettingsChanged_t>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamParentalSettingsChanged_t))
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamDeviceFormFactor {
    k_ESteamDeviceFormFactorUnknown = 0,
    k_ESteamDeviceFormFactorPhone = 1,
    k_ESteamDeviceFormFactorTablet = 2,
    k_ESteamDeviceFormFactorComputer = 3,
    k_ESteamDeviceFormFactorTV = 4,
    k_ESteamDeviceFormFactorVRHeadset = 5,
}
pub type RemotePlaySessionID_t = uint32;
pub type RemotePlayCursorID_t = uint32;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ERemotePlayInputType {
    k_ERemotePlayInputUnknown = 0,
    k_ERemotePlayInputMouseMotion = 1,
    k_ERemotePlayInputMouseButtonDown = 2,
    k_ERemotePlayInputMouseButtonUp = 3,
    k_ERemotePlayInputMouseWheel = 4,
    k_ERemotePlayInputKeyDown = 5,
    k_ERemotePlayInputKeyUp = 6,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ERemotePlayMouseButton {
    k_ERemotePlayMouseButtonLeft = 1,
    k_ERemotePlayMouseButtonRight = 2,
    k_ERemotePlayMouseButtonMiddle = 16,
    k_ERemotePlayMouseButtonX1 = 32,
    k_ERemotePlayMouseButtonX2 = 64,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ERemotePlayMouseWheelDirection {
    k_ERemotePlayMouseWheelUp = 1,
    k_ERemotePlayMouseWheelDown = 2,
    k_ERemotePlayMouseWheelLeft = 3,
    k_ERemotePlayMouseWheelRight = 4,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ERemotePlayScancode {
    k_ERemotePlayScancodeUnknown = 0,
    k_ERemotePlayScancodeA = 4,
    k_ERemotePlayScancodeB = 5,
    k_ERemotePlayScancodeC = 6,
    k_ERemotePlayScancodeD = 7,
    k_ERemotePlayScancodeE = 8,
    k_ERemotePlayScancodeF = 9,
    k_ERemotePlayScancodeG = 10,
    k_ERemotePlayScancodeH = 11,
    k_ERemotePlayScancodeI = 12,
    k_ERemotePlayScancodeJ = 13,
    k_ERemotePlayScancodeK = 14,
    k_ERemotePlayScancodeL = 15,
    k_ERemotePlayScancodeM = 16,
    k_ERemotePlayScancodeN = 17,
    k_ERemotePlayScancodeO = 18,
    k_ERemotePlayScancodeP = 19,
    k_ERemotePlayScancodeQ = 20,
    k_ERemotePlayScancodeR = 21,
    k_ERemotePlayScancodeS = 22,
    k_ERemotePlayScancodeT = 23,
    k_ERemotePlayScancodeU = 24,
    k_ERemotePlayScancodeV = 25,
    k_ERemotePlayScancodeW = 26,
    k_ERemotePlayScancodeX = 27,
    k_ERemotePlayScancodeY = 28,
    k_ERemotePlayScancodeZ = 29,
    k_ERemotePlayScancode1 = 30,
    k_ERemotePlayScancode2 = 31,
    k_ERemotePlayScancode3 = 32,
    k_ERemotePlayScancode4 = 33,
    k_ERemotePlayScancode5 = 34,
    k_ERemotePlayScancode6 = 35,
    k_ERemotePlayScancode7 = 36,
    k_ERemotePlayScancode8 = 37,
    k_ERemotePlayScancode9 = 38,
    k_ERemotePlayScancode0 = 39,
    k_ERemotePlayScancodeReturn = 40,
    k_ERemotePlayScancodeEscape = 41,
    k_ERemotePlayScancodeBackspace = 42,
    k_ERemotePlayScancodeTab = 43,
    k_ERemotePlayScancodeSpace = 44,
    k_ERemotePlayScancodeMinus = 45,
    k_ERemotePlayScancodeEquals = 46,
    k_ERemotePlayScancodeLeftBracket = 47,
    k_ERemotePlayScancodeRightBracket = 48,
    k_ERemotePlayScancodeBackslash = 49,
    k_ERemotePlayScancodeSemicolon = 51,
    k_ERemotePlayScancodeApostrophe = 52,
    k_ERemotePlayScancodeGrave = 53,
    k_ERemotePlayScancodeComma = 54,
    k_ERemotePlayScancodePeriod = 55,
    k_ERemotePlayScancodeSlash = 56,
    k_ERemotePlayScancodeCapsLock = 57,
    k_ERemotePlayScancodeF1 = 58,
    k_ERemotePlayScancodeF2 = 59,
    k_ERemotePlayScancodeF3 = 60,
    k_ERemotePlayScancodeF4 = 61,
    k_ERemotePlayScancodeF5 = 62,
    k_ERemotePlayScancodeF6 = 63,
    k_ERemotePlayScancodeF7 = 64,
    k_ERemotePlayScancodeF8 = 65,
    k_ERemotePlayScancodeF9 = 66,
    k_ERemotePlayScancodeF10 = 67,
    k_ERemotePlayScancodeF11 = 68,
    k_ERemotePlayScancodeF12 = 69,
    k_ERemotePlayScancodeInsert = 73,
    k_ERemotePlayScancodeHome = 74,
    k_ERemotePlayScancodePageUp = 75,
    k_ERemotePlayScancodeDelete = 76,
    k_ERemotePlayScancodeEnd = 77,
    k_ERemotePlayScancodePageDown = 78,
    k_ERemotePlayScancodeRight = 79,
    k_ERemotePlayScancodeLeft = 80,
    k_ERemotePlayScancodeDown = 81,
    k_ERemotePlayScancodeUp = 82,
    k_ERemotePlayScancodeLeftControl = 224,
    k_ERemotePlayScancodeLeftShift = 225,
    k_ERemotePlayScancodeLeftAlt = 226,
    k_ERemotePlayScancodeLeftGUI = 227,
    k_ERemotePlayScancodeRightControl = 228,
    k_ERemotePlayScancodeRightShift = 229,
    k_ERemotePlayScancodeRightALT = 230,
    k_ERemotePlayScancodeRightGUI = 231,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ERemotePlayKeyModifier {
    k_ERemotePlayKeyModifierNone = 0,
    k_ERemotePlayKeyModifierLeftShift = 1,
    k_ERemotePlayKeyModifierRightShift = 2,
    k_ERemotePlayKeyModifierLeftControl = 64,
    k_ERemotePlayKeyModifierRightControl = 128,
    k_ERemotePlayKeyModifierLeftAlt = 256,
    k_ERemotePlayKeyModifierRightAlt = 512,
    k_ERemotePlayKeyModifierLeftGUI = 1024,
    k_ERemotePlayKeyModifierRightGUI = 2048,
    k_ERemotePlayKeyModifierNumLock = 4096,
    k_ERemotePlayKeyModifierCapsLock = 8192,
    k_ERemotePlayKeyModifierMask = 65535,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RemotePlayInputMouseMotion_t {
    pub m_bAbsolute: bool,
    pub m_flNormalizedX: f32,
    pub m_flNormalizedY: f32,
    pub m_nDeltaX: ::std::os::raw::c_int,
    pub m_nDeltaY: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_RemotePlayInputMouseMotion_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemotePlayInputMouseMotion_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemotePlayInputMouseMotion_t>(),
        20usize,
        concat!("Size of: ", stringify!(RemotePlayInputMouseMotion_t))
    );
    assert_eq!(
        ::std::mem::align_of::<RemotePlayInputMouseMotion_t>(),
        4usize,
        concat!("Alignment of ", stringify!(RemotePlayInputMouseMotion_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bAbsolute) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemotePlayInputMouseMotion_t),
            "::",
            stringify!(m_bAbsolute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_flNormalizedX) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RemotePlayInputMouseMotion_t),
            "::",
            stringify!(m_flNormalizedX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_flNormalizedY) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemotePlayInputMouseMotion_t),
            "::",
            stringify!(m_flNormalizedY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nDeltaX) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RemotePlayInputMouseMotion_t),
            "::",
            stringify!(m_nDeltaX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nDeltaY) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RemotePlayInputMouseMotion_t),
            "::",
            stringify!(m_nDeltaY)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RemotePlayInputMouseWheel_t {
    pub m_eDirection: ERemotePlayMouseWheelDirection,
    pub m_flAmount: f32,
}
#[test]
fn bindgen_test_layout_RemotePlayInputMouseWheel_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemotePlayInputMouseWheel_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemotePlayInputMouseWheel_t>(),
        8usize,
        concat!("Size of: ", stringify!(RemotePlayInputMouseWheel_t))
    );
    assert_eq!(
        ::std::mem::align_of::<RemotePlayInputMouseWheel_t>(),
        4usize,
        concat!("Alignment of ", stringify!(RemotePlayInputMouseWheel_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eDirection) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemotePlayInputMouseWheel_t),
            "::",
            stringify!(m_eDirection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_flAmount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RemotePlayInputMouseWheel_t),
            "::",
            stringify!(m_flAmount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RemotePlayInputKey_t {
    pub m_eScancode: ::std::os::raw::c_int,
    pub m_unModifiers: uint32,
    pub m_unKeycode: uint32,
}
#[test]
fn bindgen_test_layout_RemotePlayInputKey_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemotePlayInputKey_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemotePlayInputKey_t>(),
        12usize,
        concat!("Size of: ", stringify!(RemotePlayInputKey_t))
    );
    assert_eq!(
        ::std::mem::align_of::<RemotePlayInputKey_t>(),
        4usize,
        concat!("Alignment of ", stringify!(RemotePlayInputKey_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eScancode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemotePlayInputKey_t),
            "::",
            stringify!(m_eScancode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unModifiers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RemotePlayInputKey_t),
            "::",
            stringify!(m_unModifiers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unKeycode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemotePlayInputKey_t),
            "::",
            stringify!(m_unKeycode)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RemotePlayInput_t {
    pub m_unSessionID: RemotePlaySessionID_t,
    pub m_eType: ERemotePlayInputType,
    pub __bindgen_anon_1: RemotePlayInput_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RemotePlayInput_t__bindgen_ty_1 {
    pub m_MouseMotion: RemotePlayInputMouseMotion_t,
    pub m_eMouseButton: ERemotePlayMouseButton,
    pub m_MouseWheel: RemotePlayInputMouseWheel_t,
    pub m_Key: RemotePlayInputKey_t,
    pub padding: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout_RemotePlayInput_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<RemotePlayInput_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemotePlayInput_t__bindgen_ty_1>(),
        56usize,
        concat!("Size of: ", stringify!(RemotePlayInput_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<RemotePlayInput_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(RemotePlayInput_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_MouseMotion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemotePlayInput_t__bindgen_ty_1),
            "::",
            stringify!(m_MouseMotion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eMouseButton) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemotePlayInput_t__bindgen_ty_1),
            "::",
            stringify!(m_eMouseButton)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_MouseWheel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemotePlayInput_t__bindgen_ty_1),
            "::",
            stringify!(m_MouseWheel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_Key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemotePlayInput_t__bindgen_ty_1),
            "::",
            stringify!(m_Key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemotePlayInput_t__bindgen_ty_1),
            "::",
            stringify!(padding)
        )
    );
}
#[test]
fn bindgen_test_layout_RemotePlayInput_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemotePlayInput_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemotePlayInput_t>(),
        64usize,
        concat!("Size of: ", stringify!(RemotePlayInput_t))
    );
    assert_eq!(
        ::std::mem::align_of::<RemotePlayInput_t>(),
        4usize,
        concat!("Alignment of ", stringify!(RemotePlayInput_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unSessionID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemotePlayInput_t),
            "::",
            stringify!(m_unSessionID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eType) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RemotePlayInput_t),
            "::",
            stringify!(m_eType)
        )
    );
}
#[repr(C)]
pub struct ISteamRemotePlay__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamRemotePlay {
    pub vtable_: *const ISteamRemotePlay__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamRemotePlay() {
    assert_eq!(
        ::std::mem::size_of::<ISteamRemotePlay>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamRemotePlay))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamRemotePlay>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamRemotePlay))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamRemotePlaySessionConnected_t {
    pub m_unSessionID: RemotePlaySessionID_t,
}
pub const SteamRemotePlaySessionConnected_t_k_iCallback:
    SteamRemotePlaySessionConnected_t__bindgen_ty_1 =
    SteamRemotePlaySessionConnected_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamRemotePlaySessionConnected_t__bindgen_ty_1 {
    k_iCallback = 5701,
}
#[test]
fn bindgen_test_layout_SteamRemotePlaySessionConnected_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamRemotePlaySessionConnected_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamRemotePlaySessionConnected_t>(),
        4usize,
        concat!("Size of: ", stringify!(SteamRemotePlaySessionConnected_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamRemotePlaySessionConnected_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SteamRemotePlaySessionConnected_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unSessionID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamRemotePlaySessionConnected_t),
            "::",
            stringify!(m_unSessionID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamRemotePlaySessionDisconnected_t {
    pub m_unSessionID: RemotePlaySessionID_t,
}
pub const SteamRemotePlaySessionDisconnected_t_k_iCallback:
    SteamRemotePlaySessionDisconnected_t__bindgen_ty_1 =
    SteamRemotePlaySessionDisconnected_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamRemotePlaySessionDisconnected_t__bindgen_ty_1 {
    k_iCallback = 5702,
}
#[test]
fn bindgen_test_layout_SteamRemotePlaySessionDisconnected_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamRemotePlaySessionDisconnected_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamRemotePlaySessionDisconnected_t>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(SteamRemotePlaySessionDisconnected_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamRemotePlaySessionDisconnected_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SteamRemotePlaySessionDisconnected_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unSessionID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamRemotePlaySessionDisconnected_t),
            "::",
            stringify!(m_unSessionID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamRemotePlayTogetherGuestInvite_t {
    pub m_szConnectURL: [::std::os::raw::c_char; 1024usize],
}
pub const SteamRemotePlayTogetherGuestInvite_t_k_iCallback:
    SteamRemotePlayTogetherGuestInvite_t__bindgen_ty_1 =
    SteamRemotePlayTogetherGuestInvite_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamRemotePlayTogetherGuestInvite_t__bindgen_ty_1 {
    k_iCallback = 5703,
}
#[test]
fn bindgen_test_layout_SteamRemotePlayTogetherGuestInvite_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamRemotePlayTogetherGuestInvite_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamRemotePlayTogetherGuestInvite_t>(),
        1024usize,
        concat!(
            "Size of: ",
            stringify!(SteamRemotePlayTogetherGuestInvite_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamRemotePlayTogetherGuestInvite_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SteamRemotePlayTogetherGuestInvite_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szConnectURL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamRemotePlayTogetherGuestInvite_t),
            "::",
            stringify!(m_szConnectURL)
        )
    );
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamDatagramRelayAuthTicket {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamDatagramHostedAddress {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamDatagramGameCoordinatorServerLogin {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamNetworkingFakeIPResult_t {
    _unused: [u8; 0],
}
pub type FnSteamNetConnectionStatusChanged = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut SteamNetConnectionStatusChangedCallback_t),
>;
pub type FnSteamNetAuthenticationStatusChanged =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut SteamNetAuthenticationStatus_t)>;
pub type FnSteamRelayNetworkStatusChanged =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut SteamRelayNetworkStatus_t)>;
pub type FnSteamNetworkingMessagesSessionRequest =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut SteamNetworkingMessagesSessionRequest_t)>;
pub type FnSteamNetworkingMessagesSessionFailed =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut SteamNetworkingMessagesSessionFailed_t)>;
pub type FnSteamNetworkingFakeIPResult =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut SteamNetworkingFakeIPResult_t)>;
#[doc = " Handle used to identify a connection to a remote host."]
pub type HSteamNetConnection = uint32;
pub const k_HSteamNetConnection_Invalid: HSteamNetConnection = 0;
#[doc = " Handle used to identify a \"listen socket\".  Unlike traditional\n Berkeley sockets, a listen socket and a connection are two\n different abstractions."]
pub type HSteamListenSocket = uint32;
pub const k_HSteamListenSocket_Invalid: HSteamListenSocket = 0;
#[doc = " Handle used to identify a poll group, used to query many\n connections at once efficiently."]
pub type HSteamNetPollGroup = uint32;
pub const k_HSteamNetPollGroup_Invalid: HSteamNetPollGroup = 0;
#[doc = " Max length of diagnostic error message"]
pub const k_cchMaxSteamNetworkingErrMsg: ::std::os::raw::c_int = 1024;
#[doc = " Used to return English-language diagnostic error messages to caller.\n (For debugging or spewing to a console, etc.  Not intended for UI.)"]
pub type SteamNetworkingErrMsg = [::std::os::raw::c_char; 1024usize];
#[doc = " Identifier used for a network location point of presence.  (E.g. a Valve data center.)\n Typically you won't need to directly manipulate these."]
pub type SteamNetworkingPOPID = uint32;
#[doc = " A local timestamp.  You can subtract two timestamps to get the number of elapsed\n microseconds.  This is guaranteed to increase over time during the lifetime\n of a process, but not globally across runs.  You don't need to worry about\n the value wrapping around.  Note that the underlying clock might not actually have\n microsecond resolution."]
pub type SteamNetworkingMicroseconds = int64;
#[repr(i32)]
#[non_exhaustive]
#[doc = " Describe the status of a particular network resource"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamNetworkingAvailability {
    k_ESteamNetworkingAvailability_CannotTry = -102,
    k_ESteamNetworkingAvailability_Failed = -101,
    k_ESteamNetworkingAvailability_Previously = -100,
    k_ESteamNetworkingAvailability_Retrying = -10,
    k_ESteamNetworkingAvailability_NeverTried = 1,
    k_ESteamNetworkingAvailability_Waiting = 2,
    k_ESteamNetworkingAvailability_Attempting = 3,
    k_ESteamNetworkingAvailability_Current = 100,
    k_ESteamNetworkingAvailability_Unknown = 0,
    k_ESteamNetworkingAvailability__Force32bit = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Different methods of describing the identity of a network host"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamNetworkingIdentityType {
    k_ESteamNetworkingIdentityType_Invalid = 0,
    k_ESteamNetworkingIdentityType_SteamID = 16,
    k_ESteamNetworkingIdentityType_XboxPairwiseID = 17,
    k_ESteamNetworkingIdentityType_SonyPSN = 18,
    k_ESteamNetworkingIdentityType_IPAddress = 1,
    k_ESteamNetworkingIdentityType_GenericString = 2,
    k_ESteamNetworkingIdentityType_GenericBytes = 3,
    k_ESteamNetworkingIdentityType_UnknownType = 4,
    k_ESteamNetworkingIdentityType__Force32bit = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " \"Fake IPs\" are assigned to hosts, to make it easier to interface with\n older code that assumed all hosts will have an IPv4 address"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamNetworkingFakeIPType {
    k_ESteamNetworkingFakeIPType_Invalid = 0,
    k_ESteamNetworkingFakeIPType_NotFake = 1,
    k_ESteamNetworkingFakeIPType_GlobalIPv4 = 2,
    k_ESteamNetworkingFakeIPType_LocalIPv4 = 3,
    k_ESteamNetworkingFakeIPType__Force32Bit = 2147483647,
}
#[doc = " Store an IP and port.  IPv6 is always used; IPv4 is represented using\n \"IPv4-mapped\" addresses: IPv4 aa.bb.cc.dd => IPv6 ::ffff:aabb:ccdd\n (RFC 4291 section 2.5.5.2.)"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct SteamNetworkingIPAddr {
    pub __bindgen_anon_1: SteamNetworkingIPAddr__bindgen_ty_2,
    pub m_port: uint16,
}
pub const SteamNetworkingIPAddr_k_cchMaxString: SteamNetworkingIPAddr__bindgen_ty_1 =
    SteamNetworkingIPAddr__bindgen_ty_1::k_cchMaxString;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamNetworkingIPAddr__bindgen_ty_1 {
    k_cchMaxString = 48,
}
#[doc = " RFC4038, section 4.2"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SteamNetworkingIPAddr_IPv4MappedAddress {
    pub m_8zeros: uint64,
    pub m_0000: uint16,
    pub m_ffff: uint16,
    pub m_ip: [uint8; 4usize],
}
#[test]
fn bindgen_test_layout_SteamNetworkingIPAddr_IPv4MappedAddress() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingIPAddr_IPv4MappedAddress> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingIPAddr_IPv4MappedAddress>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(SteamNetworkingIPAddr_IPv4MappedAddress)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingIPAddr_IPv4MappedAddress>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SteamNetworkingIPAddr_IPv4MappedAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_8zeros) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIPAddr_IPv4MappedAddress),
            "::",
            stringify!(m_8zeros)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_0000) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIPAddr_IPv4MappedAddress),
            "::",
            stringify!(m_0000)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ffff) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIPAddr_IPv4MappedAddress),
            "::",
            stringify!(m_ffff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ip) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIPAddr_IPv4MappedAddress),
            "::",
            stringify!(m_ip)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SteamNetworkingIPAddr__bindgen_ty_2 {
    pub m_ipv6: [uint8; 16usize],
    pub m_ipv4: SteamNetworkingIPAddr_IPv4MappedAddress,
}
#[test]
fn bindgen_test_layout_SteamNetworkingIPAddr__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingIPAddr__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingIPAddr__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(SteamNetworkingIPAddr__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingIPAddr__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SteamNetworkingIPAddr__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ipv6) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIPAddr__bindgen_ty_2),
            "::",
            stringify!(m_ipv6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ipv4) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIPAddr__bindgen_ty_2),
            "::",
            stringify!(m_ipv4)
        )
    );
}
#[test]
fn bindgen_test_layout_SteamNetworkingIPAddr() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingIPAddr> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingIPAddr>(),
        18usize,
        concat!("Size of: ", stringify!(SteamNetworkingIPAddr))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingIPAddr>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamNetworkingIPAddr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_port) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIPAddr),
            "::",
            stringify!(m_port)
        )
    );
}
#[doc = " An abstract way to represent the identity of a network host.  All identities can\n be represented as simple string.  Furthermore, this string representation is actually\n used on the wire in several places, even though it is less efficient, in order to\n facilitate forward compatibility.  (Old client code can handle an identity type that\n it doesn't understand.)"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct SteamNetworkingIdentity {
    #[doc = " Type of identity."]
    pub m_eType: ESteamNetworkingIdentityType,
    pub m_cbSize: ::std::os::raw::c_int,
    pub __bindgen_anon_1: SteamNetworkingIdentity__bindgen_ty_2,
}
pub const SteamNetworkingIdentity_k_cchMaxString: SteamNetworkingIdentity__bindgen_ty_1 =
    SteamNetworkingIdentity__bindgen_ty_1::k_cchMaxString;
pub const SteamNetworkingIdentity_k_cchMaxGenericString: SteamNetworkingIdentity__bindgen_ty_1 =
    SteamNetworkingIdentity__bindgen_ty_1::k_cchMaxGenericString;
pub const SteamNetworkingIdentity_k_cchMaxXboxPairwiseID: SteamNetworkingIdentity__bindgen_ty_1 =
    SteamNetworkingIdentity__bindgen_ty_1::k_cchMaxXboxPairwiseID;
pub const SteamNetworkingIdentity_k_cbMaxGenericBytes: SteamNetworkingIdentity__bindgen_ty_1 =
    SteamNetworkingIdentity__bindgen_ty_1::k_cchMaxGenericString;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamNetworkingIdentity__bindgen_ty_1 {
    k_cchMaxString = 128,
    k_cchMaxGenericString = 32,
    k_cchMaxXboxPairwiseID = 33,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union SteamNetworkingIdentity__bindgen_ty_2 {
    pub m_steamID64: uint64,
    pub m_PSNID: uint64,
    pub m_szGenericString: [::std::os::raw::c_char; 32usize],
    pub m_szXboxPairwiseID: [::std::os::raw::c_char; 33usize],
    pub m_genericBytes: [uint8; 32usize],
    pub m_szUnknownRawString: [::std::os::raw::c_char; 128usize],
    pub m_ip: SteamNetworkingIPAddr,
    pub m_reserved: [uint32; 32usize],
}
#[test]
fn bindgen_test_layout_SteamNetworkingIdentity__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingIdentity__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingIdentity__bindgen_ty_2>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(SteamNetworkingIdentity__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingIdentity__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SteamNetworkingIdentity__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamID64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIdentity__bindgen_ty_2),
            "::",
            stringify!(m_steamID64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_PSNID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIdentity__bindgen_ty_2),
            "::",
            stringify!(m_PSNID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szGenericString) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIdentity__bindgen_ty_2),
            "::",
            stringify!(m_szGenericString)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szXboxPairwiseID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIdentity__bindgen_ty_2),
            "::",
            stringify!(m_szXboxPairwiseID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_genericBytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIdentity__bindgen_ty_2),
            "::",
            stringify!(m_genericBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szUnknownRawString) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIdentity__bindgen_ty_2),
            "::",
            stringify!(m_szUnknownRawString)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ip) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIdentity__bindgen_ty_2),
            "::",
            stringify!(m_ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIdentity__bindgen_ty_2),
            "::",
            stringify!(m_reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_SteamNetworkingIdentity() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingIdentity> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingIdentity>(),
        136usize,
        concat!("Size of: ", stringify!(SteamNetworkingIdentity))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingIdentity>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamNetworkingIdentity))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIdentity),
            "::",
            stringify!(m_eType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cbSize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIdentity),
            "::",
            stringify!(m_cbSize)
        )
    );
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " High level connection status"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamNetworkingConnectionState {
    #[doc = " Dummy value used to indicate an error condition in the API.\n Specified connection doesn't exist or has already been closed."]
    k_ESteamNetworkingConnectionState_None = 0,
    #[doc = " We are trying to establish whether peers can talk to each other,\n whether they WANT to talk to each other, perform basic auth,\n and exchange crypt keys.\n\n - For connections on the \"client\" side (initiated locally):\n   We're in the process of trying to establish a connection.\n   Depending on the connection type, we might not know who they are.\n   Note that it is not possible to tell if we are waiting on the\n   network to complete handshake packets, or for the application layer\n   to accept the connection.\n\n - For connections on the \"server\" side (accepted through listen socket):\n   We have completed some basic handshake and the client has presented\n   some proof of identity.  The connection is ready to be accepted\n   using AcceptConnection().\n\n In either case, any unreliable packets sent now are almost certain\n to be dropped.  Attempts to receive packets are guaranteed to fail.\n You may send messages if the send mode allows for them to be queued.\n but if you close the connection before the connection is actually\n established, any queued messages will be discarded immediately.\n (We will not attempt to flush the queue and confirm delivery to the\n remote host, which ordinarily happens when a connection is closed.)"]
    k_ESteamNetworkingConnectionState_Connecting = 1,
    #[doc = " Some connection types use a back channel or trusted 3rd party\n for earliest communication.  If the server accepts the connection,\n then these connections switch into the rendezvous state.  During this\n state, we still have not yet established an end-to-end route (through\n the relay network), and so if you send any messages unreliable, they\n are going to be discarded."]
    k_ESteamNetworkingConnectionState_FindingRoute = 2,
    #[doc = " We've received communications from our peer (and we know\n who they are) and are all good.  If you close the connection now,\n we will make our best effort to flush out any reliable sent data that\n has not been acknowledged by the peer.  (But note that this happens\n from within the application process, so unlike a TCP connection, you are\n not totally handing it off to the operating system to deal with it.)"]
    k_ESteamNetworkingConnectionState_Connected = 3,
    #[doc = " Connection has been closed by our peer, but not closed locally.\n The connection still exists from an API perspective.  You must close the\n handle to free up resources.  If there are any messages in the inbound queue,\n you may retrieve them.  Otherwise, nothing may be done with the connection\n except to close it.\n\n This stats is similar to CLOSE_WAIT in the TCP state machine."]
    k_ESteamNetworkingConnectionState_ClosedByPeer = 4,
    #[doc = " A disruption in the connection has been detected locally.  (E.g. timeout,\n local internet connection disrupted, etc.)\n\n The connection still exists from an API perspective.  You must close the\n handle to free up resources.\n\n Attempts to send further messages will fail.  Any remaining received messages\n in the queue are available."]
    k_ESteamNetworkingConnectionState_ProblemDetectedLocally = 5,
    #[doc = " We've disconnected on our side, and from an API perspective the connection is closed.\n No more data may be sent or received.  All reliable data has been flushed, or else\n we've given up and discarded it.  We do not yet know for sure that the peer knows\n the connection has been closed, however, so we're just hanging around so that if we do\n get a packet from them, we can send them the appropriate packets so that they can\n know why the connection was closed (and not have to rely on a timeout, which makes\n it appear as if something is wrong)."]
    k_ESteamNetworkingConnectionState_FinWait = -1,
    #[doc = " We've disconnected on our side, and from an API perspective the connection is closed.\n No more data may be sent or received.  From a network perspective, however, on the wire,\n we have not yet given any indication to the peer that the connection is closed.\n We are in the process of flushing out the last bit of reliable data.  Once that is done,\n we will inform the peer that the connection has been closed, and transition to the\n FinWait state.\n\n Note that no indication is given to the remote host that we have closed the connection,\n until the data has been flushed.  If the remote host attempts to send us data, we will\n do whatever is necessary to keep the connection alive until it can be closed properly.\n But in fact the data will be discarded, since there is no way for the application to\n read it back.  Typically this is not a problem, as application protocols that utilize\n the lingering functionality are designed for the remote host to wait for the response\n before sending any more data."]
    k_ESteamNetworkingConnectionState_Linger = -2,
    #[doc = " Connection is completely inactive and ready to be destroyed"]
    k_ESteamNetworkingConnectionState_Dead = -3,
    #[doc = " Connection is completely inactive and ready to be destroyed"]
    k_ESteamNetworkingConnectionState__Force32Bit = 2147483647,
}
impl ESteamNetConnectionEnd {
    pub const k_ESteamNetConnectionEnd_App_Generic: ESteamNetConnectionEnd =
        ESteamNetConnectionEnd::k_ESteamNetConnectionEnd_App_Min;
}
impl ESteamNetConnectionEnd {
    pub const k_ESteamNetConnectionEnd_AppException_Generic: ESteamNetConnectionEnd =
        ESteamNetConnectionEnd::k_ESteamNetConnectionEnd_AppException_Min;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Enumerate various causes of connection termination.  These are designed to work similar\n to HTTP error codes: the numeric range gives you a rough classification as to the source\n of the problem."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamNetConnectionEnd {
    k_ESteamNetConnectionEnd_Invalid = 0,
    k_ESteamNetConnectionEnd_App_Min = 1000,
    k_ESteamNetConnectionEnd_App_Max = 1999,
    k_ESteamNetConnectionEnd_AppException_Min = 2000,
    k_ESteamNetConnectionEnd_AppException_Max = 2999,
    k_ESteamNetConnectionEnd_Local_Min = 3000,
    k_ESteamNetConnectionEnd_Local_OfflineMode = 3001,
    k_ESteamNetConnectionEnd_Local_ManyRelayConnectivity = 3002,
    k_ESteamNetConnectionEnd_Local_HostedServerPrimaryRelay = 3003,
    k_ESteamNetConnectionEnd_Local_NetworkConfig = 3004,
    k_ESteamNetConnectionEnd_Local_Rights = 3005,
    k_ESteamNetConnectionEnd_Local_P2P_ICE_NoPublicAddresses = 3006,
    k_ESteamNetConnectionEnd_Local_Max = 3999,
    k_ESteamNetConnectionEnd_Remote_Min = 4000,
    k_ESteamNetConnectionEnd_Remote_Timeout = 4001,
    k_ESteamNetConnectionEnd_Remote_BadCrypt = 4002,
    k_ESteamNetConnectionEnd_Remote_BadCert = 4003,
    k_ESteamNetConnectionEnd_Remote_BadProtocolVersion = 4006,
    k_ESteamNetConnectionEnd_Remote_P2P_ICE_NoPublicAddresses = 4007,
    k_ESteamNetConnectionEnd_Remote_Max = 4999,
    k_ESteamNetConnectionEnd_Misc_Min = 5000,
    k_ESteamNetConnectionEnd_Misc_Generic = 5001,
    k_ESteamNetConnectionEnd_Misc_InternalError = 5002,
    k_ESteamNetConnectionEnd_Misc_Timeout = 5003,
    k_ESteamNetConnectionEnd_Misc_SteamConnectivity = 5005,
    k_ESteamNetConnectionEnd_Misc_NoRelaySessionsToClient = 5006,
    k_ESteamNetConnectionEnd_Misc_P2P_Rendezvous = 5008,
    k_ESteamNetConnectionEnd_Misc_P2P_NAT_Firewall = 5009,
    k_ESteamNetConnectionEnd_Misc_PeerSentNoConnection = 5010,
    k_ESteamNetConnectionEnd_Misc_Max = 5999,
    k_ESteamNetConnectionEnd__Force32Bit = 2147483647,
}
#[doc = " Max length, in bytes (including null terminator) of the reason string\n when a connection is closed."]
pub const k_cchSteamNetworkingMaxConnectionCloseReason: ::std::os::raw::c_int = 128;
#[doc = " Max length, in bytes (include null terminator) of debug description\n of a connection."]
pub const k_cchSteamNetworkingMaxConnectionDescription: ::std::os::raw::c_int = 128;
#[doc = " Max length of the app's part of the description"]
pub const k_cchSteamNetworkingMaxConnectionAppName: ::std::os::raw::c_int = 32;
pub const k_nSteamNetworkConnectionInfoFlags_Unauthenticated: ::std::os::raw::c_int = 1;
pub const k_nSteamNetworkConnectionInfoFlags_Unencrypted: ::std::os::raw::c_int = 2;
pub const k_nSteamNetworkConnectionInfoFlags_LoopbackBuffers: ::std::os::raw::c_int = 4;
pub const k_nSteamNetworkConnectionInfoFlags_Fast: ::std::os::raw::c_int = 8;
pub const k_nSteamNetworkConnectionInfoFlags_Relayed: ::std::os::raw::c_int = 16;
pub const k_nSteamNetworkConnectionInfoFlags_DualWifi: ::std::os::raw::c_int = 32;
#[doc = " Describe the state of a connection."]
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct SteamNetConnectionInfo_t {
    #[doc = " Who is on the other end?  Depending on the connection type and phase of the connection, we might not know"]
    pub m_identityRemote: SteamNetworkingIdentity,
    #[doc = " Arbitrary user data set by the local application code"]
    pub m_nUserData: int64,
    #[doc = " Handle to listen socket this was connected on, or k_HSteamListenSocket_Invalid if we initiated the connection"]
    pub m_hListenSocket: HSteamListenSocket,
    #[doc = " Remote address.  Might be all 0's if we don't know it, or if this is N/A.\n (E.g. Basically everything except direct UDP connection.)"]
    pub m_addrRemote: SteamNetworkingIPAddr,
    pub m__pad1: uint16,
    #[doc = " What data center is the remote host in?  (0 if we don't know.)"]
    pub m_idPOPRemote: SteamNetworkingPOPID,
    #[doc = " What relay are we using to communicate with the remote host?\n (0 if not applicable.)"]
    pub m_idPOPRelay: SteamNetworkingPOPID,
    #[doc = " High level state of the connection"]
    pub m_eState: ESteamNetworkingConnectionState,
    #[doc = " Basic cause of the connection termination or problem.\n See ESteamNetConnectionEnd for the values used"]
    pub m_eEndReason: ::std::os::raw::c_int,
    #[doc = " Human-readable, but non-localized explanation for connection\n termination or problem.  This is intended for debugging /\n diagnostic purposes only, not to display to users.  It might\n have some details specific to the issue."]
    pub m_szEndDebug: [::std::os::raw::c_char; 128usize],
    #[doc = " Debug description.  This includes the internal connection ID,\n connection type (and peer information), and any name\n given to the connection by the app.  This string is used in various\n internal logging messages.\n\n Note that the connection ID *usually* matches the HSteamNetConnection\n handle, but in certain cases with symmetric connections it might not."]
    pub m_szConnectionDescription: [::std::os::raw::c_char; 128usize],
    #[doc = " Misc flags.  Bitmask of k_nSteamNetworkConnectionInfoFlags_Xxxx"]
    pub m_nFlags: ::std::os::raw::c_int,
    #[doc = " Internal stuff, room to change API easily"]
    pub reserved: [uint32; 63usize],
}
#[test]
fn bindgen_test_layout_SteamNetConnectionInfo_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetConnectionInfo_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetConnectionInfo_t>(),
        696usize,
        concat!("Size of: ", stringify!(SteamNetConnectionInfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetConnectionInfo_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamNetConnectionInfo_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_identityRemote) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(m_identityRemote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nUserData) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(m_nUserData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hListenSocket) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(m_hListenSocket)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_addrRemote) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(m_addrRemote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m__pad1) as usize - ptr as usize },
        166usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(m__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_idPOPRemote) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(m_idPOPRemote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_idPOPRelay) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(m_idPOPRelay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eState) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(m_eState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eEndReason) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(m_eEndReason)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szEndDebug) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(m_szEndDebug)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szConnectionDescription) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(m_szConnectionDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nFlags) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(m_nFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        444usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Quick connection state, pared down to something you could call\n more frequently without it being too big of a perf hit."]
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct SteamNetConnectionRealTimeStatus_t {
    #[doc = " High level state of the connection"]
    pub m_eState: ESteamNetworkingConnectionState,
    #[doc = " Current ping (ms)"]
    pub m_nPing: ::std::os::raw::c_int,
    #[doc = " Connection quality measured locally, 0...1.  (Percentage of packets delivered\n end-to-end in order)."]
    pub m_flConnectionQualityLocal: f32,
    #[doc = " Packet delivery success rate as observed from remote host"]
    pub m_flConnectionQualityRemote: f32,
    #[doc = " Current data rates from recent history."]
    pub m_flOutPacketsPerSec: f32,
    pub m_flOutBytesPerSec: f32,
    pub m_flInPacketsPerSec: f32,
    pub m_flInBytesPerSec: f32,
    #[doc = " Estimate rate that we believe that we can send data to our peer.\n Note that this could be significantly higher than m_flOutBytesPerSec,\n meaning the capacity of the channel is higher than you are sending data.\n (That's OK!)"]
    pub m_nSendRateBytesPerSecond: ::std::os::raw::c_int,
    #[doc = " Number of bytes pending to be sent.  This is data that you have recently\n requested to be sent but has not yet actually been put on the wire.  The\n reliable number ALSO includes data that was previously placed on the wire,\n but has now been scheduled for re-transmission.  Thus, it's possible to\n observe m_cbPendingReliable increasing between two checks, even if no\n calls were made to send reliable data between the checks.  Data that is\n awaiting the Nagle delay will appear in these numbers."]
    pub m_cbPendingUnreliable: ::std::os::raw::c_int,
    pub m_cbPendingReliable: ::std::os::raw::c_int,
    #[doc = " Number of bytes of reliable data that has been placed the wire, but\n for which we have not yet received an acknowledgment, and thus we may\n have to re-transmit."]
    pub m_cbSentUnackedReliable: ::std::os::raw::c_int,
    #[doc = " If you queued a message right now, approximately how long would that message\n wait in the queue before we actually started putting its data on the wire in\n a packet?\n\n In general, data that is sent by the application is limited by the bandwidth\n of the channel.  If you send data faster than this, it must be queued and\n put on the wire at a metered rate.  Even sending a small amount of data (e.g.\n a few MTU, say ~3k) will require some of the data to be delayed a bit.\n\n Ignoring multiple lanes, the estimated delay will be approximately equal to\n\n\t\t( m_cbPendingUnreliable+m_cbPendingReliable ) / m_nSendRateBytesPerSecond\n\n plus or minus one MTU.  It depends on how much time has elapsed since the last\n packet was put on the wire.  For example, the queue might have *just* been emptied,\n and the last packet placed on the wire, and we are exactly up against the send\n rate limit.  In that case we might need to wait for one packet's worth of time to\n elapse before we can send again.  On the other extreme, the queue might have data\n in it waiting for Nagle.  (This will always be less than one packet, because as\n soon as we have a complete packet we would send it.)  In that case, we might be\n ready to send data now, and this value will be 0.\n\n This value is only valid if multiple lanes are not used.  If multiple lanes are\n in use, then the queue time will be different for each lane, and you must use\n the value in SteamNetConnectionRealTimeLaneStatus_t.\n\n Nagle delay is ignored for the purposes of this calculation."]
    pub m_usecQueueTime: SteamNetworkingMicroseconds,
    pub reserved: [uint32; 16usize],
}
#[test]
fn bindgen_test_layout_SteamNetConnectionRealTimeStatus_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetConnectionRealTimeStatus_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetConnectionRealTimeStatus_t>(),
        120usize,
        concat!("Size of: ", stringify!(SteamNetConnectionRealTimeStatus_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetConnectionRealTimeStatus_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SteamNetConnectionRealTimeStatus_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_eState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPing) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_nPing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_flConnectionQualityLocal) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_flConnectionQualityLocal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_flConnectionQualityRemote) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_flConnectionQualityRemote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_flOutPacketsPerSec) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_flOutPacketsPerSec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_flOutBytesPerSec) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_flOutBytesPerSec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_flInPacketsPerSec) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_flInPacketsPerSec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_flInBytesPerSec) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_flInBytesPerSec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nSendRateBytesPerSecond) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_nSendRateBytesPerSecond)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cbPendingUnreliable) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_cbPendingUnreliable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cbPendingReliable) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_cbPendingReliable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cbSentUnackedReliable) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_cbSentUnackedReliable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_usecQueueTime) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_usecQueueTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Quick status of a particular lane"]
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct SteamNetConnectionRealTimeLaneStatus_t {
    pub m_cbPendingUnreliable: ::std::os::raw::c_int,
    pub m_cbPendingReliable: ::std::os::raw::c_int,
    pub m_cbSentUnackedReliable: ::std::os::raw::c_int,
    pub _reservePad1: ::std::os::raw::c_int,
    #[doc = " Lane-specific queue time.  This value takes into consideration lane priorities\n and weights, and how much data is queued in each lane, and attempts to predict\n how any data currently queued will be sent out."]
    pub m_usecQueueTime: SteamNetworkingMicroseconds,
    pub reserved: [uint32; 10usize],
}
#[test]
fn bindgen_test_layout_SteamNetConnectionRealTimeLaneStatus_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetConnectionRealTimeLaneStatus_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetConnectionRealTimeLaneStatus_t>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(SteamNetConnectionRealTimeLaneStatus_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetConnectionRealTimeLaneStatus_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SteamNetConnectionRealTimeLaneStatus_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cbPendingUnreliable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeLaneStatus_t),
            "::",
            stringify!(m_cbPendingUnreliable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cbPendingReliable) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeLaneStatus_t),
            "::",
            stringify!(m_cbPendingReliable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cbSentUnackedReliable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeLaneStatus_t),
            "::",
            stringify!(m_cbSentUnackedReliable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._reservePad1) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeLaneStatus_t),
            "::",
            stringify!(_reservePad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_usecQueueTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeLaneStatus_t),
            "::",
            stringify!(m_usecQueueTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeLaneStatus_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Max size of a single message that we can SEND.\n Note: We might be wiling to receive larger messages,\n and our peer might, too."]
pub const k_cbMaxSteamNetworkingSocketsMessageSizeSend: ::std::os::raw::c_int = 524288;
#[doc = " A message that has been received."]
#[repr(C)]
pub struct SteamNetworkingMessage_t {
    #[doc = " Message payload"]
    pub m_pData: *mut ::std::os::raw::c_void,
    #[doc = " Size of the payload."]
    pub m_cbSize: ::std::os::raw::c_int,
    #[doc = " For messages received on connections: what connection did this come from?\n For outgoing messages: what connection to send it to?\n Not used when using the ISteamNetworkingMessages interface"]
    pub m_conn: HSteamNetConnection,
    #[doc = " For inbound messages: Who sent this to us?\n For outbound messages on connections: not used.\n For outbound messages on the ad-hoc ISteamNetworkingMessages interface: who should we send this to?"]
    pub m_identityPeer: SteamNetworkingIdentity,
    #[doc = " For messages received on connections, this is the user data\n associated with the connection.\n\n This is *usually* the same as calling GetConnection() and then\n fetching the user data associated with that connection, but for\n the following subtle differences:\n\n - This user data will match the connection's user data at the time\n   is captured at the time the message is returned by the API.\n   If you subsequently change the userdata on the connection,\n   this won't be updated.\n - This is an inline call, so it's *much* faster.\n - You might have closed the connection, so fetching the user data\n   would not be possible.\n\n Not used when sending messages."]
    pub m_nConnUserData: int64,
    #[doc = " Local timestamp when the message was received\n Not used for outbound messages."]
    pub m_usecTimeReceived: SteamNetworkingMicroseconds,
    #[doc = " Message number assigned by the sender.  This is not used for outbound\n messages.  Note that if multiple lanes are used, each lane has its own\n message numbers, which are assigned sequentially, so messages from\n different lanes will share the same numbers."]
    pub m_nMessageNumber: int64,
    #[doc = " Function used to free up m_pData.  This mechanism exists so that\n apps can create messages with buffers allocated from their own\n heap, and pass them into the library.  This function will\n usually be something like:\n\n free( pMsg->m_pData );"]
    pub m_pfnFreeData:
        ::std::option::Option<unsafe extern "C" fn(pMsg: *mut SteamNetworkingMessage_t)>,
    #[doc = " Function to used to decrement the internal reference count and, if\n it's zero, release the message.  You should not set this function pointer,\n or need to access this directly!  Use the Release() function instead!"]
    pub m_pfnRelease:
        ::std::option::Option<unsafe extern "C" fn(pMsg: *mut SteamNetworkingMessage_t)>,
    #[doc = " When using ISteamNetworkingMessages, the channel number the message was received on\n (Not used for messages sent or received on \"connections\")"]
    pub m_nChannel: ::std::os::raw::c_int,
    #[doc = " Bitmask of k_nSteamNetworkingSend_xxx flags.\n For received messages, only the k_nSteamNetworkingSend_Reliable bit is valid.\n For outbound messages, all bits are relevant"]
    pub m_nFlags: ::std::os::raw::c_int,
    #[doc = " Arbitrary user data that you can use when sending messages using\n ISteamNetworkingUtils::AllocateMessage and ISteamNetworkingSockets::SendMessage.\n (The callback you set in m_pfnFreeData might use this field.)\n\n Not used for received messages."]
    pub m_nUserData: int64,
    #[doc = " For outbound messages, which lane to use?  See ISteamNetworkingSockets::ConfigureConnectionLanes.\n For inbound messages, what lane was the message received on?"]
    pub m_idxLane: uint16,
    pub _pad1__: uint16,
}
#[test]
fn bindgen_test_layout_SteamNetworkingMessage_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingMessage_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingMessage_t>(),
        216usize,
        concat!("Size of: ", stringify!(SteamNetworkingMessage_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingMessage_t>(),
        8usize,
        concat!("Alignment of ", stringify!(SteamNetworkingMessage_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_pData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cbSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_cbSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_conn) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_conn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_identityPeer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_identityPeer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nConnUserData) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_nConnUserData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_usecTimeReceived) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_usecTimeReceived)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nMessageNumber) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_nMessageNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pfnFreeData) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_pfnFreeData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pfnRelease) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_pfnRelease)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nChannel) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_nChannel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nFlags) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_nFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nUserData) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_nUserData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_idxLane) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_idxLane)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._pad1__) as usize - ptr as usize },
        210usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(_pad1__)
        )
    );
}
pub const k_nSteamNetworkingSend_Unreliable: ::std::os::raw::c_int = 0;
pub const k_nSteamNetworkingSend_NoNagle: ::std::os::raw::c_int = 1;
pub const k_nSteamNetworkingSend_UnreliableNoNagle: ::std::os::raw::c_int = 1;
pub const k_nSteamNetworkingSend_NoDelay: ::std::os::raw::c_int = 4;
pub const k_nSteamNetworkingSend_UnreliableNoDelay: ::std::os::raw::c_int = 5;
pub const k_nSteamNetworkingSend_Reliable: ::std::os::raw::c_int = 8;
pub const k_nSteamNetworkingSend_ReliableNoNagle: ::std::os::raw::c_int = 9;
pub const k_nSteamNetworkingSend_UseCurrentThread: ::std::os::raw::c_int = 16;
pub const k_nSteamNetworkingSend_AutoRestartBrokenSession: ::std::os::raw::c_int = 32;
#[doc = " Object that describes a \"location\" on the Internet with sufficient\n detail that we can reasonably estimate an upper bound on the ping between\n the two hosts, even if a direct route between the hosts is not possible,\n and the connection must be routed through the Steam Datagram Relay network.\n This does not contain any information that identifies the host.  Indeed,\n if two hosts are in the same building or otherwise have nearly identical\n networking characteristics, then it's valid to use the same location\n object for both of them.\n\n NOTE: This object should only be used in the same process!  Do not serialize it,\n send it over the wire, or persist it in a file or database!  If you need\n to do that, convert it to a string representation using the methods in\n ISteamNetworkingUtils()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamNetworkPingLocation_t {
    pub m_data: [uint8; 512usize],
}
#[test]
fn bindgen_test_layout_SteamNetworkPingLocation_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkPingLocation_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkPingLocation_t>(),
        512usize,
        concat!("Size of: ", stringify!(SteamNetworkPingLocation_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkPingLocation_t>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamNetworkPingLocation_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkPingLocation_t),
            "::",
            stringify!(m_data)
        )
    );
}
#[doc = " Max possible length of a ping location, in string format.  This is\n an extremely conservative worst case value which leaves room for future\n syntax enhancements.  Most strings in practice are a lot shorter.\n If you are storing many of these, you will very likely benefit from\n using dynamic memory."]
pub const k_cchMaxSteamNetworkingPingLocationString: ::std::os::raw::c_int = 1024;
#[doc = " Special values that are returned by some functions that return a ping."]
pub const k_nSteamNetworkingPing_Failed: ::std::os::raw::c_int = -1;
pub const k_nSteamNetworkingPing_Unknown: ::std::os::raw::c_int = -2;
#[repr(u32)]
#[non_exhaustive]
#[doc = " Configuration values can be applied to different types of objects."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamNetworkingConfigScope {
    #[doc = " Get/set global option, or defaults.  Even options that apply to more specific scopes\n have global scope, and you may be able to just change the global defaults.  If you\n need different settings per connection (for example), then you will need to set those\n options at the more specific scope."]
    k_ESteamNetworkingConfig_Global = 1,
    #[doc = " Some options are specific to a particular interface.  Note that all connection\n and listen socket settings can also be set at the interface level, and they will\n apply to objects created through those interfaces."]
    k_ESteamNetworkingConfig_SocketsInterface = 2,
    #[doc = " Options for a listen socket.  Listen socket options can be set at the interface layer,\n if  you have multiple listen sockets and they all use the same options.\n You can also set connection options on a listen socket, and they set the defaults\n for all connections accepted through this listen socket.  (They will be used if you don't\n set a connection option.)"]
    k_ESteamNetworkingConfig_ListenSocket = 3,
    #[doc = " Options for a specific connection."]
    k_ESteamNetworkingConfig_Connection = 4,
    #[doc = " Options for a specific connection."]
    k_ESteamNetworkingConfigScope__Force32Bit = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamNetworkingConfigDataType {
    k_ESteamNetworkingConfig_Int32 = 1,
    k_ESteamNetworkingConfig_Int64 = 2,
    k_ESteamNetworkingConfig_Float = 3,
    k_ESteamNetworkingConfig_String = 4,
    k_ESteamNetworkingConfig_Ptr = 5,
    k_ESteamNetworkingConfigDataType__Force32Bit = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Configuration options"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamNetworkingConfigValue {
    k_ESteamNetworkingConfig_Invalid = 0,
    #[doc = " [connection int32] Timeout value (in ms) to use when first connecting"]
    k_ESteamNetworkingConfig_TimeoutInitial = 24,
    #[doc = " [connection int32] Timeout value (in ms) to use after connection is established"]
    k_ESteamNetworkingConfig_TimeoutConnected = 25,
    #[doc = " [connection int32] Upper limit of buffered pending bytes to be sent,\n if this is reached SendMessage will return k_EResultLimitExceeded\n Default is 512k (524288 bytes)"]
    k_ESteamNetworkingConfig_SendBufferSize = 9,
    #[doc = " [connection int32] Upper limit on total size (in bytes) of received messages\n that will be buffered waiting to be processed by the application.  If this limit\n is exceeded, packets will be dropped.  This is to protect us from a malicious\n peer flooding us with messages faster than we can process them.\n\n This must be bigger than k_ESteamNetworkingConfig_RecvMaxMessageSize"]
    k_ESteamNetworkingConfig_RecvBufferSize = 47,
    #[doc = " [connection int32] Upper limit on the number of received messages that will\n that will be buffered waiting to be processed by the application.  If this limit\n is exceeded, packets will be dropped.  This is to protect us from a malicious\n peer flooding us with messages faster than we can pull them off the wire."]
    k_ESteamNetworkingConfig_RecvBufferMessages = 48,
    #[doc = " [connection int32] Maximum message size that we are willing to receive.\n if a client attempts to send us a message larger than this, the connection\n will be immediately closed.\n\n Default is 512k (524288 bytes).  Note that the peer needs to be able to\n send a message this big.  (See k_cbMaxSteamNetworkingSocketsMessageSizeSend.)"]
    k_ESteamNetworkingConfig_RecvMaxMessageSize = 49,
    #[doc = " [connection int32] Max number of message segments that can be received\n in a single UDP packet.  While decoding a packet, if the number of segments\n exceeds this, we will abort further packet processing.\n\n The default is effectively unlimited.  If you know that you very rarely\n send small packets, you can protect yourself from malicious senders by\n lowering this number.\n\n In particular, if you are NOT using the reliability layer and are only using\n SteamNetworkingSockets for datagram transport, setting this to a very low\n number may be beneficial.  (We recommend a value of 2.)  Make sure your sender\n disables Nagle!"]
    k_ESteamNetworkingConfig_RecvMaxSegmentsPerPacket = 50,
    #[doc = " [connection int64] Get/set userdata as a configuration option.\n The default value is -1.   You may want to set the user data as\n a config value, instead of using ISteamNetworkingSockets::SetConnectionUserData\n in two specific instances:\n\n - You wish to set the userdata atomically when creating\n   an outbound connection, so that the userdata is filled in properly\n   for any callbacks that happen.  However, note that this trick\n   only works for connections initiated locally!  For incoming\n   connections, multiple state transitions may happen and\n   callbacks be queued, before you are able to service the first\n   callback!  Be careful!\n\n - You can set the default userdata for all newly created connections\n   by setting this value at a higher level (e.g. on the listen\n   socket or at the global level.)  Then this default\n   value will be inherited when the connection is created.\n   This is useful in case -1 is a valid userdata value, and you\n   wish to use something else as the default value so you can\n   tell if it has been set or not.\n\n   HOWEVER: once a connection is created, the effective value is\n   then bound to the connection.  Unlike other connection options,\n   if you change it again at a higher level, the new value will not\n   be inherited by connections.\n\n Using the userdata field in callback structs is not advised because\n of tricky race conditions.  Instead, you might try one of these methods:\n\n - Use a separate map with the HSteamNetConnection as the key.\n - Fetch the userdata from the connection in your callback\n   using ISteamNetworkingSockets::GetConnectionUserData, to"]
    k_ESteamNetworkingConfig_ConnectionUserData = 40,
    #[doc = " [connection int32] Minimum/maximum send rate clamp, in bytes/sec.\n At the time of this writing these two options should always be set to\n the same value, to manually configure a specific send rate.  The default\n value is 256K.  Eventually we hope to have the library estimate the bandwidth\n of the channel and set the send rate to that estimated bandwidth, and these\n values will only set limits on that send rate."]
    k_ESteamNetworkingConfig_SendRateMin = 10,
    #[doc = " [connection int32] Minimum/maximum send rate clamp, in bytes/sec.\n At the time of this writing these two options should always be set to\n the same value, to manually configure a specific send rate.  The default\n value is 256K.  Eventually we hope to have the library estimate the bandwidth\n of the channel and set the send rate to that estimated bandwidth, and these\n values will only set limits on that send rate."]
    k_ESteamNetworkingConfig_SendRateMax = 11,
    #[doc = " [connection int32] Nagle time, in microseconds.  When SendMessage is called, if\n the outgoing message is less than the size of the MTU, it will be\n queued for a delay equal to the Nagle timer value.  This is to ensure\n that if the application sends several small messages rapidly, they are\n coalesced into a single packet.\n See historical RFC 896.  Value is in microseconds.\n Default is 5000us (5ms)."]
    k_ESteamNetworkingConfig_NagleTime = 12,
    #[doc = " [connection int32] Don't automatically fail IP connections that don't have\n strong auth.  On clients, this means we will attempt the connection even if\n we don't know our identity or can't get a cert.  On the server, it means that\n we won't automatically reject a connection due to a failure to authenticate.\n (You can examine the incoming connection and decide whether to accept it.)\n\n 0: Don't attempt or accept unauthorized connections\n 1: Attempt authorization when connecting, and allow unauthorized peers, but emit warnings\n 2: don't attempt authentication, or complain if peer is unauthenticated\n\n This is a dev configuration value, and you should not let users modify it in\n production."]
    k_ESteamNetworkingConfig_IP_AllowWithoutAuth = 23,
    #[doc = " [connection int32] The same as IP_AllowWithoutAuth, but will only apply\n for connections to/from localhost addresses.  Whichever value is larger\n (more permissive) will be used."]
    k_ESteamNetworkingConfig_IPLocalHost_AllowWithoutAuth = 52,
    #[doc = " [connection int32] Do not send UDP packets with a payload of\n larger than N bytes.  If you set this, k_ESteamNetworkingConfig_MTU_DataSize\n is automatically adjusted"]
    k_ESteamNetworkingConfig_MTU_PacketSize = 32,
    #[doc = " [connection int32] (read only) Maximum message size you can send that\n will not fragment, based on k_ESteamNetworkingConfig_MTU_PacketSize"]
    k_ESteamNetworkingConfig_MTU_DataSize = 33,
    #[doc = " [connection int32] Allow unencrypted (and unauthenticated) communication.\n 0: Not allowed (the default)\n 1: Allowed, but prefer encrypted\n 2: Allowed, and preferred\n 3: Required.  (Fail the connection if the peer requires encryption.)\n\n This is a dev configuration value, since its purpose is to disable encryption.\n You should not let users modify it in production.  (But note that it requires\n the peer to also modify their value in order for encryption to be disabled.)"]
    k_ESteamNetworkingConfig_Unencrypted = 34,
    #[doc = " [connection int32] Set this to 1 on outbound connections and listen sockets,\n to enable \"symmetric connect mode\", which is useful in the following\n common peer-to-peer use case:\n\n - The two peers are \"equal\" to each other.  (Neither is clearly the \"client\"\n   or \"server\".)\n - Either peer may initiate the connection, and indeed they may do this\n   at the same time\n - The peers only desire a single connection to each other, and if both\n   peers initiate connections simultaneously, a protocol is needed for them\n   to resolve the conflict, so that we end up with a single connection.\n\n This use case is both common, and involves subtle race conditions and tricky\n pitfalls, which is why the API has support for dealing with it.\n\n If an incoming connection arrives on a listen socket or via custom signaling,\n and the application has not attempted to make a matching outbound connection\n in symmetric mode, then the incoming connection can be accepted as usual.\n A \"matching\" connection means that the relevant endpoint information matches.\n (At the time this comment is being written, this is only supported for P2P\n connections, which means that the peer identities must match, and the virtual\n port must match.  At a later time, symmetric mode may be supported for other\n connection types.)\n\n If connections are initiated by both peers simultaneously, race conditions\n can arise, but fortunately, most of them are handled internally and do not\n require any special awareness from the application.  However, there\n is one important case that application code must be aware of:\n If application code attempts an outbound connection using a ConnectXxx\n function in symmetric mode, and a matching incoming connection is already\n waiting on a listen socket, then instead of forming a new connection,\n the ConnectXxx call will accept the existing incoming connection, and return\n a connection handle to this accepted connection.\n IMPORTANT: in this case, a SteamNetConnectionStatusChangedCallback_t\n has probably *already* been posted to the queue for the incoming connection!\n (Once callbacks are posted to the queue, they are not modified.)  It doesn't\n matter if the callback has not been consumed by the app.  Thus, application\n code that makes use of symmetric connections must be aware that, when processing a\n SteamNetConnectionStatusChangedCallback_t for an incoming connection, the\n m_hConn may refer to a new connection that the app has has not\n seen before (the usual case), but it may also refer to a connection that\n has already been accepted implicitly through a call to Connect()!  In this\n case, AcceptConnection() will return k_EResultDuplicateRequest.\n\n Only one symmetric connection to a given peer (on a given virtual port)\n may exist at any given time.  If client code attempts to create a connection,\n and a (live) connection already exists on the local host, then either the\n existing connection will be accepted as described above, or the attempt\n to create a new connection will fail.  Furthermore, linger mode functionality\n is not supported on symmetric connections.\n\n A more complicated race condition can arise if both peers initiate a connection\n at roughly the same time.  In this situation, each peer will receive an incoming\n connection from the other peer, when the application code has already initiated\n an outgoing connection to that peer.  The peers must resolve this conflict and\n decide who is going to act as the \"server\" and who will act as the \"client\".\n Typically the application does not need to be aware of this case as it is handled\n internally.  On both sides, the will observe their outbound connection being\n \"accepted\", although one of them one have been converted internally to act\n as the \"server\".\n\n In general, symmetric mode should be all-or-nothing: do not mix symmetric\n connections with a non-symmetric connection that it might possible \"match\"\n with.  If you use symmetric mode on any connections, then both peers should\n use it on all connections, and the corresponding listen socket, if any.  The\n behaviour when symmetric and ordinary connections are mixed is not defined by\n this API, and you should not rely on it.  (This advice only applies when connections\n might possibly \"match\".  For example, it's OK to use all symmetric mode\n connections on one virtual port, and all ordinary, non-symmetric connections\n on a different virtual port, as there is no potential for ambiguity.)\n\n When using the feature, you should set it in the following situations on\n applicable objects:\n\n - When creating an outbound connection using ConnectXxx function\n - When creating a listen socket.  (Note that this will automatically cause\n   any accepted connections to inherit the flag.)\n - When using custom signaling, before accepting an incoming connection.\n\n Setting the flag on listen socket and accepted connections will enable the\n API to automatically deal with duplicate incoming connections, even if the\n local host has not made any outbound requests.  (In general, such duplicate\n requests from a peer are ignored internally and will not be visible to the\n application code.  The previous connection must be closed or resolved first.)"]
    k_ESteamNetworkingConfig_SymmetricConnect = 37,
    #[doc = " [connection int32] For connection types that use \"virtual ports\", this can be used\n to assign a local virtual port.  For incoming connections, this will always be the\n virtual port of the listen socket (or the port requested by the remote host if custom\n signaling is used and the connection is accepted), and cannot be changed.  For\n connections initiated locally, the local virtual port will default to the same as the\n requested remote virtual port, if you do not specify a different option when creating\n the connection.  The local port is only relevant for symmetric connections, when\n determining if two connections \"match.\"  In this case, if you need the local and remote\n port to differ, you can set this value.\n\n You can also read back this value on listen sockets.\n\n This value should not be read or written in any other context."]
    k_ESteamNetworkingConfig_LocalVirtualPort = 38,
    #[doc = " [connection int32] Enable Dual wifi band support for this connection\n 0 = no, 1 = yes, 2 = simulate it for debugging, even if dual wifi not available"]
    k_ESteamNetworkingConfig_DualWifi_Enable = 39,
    #[doc = " [connection int32] True to enable diagnostics reporting through\n generic platform UI.  (Only available on Steam.)"]
    k_ESteamNetworkingConfig_EnableDiagnosticsUI = 46,
    #[doc = " [connection int32] Send of time-since-previous-packet values in each UDP packet.\n This add a small amount of packet overhead but allows for detailed jitter measurements\n to be made by the receiver.\n\n -  0: disables the sending\n -  1: enables sending\n - -1: (the default) Use the default for the connection type.  For plain UDP connections,\n       this is disabled, and for relayed connections, it is enabled.  Note that relays\n       always send the value."]
    k_ESteamNetworkingConfig_SendTimeSincePreviousPacket = 59,
    #[doc = " [global float, 0--100] Randomly discard N pct of packets instead of sending/recv\n This is a global option only, since it is applied at a low level\n where we don't have much context"]
    k_ESteamNetworkingConfig_FakePacketLoss_Send = 2,
    #[doc = " [global float, 0--100] Randomly discard N pct of packets instead of sending/recv\n This is a global option only, since it is applied at a low level\n where we don't have much context"]
    k_ESteamNetworkingConfig_FakePacketLoss_Recv = 3,
    #[doc = " [global int32].  Delay all outbound/inbound packets by N ms"]
    k_ESteamNetworkingConfig_FakePacketLag_Send = 4,
    #[doc = " [global int32].  Delay all outbound/inbound packets by N ms"]
    k_ESteamNetworkingConfig_FakePacketLag_Recv = 5,
    #[doc = " Simulated jitter/clumping.\n\n For each packet, a jitter value is determined (which may\n be zero).  This amount is added as extra delay to the\n packet.  When a subsequent packet is queued, it receives its\n own random jitter amount from the current time.  if this would\n result in the packets being delivered out of order, the later\n packet queue time is adjusted to happen after the first packet.\n Thus simulating jitter by itself will not reorder packets, but it\n can \"clump\" them.\n\n\t- Avg: A random jitter time is generated using an exponential\n   distribution using this value as the mean (ms).  The default\n   is zero, which disables random jitter.\n - Max: Limit the random jitter time to this value (ms).\n\t- Pct: odds (0-100) that a random jitter value for the packet\n   will be generated.  Otherwise, a jitter value of zero\n   is used, and the packet will only be delayed by the jitter\n   system if necessary to retain order, due to the jitter of a\n   previous packet.\n\n All values are [global float]\n\n Fake jitter is simulated after fake lag, but before reordering."]
    k_ESteamNetworkingConfig_FakePacketJitter_Send_Avg = 53,
    #[doc = " Simulated jitter/clumping.\n\n For each packet, a jitter value is determined (which may\n be zero).  This amount is added as extra delay to the\n packet.  When a subsequent packet is queued, it receives its\n own random jitter amount from the current time.  if this would\n result in the packets being delivered out of order, the later\n packet queue time is adjusted to happen after the first packet.\n Thus simulating jitter by itself will not reorder packets, but it\n can \"clump\" them.\n\n\t- Avg: A random jitter time is generated using an exponential\n   distribution using this value as the mean (ms).  The default\n   is zero, which disables random jitter.\n - Max: Limit the random jitter time to this value (ms).\n\t- Pct: odds (0-100) that a random jitter value for the packet\n   will be generated.  Otherwise, a jitter value of zero\n   is used, and the packet will only be delayed by the jitter\n   system if necessary to retain order, due to the jitter of a\n   previous packet.\n\n All values are [global float]\n\n Fake jitter is simulated after fake lag, but before reordering."]
    k_ESteamNetworkingConfig_FakePacketJitter_Send_Max = 54,
    #[doc = " Simulated jitter/clumping.\n\n For each packet, a jitter value is determined (which may\n be zero).  This amount is added as extra delay to the\n packet.  When a subsequent packet is queued, it receives its\n own random jitter amount from the current time.  if this would\n result in the packets being delivered out of order, the later\n packet queue time is adjusted to happen after the first packet.\n Thus simulating jitter by itself will not reorder packets, but it\n can \"clump\" them.\n\n\t- Avg: A random jitter time is generated using an exponential\n   distribution using this value as the mean (ms).  The default\n   is zero, which disables random jitter.\n - Max: Limit the random jitter time to this value (ms).\n\t- Pct: odds (0-100) that a random jitter value for the packet\n   will be generated.  Otherwise, a jitter value of zero\n   is used, and the packet will only be delayed by the jitter\n   system if necessary to retain order, due to the jitter of a\n   previous packet.\n\n All values are [global float]\n\n Fake jitter is simulated after fake lag, but before reordering."]
    k_ESteamNetworkingConfig_FakePacketJitter_Send_Pct = 55,
    #[doc = " Simulated jitter/clumping.\n\n For each packet, a jitter value is determined (which may\n be zero).  This amount is added as extra delay to the\n packet.  When a subsequent packet is queued, it receives its\n own random jitter amount from the current time.  if this would\n result in the packets being delivered out of order, the later\n packet queue time is adjusted to happen after the first packet.\n Thus simulating jitter by itself will not reorder packets, but it\n can \"clump\" them.\n\n\t- Avg: A random jitter time is generated using an exponential\n   distribution using this value as the mean (ms).  The default\n   is zero, which disables random jitter.\n - Max: Limit the random jitter time to this value (ms).\n\t- Pct: odds (0-100) that a random jitter value for the packet\n   will be generated.  Otherwise, a jitter value of zero\n   is used, and the packet will only be delayed by the jitter\n   system if necessary to retain order, due to the jitter of a\n   previous packet.\n\n All values are [global float]\n\n Fake jitter is simulated after fake lag, but before reordering."]
    k_ESteamNetworkingConfig_FakePacketJitter_Recv_Avg = 56,
    #[doc = " Simulated jitter/clumping.\n\n For each packet, a jitter value is determined (which may\n be zero).  This amount is added as extra delay to the\n packet.  When a subsequent packet is queued, it receives its\n own random jitter amount from the current time.  if this would\n result in the packets being delivered out of order, the later\n packet queue time is adjusted to happen after the first packet.\n Thus simulating jitter by itself will not reorder packets, but it\n can \"clump\" them.\n\n\t- Avg: A random jitter time is generated using an exponential\n   distribution using this value as the mean (ms).  The default\n   is zero, which disables random jitter.\n - Max: Limit the random jitter time to this value (ms).\n\t- Pct: odds (0-100) that a random jitter value for the packet\n   will be generated.  Otherwise, a jitter value of zero\n   is used, and the packet will only be delayed by the jitter\n   system if necessary to retain order, due to the jitter of a\n   previous packet.\n\n All values are [global float]\n\n Fake jitter is simulated after fake lag, but before reordering."]
    k_ESteamNetworkingConfig_FakePacketJitter_Recv_Max = 57,
    #[doc = " Simulated jitter/clumping.\n\n For each packet, a jitter value is determined (which may\n be zero).  This amount is added as extra delay to the\n packet.  When a subsequent packet is queued, it receives its\n own random jitter amount from the current time.  if this would\n result in the packets being delivered out of order, the later\n packet queue time is adjusted to happen after the first packet.\n Thus simulating jitter by itself will not reorder packets, but it\n can \"clump\" them.\n\n\t- Avg: A random jitter time is generated using an exponential\n   distribution using this value as the mean (ms).  The default\n   is zero, which disables random jitter.\n - Max: Limit the random jitter time to this value (ms).\n\t- Pct: odds (0-100) that a random jitter value for the packet\n   will be generated.  Otherwise, a jitter value of zero\n   is used, and the packet will only be delayed by the jitter\n   system if necessary to retain order, due to the jitter of a\n   previous packet.\n\n All values are [global float]\n\n Fake jitter is simulated after fake lag, but before reordering."]
    k_ESteamNetworkingConfig_FakePacketJitter_Recv_Pct = 58,
    #[doc = " [global float] 0-100 Percentage of packets we will add additional\n delay to.  If other packet(s) are sent/received within this delay\n window (that doesn't also randomly receive the same extra delay),\n then the packets become reordered.\n\n This mechanism is primarily intended to generate out-of-order\n packets.  To simulate random jitter, use the FakePacketJitter.\n Fake packet reordering is applied after fake lag and jitter"]
    k_ESteamNetworkingConfig_FakePacketReorder_Send = 6,
    #[doc = " [global float] 0-100 Percentage of packets we will add additional\n delay to.  If other packet(s) are sent/received within this delay\n window (that doesn't also randomly receive the same extra delay),\n then the packets become reordered.\n\n This mechanism is primarily intended to generate out-of-order\n packets.  To simulate random jitter, use the FakePacketJitter.\n Fake packet reordering is applied after fake lag and jitter"]
    k_ESteamNetworkingConfig_FakePacketReorder_Recv = 7,
    #[doc = " [global int32] Extra delay, in ms, to apply to reordered\n packets.  The same time value is used for sending and receiving."]
    k_ESteamNetworkingConfig_FakePacketReorder_Time = 8,
    #[doc = " [global float 0--100] Globally duplicate some percentage of packets."]
    k_ESteamNetworkingConfig_FakePacketDup_Send = 26,
    #[doc = " [global float 0--100] Globally duplicate some percentage of packets."]
    k_ESteamNetworkingConfig_FakePacketDup_Recv = 27,
    #[doc = " [global int32] Amount of delay, in ms, to delay duplicated packets.\n (We chose a random delay between 0 and this value)"]
    k_ESteamNetworkingConfig_FakePacketDup_TimeMax = 28,
    #[doc = " [global int32] Trace every UDP packet, similar to Wireshark or tcpdump.\n Value is max number of bytes to dump.  -1 disables tracing."]
    k_ESteamNetworkingConfig_PacketTraceMaxBytes = 41,
    k_ESteamNetworkingConfig_FakeRateLimit_Send_Rate = 42,
    k_ESteamNetworkingConfig_FakeRateLimit_Send_Burst = 43,
    k_ESteamNetworkingConfig_FakeRateLimit_Recv_Rate = 44,
    k_ESteamNetworkingConfig_FakeRateLimit_Recv_Burst = 45,
    k_ESteamNetworkingConfig_OutOfOrderCorrectionWindowMicroseconds = 51,
    #[doc = " [connection FnSteamNetConnectionStatusChanged] Callback that will be invoked\n when the state of a connection changes.\n\n IMPORTANT: callbacks are dispatched to the handler that is in effect at the time\n the event occurs, which might be in another thread.  For example, immediately after\n creating a listen socket, you may receive an incoming connection.  And then immediately\n after this, the remote host may close the connection.  All of this could happen\n before the function to create the listen socket has returned.  For this reason,\n callbacks usually must be in effect at the time of object creation.  This means\n you should set them when you are creating the listen socket or connection, or have\n them in effect so they will be inherited at the time of object creation.\n\n For example:\n\n exterm void MyStatusChangedFunc( SteamNetConnectionStatusChangedCallback_t *info );\n SteamNetworkingConfigValue_t opt; opt.SetPtr( k_ESteamNetworkingConfig_Callback_ConnectionStatusChanged, MyStatusChangedFunc );\n SteamNetworkingIPAddr localAddress; localAddress.Clear();\n HSteamListenSocket hListenSock = SteamNetworkingSockets()->CreateListenSocketIP( localAddress, 1, &opt );\n\n When accepting an incoming connection, there is no atomic way to switch the\n callback.  However, if the connection is DOA, AcceptConnection() will fail, and\n you can fetch the state of the connection at that time.\n\n If all connections and listen sockets can use the same callback, the simplest\n method is to set it globally before you create any listen sockets or connections."]
    k_ESteamNetworkingConfig_Callback_ConnectionStatusChanged = 201,
    #[doc = " [global FnSteamNetAuthenticationStatusChanged] Callback that will be invoked\n when our auth state changes.  If you use this, install the callback before creating\n any connections or listen sockets, and don't change it.\n See: ISteamNetworkingUtils::SetGlobalCallback_SteamNetAuthenticationStatusChanged"]
    k_ESteamNetworkingConfig_Callback_AuthStatusChanged = 202,
    #[doc = " [global FnSteamRelayNetworkStatusChanged] Callback that will be invoked\n when our auth state changes.  If you use this, install the callback before creating\n any connections or listen sockets, and don't change it.\n See: ISteamNetworkingUtils::SetGlobalCallback_SteamRelayNetworkStatusChanged"]
    k_ESteamNetworkingConfig_Callback_RelayNetworkStatusChanged = 203,
    #[doc = " [global FnSteamNetworkingMessagesSessionRequest] Callback that will be invoked\n when a peer wants to initiate a SteamNetworkingMessagesSessionRequest.\n See: ISteamNetworkingUtils::SetGlobalCallback_MessagesSessionRequest"]
    k_ESteamNetworkingConfig_Callback_MessagesSessionRequest = 204,
    #[doc = " [global FnSteamNetworkingMessagesSessionFailed] Callback that will be invoked\n when a session you have initiated, or accepted either fails to connect, or loses\n connection in some unexpected way.\n See: ISteamNetworkingUtils::SetGlobalCallback_MessagesSessionFailed"]
    k_ESteamNetworkingConfig_Callback_MessagesSessionFailed = 205,
    #[doc = " [global FnSteamNetworkingSocketsCreateConnectionSignaling] Callback that will\n be invoked when we need to create a signaling object for a connection\n initiated locally.  See: ISteamNetworkingSockets::ConnectP2P,\n ISteamNetworkingMessages."]
    k_ESteamNetworkingConfig_Callback_CreateConnectionSignaling = 206,
    #[doc = " [global FnSteamNetworkingFakeIPResult] Callback that's invoked when\n a FakeIP allocation finishes.  See: ISteamNetworkingSockets::BeginAsyncRequestFakeIP,\n ISteamNetworkingUtils::SetGlobalCallback_FakeIPResult"]
    k_ESteamNetworkingConfig_Callback_FakeIPResult = 207,
    #[doc = " [connection string] Comma-separated list of STUN servers that can be used\n for NAT piercing.  If you set this to an empty string, NAT piercing will\n not be attempted.  Also if \"public\" candidates are not allowed for\n P2P_Transport_ICE_Enable, then this is ignored."]
    k_ESteamNetworkingConfig_P2P_STUN_ServerList = 103,
    #[doc = " [connection int32] What types of ICE candidates to share with the peer.\n See k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_xxx values"]
    k_ESteamNetworkingConfig_P2P_Transport_ICE_Enable = 104,
    #[doc = " [connection int32] When selecting P2P transport, add various\n penalties to the scores for selected transports.  (Route selection\n scores are on a scale of milliseconds.  The score begins with the\n route ping time and is then adjusted.)"]
    k_ESteamNetworkingConfig_P2P_Transport_ICE_Penalty = 105,
    #[doc = " [connection int32] When selecting P2P transport, add various\n penalties to the scores for selected transports.  (Route selection\n scores are on a scale of milliseconds.  The score begins with the\n route ping time and is then adjusted.)"]
    k_ESteamNetworkingConfig_P2P_Transport_SDR_Penalty = 106,
    #[doc = " [connection int32] When selecting P2P transport, add various\n penalties to the scores for selected transports.  (Route selection\n scores are on a scale of milliseconds.  The score begins with the\n route ping time and is then adjusted.)"]
    k_ESteamNetworkingConfig_P2P_TURN_ServerList = 107,
    #[doc = " [connection int32] When selecting P2P transport, add various\n penalties to the scores for selected transports.  (Route selection\n scores are on a scale of milliseconds.  The score begins with the\n route ping time and is then adjusted.)"]
    k_ESteamNetworkingConfig_P2P_TURN_UserList = 108,
    #[doc = " [connection int32] When selecting P2P transport, add various\n penalties to the scores for selected transports.  (Route selection\n scores are on a scale of milliseconds.  The score begins with the\n route ping time and is then adjusted.)"]
    k_ESteamNetworkingConfig_P2P_TURN_PassList = 109,
    #[doc = " [connection int32] When selecting P2P transport, add various\n penalties to the scores for selected transports.  (Route selection\n scores are on a scale of milliseconds.  The score begins with the\n route ping time and is then adjusted.)"]
    k_ESteamNetworkingConfig_P2P_Transport_ICE_Implementation = 110,
    #[doc = " [global int32] If the first N pings to a port all fail, mark that port as unavailable for\n a while, and try a different one.  Some ISPs and routers may drop the first\n packet, so setting this to 1 may greatly disrupt communications."]
    k_ESteamNetworkingConfig_SDRClient_ConsecutitivePingTimeoutsFailInitial = 19,
    #[doc = " [global int32] If N consecutive pings to a port fail, after having received successful\n communication, mark that port as unavailable for a while, and try a\n different one."]
    k_ESteamNetworkingConfig_SDRClient_ConsecutitivePingTimeoutsFail = 20,
    #[doc = " [global int32] Minimum number of lifetime pings we need to send, before we think our estimate\n is solid.  The first ping to each cluster is very often delayed because of NAT,\n routers not having the best route, etc.  Until we've sent a sufficient number\n of pings, our estimate is often inaccurate.  Keep pinging until we get this\n many pings."]
    k_ESteamNetworkingConfig_SDRClient_MinPingsBeforePingAccurate = 21,
    #[doc = " [global int32] Set all steam datagram traffic to originate from the same\n local port. By default, we open up a new UDP socket (on a different local\n port) for each relay.  This is slightly less optimal, but it works around\n some routers that don't implement NAT properly.  If you have intermittent\n problems talking to relays that might be NAT related, try toggling\n this flag"]
    k_ESteamNetworkingConfig_SDRClient_SingleSocket = 22,
    #[doc = " [global string] Code of relay cluster to force use.  If not empty, we will\n only use relays in that cluster.  E.g. 'iad'"]
    k_ESteamNetworkingConfig_SDRClient_ForceRelayCluster = 29,
    #[doc = " [connection string] For development, a base-64 encoded ticket generated\n using the cert tool.  This can be used to connect to a gameserver via SDR\n without a ticket generated using the game coordinator.  (You will still\n need a key that is trusted for your app, however.)\n\n This can also be passed using the SDR_DEVTICKET environment variable"]
    k_ESteamNetworkingConfig_SDRClient_DevTicket = 30,
    #[doc = " [global string] For debugging.  Override list of relays from the config with\n this set (maybe just one).  Comma-separated list."]
    k_ESteamNetworkingConfig_SDRClient_ForceProxyAddr = 31,
    #[doc = " [global string] For debugging.  Force ping times to clusters to be the specified\n values.  A comma separated list of <cluster>=<ms> values.  E.g. \"sto=32,iad=100\"\n\n This is a dev configuration value, you probably should not let users modify it\n in production."]
    k_ESteamNetworkingConfig_SDRClient_FakeClusterPing = 36,
    #[doc = " [global int32] When probing the SteamDatagram network, we limit exploration\n to the closest N POPs, based on our current best approximated ping to that POP."]
    k_ESteamNetworkingConfig_SDRClient_LimitPingProbesToNearestN = 60,
    #[doc = " [global int32] When probing the SteamDatagram network, we limit exploration\n to the closest N POPs, based on our current best approximated ping to that POP."]
    k_ESteamNetworkingConfig_LogLevel_AckRTT = 13,
    #[doc = " [global int32] When probing the SteamDatagram network, we limit exploration\n to the closest N POPs, based on our current best approximated ping to that POP."]
    k_ESteamNetworkingConfig_LogLevel_PacketDecode = 14,
    #[doc = " [global int32] When probing the SteamDatagram network, we limit exploration\n to the closest N POPs, based on our current best approximated ping to that POP."]
    k_ESteamNetworkingConfig_LogLevel_Message = 15,
    #[doc = " [global int32] When probing the SteamDatagram network, we limit exploration\n to the closest N POPs, based on our current best approximated ping to that POP."]
    k_ESteamNetworkingConfig_LogLevel_PacketGaps = 16,
    #[doc = " [global int32] When probing the SteamDatagram network, we limit exploration\n to the closest N POPs, based on our current best approximated ping to that POP."]
    k_ESteamNetworkingConfig_LogLevel_P2PRendezvous = 17,
    #[doc = " [global int32] When probing the SteamDatagram network, we limit exploration\n to the closest N POPs, based on our current best approximated ping to that POP."]
    k_ESteamNetworkingConfig_LogLevel_SDRRelayPings = 18,
    #[doc = " [global int32] When probing the SteamDatagram network, we limit exploration\n to the closest N POPs, based on our current best approximated ping to that POP."]
    k_ESteamNetworkingConfig_ECN = 999,
    #[doc = " [global int32] When probing the SteamDatagram network, we limit exploration\n to the closest N POPs, based on our current best approximated ping to that POP."]
    k_ESteamNetworkingConfig_DELETED_EnumerateDevVars = 35,
    #[doc = " [global int32] When probing the SteamDatagram network, we limit exploration\n to the closest N POPs, based on our current best approximated ping to that POP."]
    k_ESteamNetworkingConfigValue__Force32Bit = 2147483647,
}
pub const k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Default: ::std::os::raw::c_int = -1;
pub const k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Disable: ::std::os::raw::c_int = 0;
pub const k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Relay: ::std::os::raw::c_int = 1;
pub const k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Private: ::std::os::raw::c_int = 2;
pub const k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Public: ::std::os::raw::c_int = 4;
pub const k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_All: ::std::os::raw::c_int = 2147483647;
#[doc = " In a few places we need to set configuration options on listen sockets and connections, and\n have them take effect *before* the listen socket or connection really starts doing anything.\n Creating the object and then setting the options \"immediately\" after creation doesn't work\n completely, because network packets could be received between the time the object is created and\n when the options are applied.  To set options at creation time in a reliable way, they must be\n passed to the creation function.  This structure is used to pass those options.\n\n For the meaning of these fields, see ISteamNetworkingUtils::SetConfigValue.  Basically\n when the object is created, we just iterate over the list of options and call\n ISteamNetworkingUtils::SetConfigValueStruct, where the scope arguments are supplied by the\n object being created."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SteamNetworkingConfigValue_t {
    #[doc = " Which option is being set"]
    pub m_eValue: ESteamNetworkingConfigValue,
    #[doc = " Which field below did you fill in?"]
    pub m_eDataType: ESteamNetworkingConfigDataType,
    pub m_val: SteamNetworkingConfigValue_t__bindgen_ty_1,
}
#[doc = " Option value"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union SteamNetworkingConfigValue_t__bindgen_ty_1 {
    pub m_int32: i32,
    pub m_int64: i64,
    pub m_float: f32,
    pub m_string: *const ::std::os::raw::c_char,
    pub m_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_SteamNetworkingConfigValue_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingConfigValue_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingConfigValue_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(SteamNetworkingConfigValue_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingConfigValue_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SteamNetworkingConfigValue_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_int32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingConfigValue_t__bindgen_ty_1),
            "::",
            stringify!(m_int32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_int64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingConfigValue_t__bindgen_ty_1),
            "::",
            stringify!(m_int64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_float) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingConfigValue_t__bindgen_ty_1),
            "::",
            stringify!(m_float)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_string) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingConfigValue_t__bindgen_ty_1),
            "::",
            stringify!(m_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingConfigValue_t__bindgen_ty_1),
            "::",
            stringify!(m_ptr)
        )
    );
}
#[test]
fn bindgen_test_layout_SteamNetworkingConfigValue_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingConfigValue_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingConfigValue_t>(),
        16usize,
        concat!("Size of: ", stringify!(SteamNetworkingConfigValue_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingConfigValue_t>(),
        8usize,
        concat!("Alignment of ", stringify!(SteamNetworkingConfigValue_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingConfigValue_t),
            "::",
            stringify!(m_eValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eDataType) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingConfigValue_t),
            "::",
            stringify!(m_eDataType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_val) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingConfigValue_t),
            "::",
            stringify!(m_val)
        )
    );
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " Return value of ISteamNetworkintgUtils::GetConfigValue"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamNetworkingGetConfigValueResult {
    k_ESteamNetworkingGetConfigValue_BadValue = -1,
    k_ESteamNetworkingGetConfigValue_BadScopeObj = -2,
    k_ESteamNetworkingGetConfigValue_BufferTooSmall = -3,
    k_ESteamNetworkingGetConfigValue_OK = 1,
    k_ESteamNetworkingGetConfigValue_OKInherited = 2,
    k_ESteamNetworkingGetConfigValueResult__Force32Bit = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Detail level for diagnostic output callback.\n See ISteamNetworkingUtils::SetDebugOutputFunction"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamNetworkingSocketsDebugOutputType {
    k_ESteamNetworkingSocketsDebugOutputType_None = 0,
    k_ESteamNetworkingSocketsDebugOutputType_Bug = 1,
    k_ESteamNetworkingSocketsDebugOutputType_Error = 2,
    k_ESteamNetworkingSocketsDebugOutputType_Important = 3,
    k_ESteamNetworkingSocketsDebugOutputType_Warning = 4,
    k_ESteamNetworkingSocketsDebugOutputType_Msg = 5,
    k_ESteamNetworkingSocketsDebugOutputType_Verbose = 6,
    k_ESteamNetworkingSocketsDebugOutputType_Debug = 7,
    k_ESteamNetworkingSocketsDebugOutputType_Everything = 8,
    k_ESteamNetworkingSocketsDebugOutputType__Force32Bit = 2147483647,
}
#[doc = " Setup callback for debug output, and the desired verbosity you want."]
pub type FSteamNetworkingSocketsDebugOutput = ::std::option::Option<
    unsafe extern "C" fn(
        nType: ESteamNetworkingSocketsDebugOutputType,
        pszMsg: *const ::std::os::raw::c_char,
    ),
>;
#[doc = " The POPID \"dev\" is used in non-production environments for testing."]
pub const k_SteamDatagramPOPID_dev: SteamNetworkingPOPID = 6579574;
#[doc = " Utility class for printing a SteamNetworkingPOPID."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamNetworkingPOPIDRender {
    pub buf: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_SteamNetworkingPOPIDRender() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingPOPIDRender> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingPOPIDRender>(),
        8usize,
        concat!("Size of: ", stringify!(SteamNetworkingPOPIDRender))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingPOPIDRender>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamNetworkingPOPIDRender))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingPOPIDRender),
            "::",
            stringify!(buf)
        )
    );
}
#[doc = " A message that has been received."]
pub type ISteamNetworkingMessage = SteamNetworkingMessage_t;
pub type SteamDatagramErrMsg = SteamNetworkingErrMsg;
#[repr(C)]
pub struct ISteamNetworkingMessages__bindgen_vtable(::std::os::raw::c_void);
#[doc = " The non-connection-oriented interface to send and receive messages\n (whether they be \"clients\" or \"servers\").\n\n ISteamNetworkingSockets is connection-oriented (like TCP), meaning you\n need to listen and connect, and then you send messages using a connection\n handle.  ISteamNetworkingMessages is more like UDP, in that you can just send\n messages to arbitrary peers at any time.  The underlying connections are\n established implicitly.\n\n Under the hood ISteamNetworkingMessages works on top of the ISteamNetworkingSockets\n code, so you get the same routing and messaging efficiency.  The difference is\n mainly in your responsibility to explicitly establish a connection and\n the type of feedback you get about the state of the connection.  Both\n interfaces can do \"P2P\" communications, and both support both unreliable\n and reliable messages, fragmentation and reassembly.\n\n The primary purpose of this interface is to be \"like UDP\", so that UDP-based code\n can be ported easily to take advantage of relayed connections.  If you find\n yourself needing more low level information or control, or to be able to better\n handle failure, then you probably need to use ISteamNetworkingSockets directly.\n Also, note that if your main goal is to obtain a connection between two peers\n without concerning yourself with assigning roles of \"client\" and \"server\",\n you may find the symmetric connection mode of ISteamNetworkingSockets useful.\n (See k_ESteamNetworkingConfig_SymmetricConnect.)\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamNetworkingMessages {
    pub vtable_: *const ISteamNetworkingMessages__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamNetworkingMessages() {
    assert_eq!(
        ::std::mem::size_of::<ISteamNetworkingMessages>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamNetworkingMessages))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamNetworkingMessages>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamNetworkingMessages))
    );
}
#[doc = " Posted when a remote host is sending us a message, and we do not already have a session with them"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SteamNetworkingMessagesSessionRequest_t {
    pub m_identityRemote: SteamNetworkingIdentity,
}
pub const SteamNetworkingMessagesSessionRequest_t_k_iCallback:
    SteamNetworkingMessagesSessionRequest_t__bindgen_ty_1 =
    SteamNetworkingMessagesSessionRequest_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamNetworkingMessagesSessionRequest_t__bindgen_ty_1 {
    k_iCallback = 1251,
}
#[test]
fn bindgen_test_layout_SteamNetworkingMessagesSessionRequest_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingMessagesSessionRequest_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingMessagesSessionRequest_t>(),
        136usize,
        concat!(
            "Size of: ",
            stringify!(SteamNetworkingMessagesSessionRequest_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingMessagesSessionRequest_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SteamNetworkingMessagesSessionRequest_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_identityRemote) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessagesSessionRequest_t),
            "::",
            stringify!(m_identityRemote)
        )
    );
}
#[doc = " Posted when we fail to establish a connection, or we detect that communications\n have been disrupted it an unusual way.  There is no notification when a peer proactively\n closes the session.  (\"Closed by peer\" is not a concept of UDP-style communications, and\n SteamNetworkingMessages is primarily intended to make porting UDP code easy.)\n\n Remember: callbacks are asynchronous.   See notes on SendMessageToUser,\n and k_nSteamNetworkingSend_AutoRestartBrokenSession in particular.\n\n Also, if a session times out due to inactivity, no callbacks will be posted.  The only\n way to detect that this is happening is that querying the session state may return\n none, connecting, and findingroute again."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct SteamNetworkingMessagesSessionFailed_t {
    #[doc = " Detailed info about the session that failed.\n SteamNetConnectionInfo_t::m_identityRemote indicates who this session\n was with."]
    pub m_info: SteamNetConnectionInfo_t,
}
pub const SteamNetworkingMessagesSessionFailed_t_k_iCallback:
    SteamNetworkingMessagesSessionFailed_t__bindgen_ty_1 =
    SteamNetworkingMessagesSessionFailed_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamNetworkingMessagesSessionFailed_t__bindgen_ty_1 {
    k_iCallback = 1252,
}
#[test]
fn bindgen_test_layout_SteamNetworkingMessagesSessionFailed_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingMessagesSessionFailed_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingMessagesSessionFailed_t>(),
        696usize,
        concat!(
            "Size of: ",
            stringify!(SteamNetworkingMessagesSessionFailed_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingMessagesSessionFailed_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SteamNetworkingMessagesSessionFailed_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessagesSessionFailed_t),
            "::",
            stringify!(m_info)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamNetworkingConnectionSignaling {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamNetworkingSignalingRecvContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamNetworkingFakeUDPPort {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct ISteamNetworkingSockets__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Lower level networking API.\n\n - Connection-oriented API (like TCP, not UDP).  When sending and receiving\n   messages, a connection handle is used.  (For a UDP-style interface, where\n   the peer is identified by their address with each send/recv call, see\n   ISteamNetworkingMessages.)  The typical pattern is for a \"server\" to \"listen\"\n   on a \"listen socket.\"  A \"client\" will \"connect\" to the server, and the\n   server will \"accept\" the connection.  If you have a symmetric situation\n   where either peer may initiate the connection and server/client roles are\n   not clearly defined, check out k_ESteamNetworkingConfig_SymmetricConnect.\n - But unlike TCP, it's message-oriented, not stream-oriented.\n - Mix of reliable and unreliable messages\n - Fragmentation and reassembly\n - Supports connectivity over plain UDP\n - Also supports SDR (\"Steam Datagram Relay\") connections, which are\n   addressed by the identity of the peer.  There is a \"P2P\" use case and\n   a \"hosted dedicated server\" use case.\n\n Note that neither of the terms \"connection\" nor \"socket\" necessarily correspond\n one-to-one with an underlying UDP socket.  An attempt has been made to\n keep the semantics as similar to the standard socket model when appropriate,\n but some deviations do exist.\n\n See also: ISteamNetworkingMessages, the UDP-style interface.  This API might be\n easier to use, especially when porting existing UDP code."]
#[repr(C)]
#[derive(Debug)]
pub struct ISteamNetworkingSockets {
    pub vtable_: *const ISteamNetworkingSockets__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamNetworkingSockets() {
    assert_eq!(
        ::std::mem::size_of::<ISteamNetworkingSockets>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamNetworkingSockets))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamNetworkingSockets>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamNetworkingSockets))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23ISteamNetworkingSocketsD1Ev"]
    pub fn ISteamNetworkingSockets_ISteamNetworkingSockets_destructor(
        this: *mut ISteamNetworkingSockets,
    );
}
impl ISteamNetworkingSockets {
    #[inline]
    pub unsafe fn destruct(&mut self) {
        ISteamNetworkingSockets_ISteamNetworkingSockets_destructor(self)
    }
}
#[doc = " This callback is posted whenever a connection is created, destroyed, or changes state.\n The m_info field will contain a complete description of the connection at the time the\n change occurred and the callback was posted.  In particular, m_eState will have the\n new connection state.\n\n You will usually need to listen for this callback to know when:\n - A new connection arrives on a listen socket.\n   m_info.m_hListenSocket will be set, m_eOldState = k_ESteamNetworkingConnectionState_None,\n   and m_info.m_eState = k_ESteamNetworkingConnectionState_Connecting.\n   See ISteamNetworkigSockets::AcceptConnection.\n - A connection you initiated has been accepted by the remote host.\n   m_eOldState = k_ESteamNetworkingConnectionState_Connecting, and\n   m_info.m_eState = k_ESteamNetworkingConnectionState_Connected.\n   Some connections might transition to k_ESteamNetworkingConnectionState_FindingRoute first.\n - A connection has been actively rejected or closed by the remote host.\n   m_eOldState = k_ESteamNetworkingConnectionState_Connecting or k_ESteamNetworkingConnectionState_Connected,\n   and m_info.m_eState = k_ESteamNetworkingConnectionState_ClosedByPeer.  m_info.m_eEndReason\n   and m_info.m_szEndDebug will have for more details.\n   NOTE: upon receiving this callback, you must still destroy the connection using\n   ISteamNetworkingSockets::CloseConnection to free up local resources.  (The details\n   passed to the function are not used in this case, since the connection is already closed.)\n - A problem was detected with the connection, and it has been closed by the local host.\n   The most common failure is timeout, but other configuration or authentication failures\n   can cause this.  m_eOldState = k_ESteamNetworkingConnectionState_Connecting or\n   k_ESteamNetworkingConnectionState_Connected, and m_info.m_eState = k_ESteamNetworkingConnectionState_ProblemDetectedLocally.\n   m_info.m_eEndReason and m_info.m_szEndDebug will have for more details.\n   NOTE: upon receiving this callback, you must still destroy the connection using\n   ISteamNetworkingSockets::CloseConnection to free up local resources.  (The details\n   passed to the function are not used in this case, since the connection is already closed.)\n\n Remember that callbacks are posted to a queue, and networking connections can\n change at any time.  It is possible that the connection has already changed\n state by the time you process this callback.\n\n Also note that callbacks will be posted when connections are created and destroyed by your own API calls."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SteamNetConnectionStatusChangedCallback_t {
    #[doc = " Connection handle"]
    pub m_hConn: HSteamNetConnection,
    #[doc = " Full connection info"]
    pub m_info: SteamNetConnectionInfo_t,
    #[doc = " Previous state.  (Current state is in m_info.m_eState)"]
    pub m_eOldState: ESteamNetworkingConnectionState,
}
pub const SteamNetConnectionStatusChangedCallback_t_k_iCallback:
    SteamNetConnectionStatusChangedCallback_t__bindgen_ty_1 =
    SteamNetConnectionStatusChangedCallback_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamNetConnectionStatusChangedCallback_t__bindgen_ty_1 {
    k_iCallback = 1221,
}
#[test]
fn bindgen_test_layout_SteamNetConnectionStatusChangedCallback_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetConnectionStatusChangedCallback_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetConnectionStatusChangedCallback_t>(),
        704usize,
        concat!(
            "Size of: ",
            stringify!(SteamNetConnectionStatusChangedCallback_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetConnectionStatusChangedCallback_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SteamNetConnectionStatusChangedCallback_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hConn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionStatusChangedCallback_t),
            "::",
            stringify!(m_hConn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_info) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionStatusChangedCallback_t),
            "::",
            stringify!(m_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eOldState) as usize - ptr as usize },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionStatusChangedCallback_t),
            "::",
            stringify!(m_eOldState)
        )
    );
}
#[doc = " A struct used to describe our readiness to participate in authenticated,\n encrypted communication.  In order to do this we need:\n\n - The list of trusted CA certificates that might be relevant for this\n   app.\n - A valid certificate issued by a CA.\n\n This callback is posted whenever the state of our readiness changes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamNetAuthenticationStatus_t {
    #[doc = " Status"]
    pub m_eAvail: ESteamNetworkingAvailability,
    #[doc = " Non-localized English language status.  For diagnostic/debugging\n purposes only."]
    pub m_debugMsg: [::std::os::raw::c_char; 256usize],
}
pub const SteamNetAuthenticationStatus_t_k_iCallback: SteamNetAuthenticationStatus_t__bindgen_ty_1 =
    SteamNetAuthenticationStatus_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamNetAuthenticationStatus_t__bindgen_ty_1 {
    k_iCallback = 1222,
}
#[test]
fn bindgen_test_layout_SteamNetAuthenticationStatus_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetAuthenticationStatus_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetAuthenticationStatus_t>(),
        260usize,
        concat!("Size of: ", stringify!(SteamNetAuthenticationStatus_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetAuthenticationStatus_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamNetAuthenticationStatus_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eAvail) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetAuthenticationStatus_t),
            "::",
            stringify!(m_eAvail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_debugMsg) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetAuthenticationStatus_t),
            "::",
            stringify!(m_debugMsg)
        )
    );
}
#[repr(C)]
pub struct ISteamNetworkingUtils__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Misc networking utilities for checking the local networking environment\n and estimating pings."]
#[repr(C)]
#[derive(Debug)]
pub struct ISteamNetworkingUtils {
    pub vtable_: *const ISteamNetworkingUtils__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamNetworkingUtils() {
    assert_eq!(
        ::std::mem::size_of::<ISteamNetworkingUtils>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamNetworkingUtils))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamNetworkingUtils>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamNetworkingUtils))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21ISteamNetworkingUtilsD1Ev"]
    pub fn ISteamNetworkingUtils_ISteamNetworkingUtils_destructor(this: *mut ISteamNetworkingUtils);
}
impl ISteamNetworkingUtils {
    #[inline]
    pub unsafe fn destruct(&mut self) {
        ISteamNetworkingUtils_ISteamNetworkingUtils_destructor(self)
    }
}
#[doc = " A struct used to describe our readiness to use the relay network.\n To do this we first need to fetch the network configuration,\n which describes what POPs are available."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamRelayNetworkStatus_t {
    #[doc = " Summary status.  When this is \"current\", initialization has\n completed.  Anything else means you are not ready yet, or\n there is a significant problem."]
    pub m_eAvail: ESteamNetworkingAvailability,
    #[doc = " Nonzero if latency measurement is in progress (or pending,\n awaiting a prerequisite)."]
    pub m_bPingMeasurementInProgress: ::std::os::raw::c_int,
    #[doc = " Status obtaining the network config.  This is a prerequisite\n for relay network access.\n\n Failure to obtain the network config almost always indicates\n a problem with the local internet connection."]
    pub m_eAvailNetworkConfig: ESteamNetworkingAvailability,
    #[doc = " Current ability to communicate with ANY relay.  Note that\n the complete failure to communicate with any relays almost\n always indicates a problem with the local Internet connection.\n (However, just because you can reach a single relay doesn't\n mean that the local connection is in perfect health.)"]
    pub m_eAvailAnyRelay: ESteamNetworkingAvailability,
    #[doc = " Non-localized English language status.  For diagnostic/debugging\n purposes only."]
    pub m_debugMsg: [::std::os::raw::c_char; 256usize],
}
pub const SteamRelayNetworkStatus_t_k_iCallback: SteamRelayNetworkStatus_t__bindgen_ty_1 =
    SteamRelayNetworkStatus_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SteamRelayNetworkStatus_t__bindgen_ty_1 {
    k_iCallback = 1281,
}
#[test]
fn bindgen_test_layout_SteamRelayNetworkStatus_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamRelayNetworkStatus_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamRelayNetworkStatus_t>(),
        272usize,
        concat!("Size of: ", stringify!(SteamRelayNetworkStatus_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamRelayNetworkStatus_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamRelayNetworkStatus_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eAvail) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamRelayNetworkStatus_t),
            "::",
            stringify!(m_eAvail)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_bPingMeasurementInProgress) as usize - ptr as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamRelayNetworkStatus_t),
            "::",
            stringify!(m_bPingMeasurementInProgress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eAvailNetworkConfig) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamRelayNetworkStatus_t),
            "::",
            stringify!(m_eAvailNetworkConfig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eAvailAnyRelay) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamRelayNetworkStatus_t),
            "::",
            stringify!(m_eAvailAnyRelay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_debugMsg) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamRelayNetworkStatus_t),
            "::",
            stringify!(m_debugMsg)
        )
    );
}
#[doc = " Utility class for printing a SteamNetworkingIdentity.\n E.g. printf( \"Identity is '%s'\\n\", SteamNetworkingIdentityRender( identity ).c_str() );"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamNetworkingIdentityRender {
    pub buf: [::std::os::raw::c_char; 128usize],
}
#[test]
fn bindgen_test_layout_SteamNetworkingIdentityRender() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingIdentityRender> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingIdentityRender>(),
        128usize,
        concat!("Size of: ", stringify!(SteamNetworkingIdentityRender))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingIdentityRender>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamNetworkingIdentityRender))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIdentityRender),
            "::",
            stringify!(buf)
        )
    );
}
#[doc = " Utility class for printing a SteamNetworkingIPAddrRender."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamNetworkingIPAddrRender {
    pub buf: [::std::os::raw::c_char; 48usize],
}
#[test]
fn bindgen_test_layout_SteamNetworkingIPAddrRender() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingIPAddrRender> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingIPAddrRender>(),
        48usize,
        concat!("Size of: ", stringify!(SteamNetworkingIPAddrRender))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingIPAddrRender>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamNetworkingIPAddrRender))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIPAddrRender),
            "::",
            stringify!(buf)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ESteamAPIInitResult {
    k_ESteamAPIInitResult_OK = 0,
    k_ESteamAPIInitResult_FailedGeneric = 1,
    k_ESteamAPIInitResult_NoSteamClient = 2,
    k_ESteamAPIInitResult_VersionMismatch = 3,
}
extern "C" {
    pub fn SteamAPI_InitFlat(pOutErrMsg: *mut SteamErrMsg) -> ESteamAPIInitResult;
}
extern "C" {
    pub fn SteamAPI_Shutdown();
}
extern "C" {
    pub fn SteamAPI_RestartAppIfNecessary(unOwnAppID: uint32) -> bool;
}
extern "C" {
    pub fn SteamAPI_ReleaseCurrentThreadMemory();
}
extern "C" {
    pub fn SteamAPI_WriteMiniDump(
        uStructuredExceptionCode: uint32,
        pvExceptionInfo: *mut ::std::os::raw::c_void,
        uBuildID: uint32,
    );
}
extern "C" {
    pub fn SteamAPI_SetMiniDumpComment(pchMsg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn SteamAPI_IsSteamRunning() -> bool;
}
extern "C" {
    pub fn SteamAPI_GetSteamInstallPath() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_SetTryCatchCallbacks(bTryCatchCallbacks: bool);
}
extern "C" {
    #[doc = " Inform the API that you wish to use manual event dispatch.  This must be called after SteamAPI_Init, but before\n you use any of the other manual dispatch functions below."]
    pub fn SteamAPI_ManualDispatch_Init();
}
extern "C" {
    #[doc = " Perform certain periodic actions that need to be performed."]
    pub fn SteamAPI_ManualDispatch_RunFrame(hSteamPipe: HSteamPipe);
}
extern "C" {
    #[doc = " Fetch the next pending callback on the given pipe, if any.  If a callback is available, true is returned\n and the structure is populated.  In this case, you MUST call SteamAPI_ManualDispatch_FreeLastCallback\n (after dispatching the callback) before calling SteamAPI_ManualDispatch_GetNextCallback again."]
    pub fn SteamAPI_ManualDispatch_GetNextCallback(
        hSteamPipe: HSteamPipe,
        pCallbackMsg: *mut CallbackMsg_t,
    ) -> bool;
}
extern "C" {
    #[doc = " You must call this after dispatching the callback, if SteamAPI_ManualDispatch_GetNextCallback returns true."]
    pub fn SteamAPI_ManualDispatch_FreeLastCallback(hSteamPipe: HSteamPipe);
}
extern "C" {
    #[doc = " Return the call result for the specified call on the specified pipe.  You really should\n only call this in a handler for SteamAPICallCompleted_t callback."]
    pub fn SteamAPI_ManualDispatch_GetAPICallResult(
        hSteamPipe: HSteamPipe,
        hSteamAPICall: SteamAPICall_t,
        pCallback: *mut ::std::os::raw::c_void,
        cubCallback: ::std::os::raw::c_int,
        iCallbackExpected: ::std::os::raw::c_int,
        pbFailed: *mut bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamInternal_SteamAPI_Init(
        pszInternalCheckInterfaceVersions: *const ::std::os::raw::c_char,
        pOutErrMsg: *mut SteamErrMsg,
    ) -> ESteamAPIInitResult;
}
#[repr(C)]
pub struct ISteamGameServer__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamGameServer {
    pub vtable_: *const ISteamGameServer__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamGameServer() {
    assert_eq!(
        ::std::mem::size_of::<ISteamGameServer>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamGameServer))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamGameServer>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamGameServer))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GSClientApprove_t {
    pub m_SteamID: CSteamID,
    pub m_OwnerSteamID: CSteamID,
}
pub const GSClientApprove_t_k_iCallback: GSClientApprove_t__bindgen_ty_1 =
    GSClientApprove_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GSClientApprove_t__bindgen_ty_1 {
    k_iCallback = 201,
}
#[test]
fn bindgen_test_layout_GSClientApprove_t() {
    const UNINIT: ::std::mem::MaybeUninit<GSClientApprove_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GSClientApprove_t>(),
        16usize,
        concat!("Size of: ", stringify!(GSClientApprove_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GSClientApprove_t>(),
        1usize,
        concat!("Alignment of ", stringify!(GSClientApprove_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_SteamID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GSClientApprove_t),
            "::",
            stringify!(m_SteamID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_OwnerSteamID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GSClientApprove_t),
            "::",
            stringify!(m_OwnerSteamID)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GSClientDeny_t {
    pub m_SteamID: CSteamID,
    pub m_eDenyReason: EDenyReason,
    pub m_rgchOptionalText: [::std::os::raw::c_char; 128usize],
}
pub const GSClientDeny_t_k_iCallback: GSClientDeny_t__bindgen_ty_1 =
    GSClientDeny_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GSClientDeny_t__bindgen_ty_1 {
    k_iCallback = 202,
}
#[test]
fn bindgen_test_layout_GSClientDeny_t() {
    const UNINIT: ::std::mem::MaybeUninit<GSClientDeny_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GSClientDeny_t>(),
        140usize,
        concat!("Size of: ", stringify!(GSClientDeny_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GSClientDeny_t>(),
        4usize,
        concat!("Alignment of ", stringify!(GSClientDeny_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_SteamID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GSClientDeny_t),
            "::",
            stringify!(m_SteamID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eDenyReason) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GSClientDeny_t),
            "::",
            stringify!(m_eDenyReason)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchOptionalText) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GSClientDeny_t),
            "::",
            stringify!(m_rgchOptionalText)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GSClientKick_t {
    pub m_SteamID: CSteamID,
    pub m_eDenyReason: EDenyReason,
}
pub const GSClientKick_t_k_iCallback: GSClientKick_t__bindgen_ty_1 =
    GSClientKick_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GSClientKick_t__bindgen_ty_1 {
    k_iCallback = 203,
}
#[test]
fn bindgen_test_layout_GSClientKick_t() {
    const UNINIT: ::std::mem::MaybeUninit<GSClientKick_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GSClientKick_t>(),
        12usize,
        concat!("Size of: ", stringify!(GSClientKick_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GSClientKick_t>(),
        4usize,
        concat!("Alignment of ", stringify!(GSClientKick_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_SteamID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GSClientKick_t),
            "::",
            stringify!(m_SteamID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eDenyReason) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GSClientKick_t),
            "::",
            stringify!(m_eDenyReason)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct GSClientAchievementStatus_t {
    pub m_SteamID: uint64,
    pub m_pchAchievement: [::std::os::raw::c_char; 128usize],
    pub m_bUnlocked: bool,
}
pub const GSClientAchievementStatus_t_k_iCallback: GSClientAchievementStatus_t__bindgen_ty_1 =
    GSClientAchievementStatus_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GSClientAchievementStatus_t__bindgen_ty_1 {
    k_iCallback = 206,
}
#[test]
fn bindgen_test_layout_GSClientAchievementStatus_t() {
    const UNINIT: ::std::mem::MaybeUninit<GSClientAchievementStatus_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GSClientAchievementStatus_t>(),
        140usize,
        concat!("Size of: ", stringify!(GSClientAchievementStatus_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GSClientAchievementStatus_t>(),
        4usize,
        concat!("Alignment of ", stringify!(GSClientAchievementStatus_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_SteamID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GSClientAchievementStatus_t),
            "::",
            stringify!(m_SteamID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pchAchievement) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GSClientAchievementStatus_t),
            "::",
            stringify!(m_pchAchievement)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bUnlocked) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(GSClientAchievementStatus_t),
            "::",
            stringify!(m_bUnlocked)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GSPolicyResponse_t {
    pub m_bSecure: uint8,
}
pub const GSPolicyResponse_t_k_iCallback: GSPolicyResponse_t__bindgen_ty_1 =
    GSPolicyResponse_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GSPolicyResponse_t__bindgen_ty_1 {
    k_iCallback = 115,
}
#[test]
fn bindgen_test_layout_GSPolicyResponse_t() {
    const UNINIT: ::std::mem::MaybeUninit<GSPolicyResponse_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GSPolicyResponse_t>(),
        1usize,
        concat!("Size of: ", stringify!(GSPolicyResponse_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GSPolicyResponse_t>(),
        1usize,
        concat!("Alignment of ", stringify!(GSPolicyResponse_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bSecure) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GSPolicyResponse_t),
            "::",
            stringify!(m_bSecure)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GSGameplayStats_t {
    pub m_eResult: EResult,
    pub m_nRank: int32,
    pub m_unTotalConnects: uint32,
    pub m_unTotalMinutesPlayed: uint32,
}
pub const GSGameplayStats_t_k_iCallback: GSGameplayStats_t__bindgen_ty_1 =
    GSGameplayStats_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GSGameplayStats_t__bindgen_ty_1 {
    k_iCallback = 207,
}
#[test]
fn bindgen_test_layout_GSGameplayStats_t() {
    const UNINIT: ::std::mem::MaybeUninit<GSGameplayStats_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GSGameplayStats_t>(),
        16usize,
        concat!("Size of: ", stringify!(GSGameplayStats_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GSGameplayStats_t>(),
        4usize,
        concat!("Alignment of ", stringify!(GSGameplayStats_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GSGameplayStats_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nRank) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GSGameplayStats_t),
            "::",
            stringify!(m_nRank)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unTotalConnects) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GSGameplayStats_t),
            "::",
            stringify!(m_unTotalConnects)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unTotalMinutesPlayed) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GSGameplayStats_t),
            "::",
            stringify!(m_unTotalMinutesPlayed)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GSClientGroupStatus_t {
    pub m_SteamIDUser: CSteamID,
    pub m_SteamIDGroup: CSteamID,
    pub m_bMember: bool,
    pub m_bOfficer: bool,
}
pub const GSClientGroupStatus_t_k_iCallback: GSClientGroupStatus_t__bindgen_ty_1 =
    GSClientGroupStatus_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GSClientGroupStatus_t__bindgen_ty_1 {
    k_iCallback = 208,
}
#[test]
fn bindgen_test_layout_GSClientGroupStatus_t() {
    const UNINIT: ::std::mem::MaybeUninit<GSClientGroupStatus_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GSClientGroupStatus_t>(),
        18usize,
        concat!("Size of: ", stringify!(GSClientGroupStatus_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GSClientGroupStatus_t>(),
        1usize,
        concat!("Alignment of ", stringify!(GSClientGroupStatus_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_SteamIDUser) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GSClientGroupStatus_t),
            "::",
            stringify!(m_SteamIDUser)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_SteamIDGroup) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GSClientGroupStatus_t),
            "::",
            stringify!(m_SteamIDGroup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bMember) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GSClientGroupStatus_t),
            "::",
            stringify!(m_bMember)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bOfficer) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(GSClientGroupStatus_t),
            "::",
            stringify!(m_bOfficer)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct GSReputation_t {
    pub m_eResult: EResult,
    pub m_unReputationScore: uint32,
    pub m_bBanned: bool,
    pub m_unBannedIP: uint32,
    pub m_usBannedPort: uint16,
    pub m_ulBannedGameID: uint64,
    pub m_unBanExpires: uint32,
}
pub const GSReputation_t_k_iCallback: GSReputation_t__bindgen_ty_1 =
    GSReputation_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GSReputation_t__bindgen_ty_1 {
    k_iCallback = 209,
}
#[test]
fn bindgen_test_layout_GSReputation_t() {
    const UNINIT: ::std::mem::MaybeUninit<GSReputation_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GSReputation_t>(),
        32usize,
        concat!("Size of: ", stringify!(GSReputation_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GSReputation_t>(),
        4usize,
        concat!("Alignment of ", stringify!(GSReputation_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GSReputation_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unReputationScore) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GSReputation_t),
            "::",
            stringify!(m_unReputationScore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bBanned) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GSReputation_t),
            "::",
            stringify!(m_bBanned)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unBannedIP) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GSReputation_t),
            "::",
            stringify!(m_unBannedIP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_usBannedPort) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GSReputation_t),
            "::",
            stringify!(m_usBannedPort)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulBannedGameID) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GSReputation_t),
            "::",
            stringify!(m_ulBannedGameID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unBanExpires) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(GSReputation_t),
            "::",
            stringify!(m_unBanExpires)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AssociateWithClanResult_t {
    pub m_eResult: EResult,
}
pub const AssociateWithClanResult_t_k_iCallback: AssociateWithClanResult_t__bindgen_ty_1 =
    AssociateWithClanResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AssociateWithClanResult_t__bindgen_ty_1 {
    k_iCallback = 210,
}
#[test]
fn bindgen_test_layout_AssociateWithClanResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<AssociateWithClanResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AssociateWithClanResult_t>(),
        4usize,
        concat!("Size of: ", stringify!(AssociateWithClanResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<AssociateWithClanResult_t>(),
        4usize,
        concat!("Alignment of ", stringify!(AssociateWithClanResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AssociateWithClanResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ComputeNewPlayerCompatibilityResult_t {
    pub m_eResult: EResult,
    pub m_cPlayersThatDontLikeCandidate: ::std::os::raw::c_int,
    pub m_cPlayersThatCandidateDoesntLike: ::std::os::raw::c_int,
    pub m_cClanPlayersThatDontLikeCandidate: ::std::os::raw::c_int,
    pub m_SteamIDCandidate: CSteamID,
}
pub const ComputeNewPlayerCompatibilityResult_t_k_iCallback:
    ComputeNewPlayerCompatibilityResult_t__bindgen_ty_1 =
    ComputeNewPlayerCompatibilityResult_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ComputeNewPlayerCompatibilityResult_t__bindgen_ty_1 {
    k_iCallback = 211,
}
#[test]
fn bindgen_test_layout_ComputeNewPlayerCompatibilityResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<ComputeNewPlayerCompatibilityResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ComputeNewPlayerCompatibilityResult_t>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(ComputeNewPlayerCompatibilityResult_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ComputeNewPlayerCompatibilityResult_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ComputeNewPlayerCompatibilityResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ComputeNewPlayerCompatibilityResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_cPlayersThatDontLikeCandidate) as usize - ptr as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ComputeNewPlayerCompatibilityResult_t),
            "::",
            stringify!(m_cPlayersThatDontLikeCandidate)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_cPlayersThatCandidateDoesntLike) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ComputeNewPlayerCompatibilityResult_t),
            "::",
            stringify!(m_cPlayersThatCandidateDoesntLike)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_cClanPlayersThatDontLikeCandidate) as usize - ptr as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ComputeNewPlayerCompatibilityResult_t),
            "::",
            stringify!(m_cClanPlayersThatDontLikeCandidate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_SteamIDCandidate) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ComputeNewPlayerCompatibilityResult_t),
            "::",
            stringify!(m_SteamIDCandidate)
        )
    );
}
#[repr(C)]
pub struct ISteamGameServerStats__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamGameServerStats {
    pub vtable_: *const ISteamGameServerStats__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamGameServerStats() {
    assert_eq!(
        ::std::mem::size_of::<ISteamGameServerStats>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamGameServerStats))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamGameServerStats>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamGameServerStats))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GSStatsReceived_t {
    pub m_eResult: EResult,
    pub m_steamIDUser: CSteamID,
}
pub const GSStatsReceived_t_k_iCallback: GSStatsReceived_t__bindgen_ty_1 =
    GSStatsReceived_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GSStatsReceived_t__bindgen_ty_1 {
    k_iCallback = 1800,
}
#[test]
fn bindgen_test_layout_GSStatsReceived_t() {
    const UNINIT: ::std::mem::MaybeUninit<GSStatsReceived_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GSStatsReceived_t>(),
        12usize,
        concat!("Size of: ", stringify!(GSStatsReceived_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GSStatsReceived_t>(),
        4usize,
        concat!("Alignment of ", stringify!(GSStatsReceived_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GSStatsReceived_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDUser) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GSStatsReceived_t),
            "::",
            stringify!(m_steamIDUser)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GSStatsStored_t {
    pub m_eResult: EResult,
    pub m_steamIDUser: CSteamID,
}
pub const GSStatsStored_t_k_iCallback: GSStatsStored_t__bindgen_ty_1 =
    GSStatsStored_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GSStatsStored_t__bindgen_ty_1 {
    k_iCallback = 1801,
}
#[test]
fn bindgen_test_layout_GSStatsStored_t() {
    const UNINIT: ::std::mem::MaybeUninit<GSStatsStored_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GSStatsStored_t>(),
        12usize,
        concat!("Size of: ", stringify!(GSStatsStored_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GSStatsStored_t>(),
        4usize,
        concat!("Alignment of ", stringify!(GSStatsStored_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GSStatsStored_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDUser) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GSStatsStored_t),
            "::",
            stringify!(m_steamIDUser)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GSStatsUnloaded_t {
    pub m_steamIDUser: CSteamID,
}
pub const GSStatsUnloaded_t_k_iCallback: GSStatsUnloaded_t__bindgen_ty_1 =
    GSStatsUnloaded_t__bindgen_ty_1::k_iCallback;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GSStatsUnloaded_t__bindgen_ty_1 {
    k_iCallback = 1108,
}
#[test]
fn bindgen_test_layout_GSStatsUnloaded_t() {
    const UNINIT: ::std::mem::MaybeUninit<GSStatsUnloaded_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GSStatsUnloaded_t>(),
        8usize,
        concat!("Size of: ", stringify!(GSStatsUnloaded_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GSStatsUnloaded_t>(),
        1usize,
        concat!("Alignment of ", stringify!(GSStatsUnloaded_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDUser) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GSStatsUnloaded_t),
            "::",
            stringify!(m_steamIDUser)
        )
    );
}
pub type uint64_steamid = uint64;
pub type uint64_gameid = uint64;
extern "C" {
    pub fn SteamAPI_ISteamClient_CreateSteamPipe(self_: *mut ISteamClient) -> HSteamPipe;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_BReleaseSteamPipe(
        self_: *mut ISteamClient,
        hSteamPipe: HSteamPipe,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_ConnectToGlobalUser(
        self_: *mut ISteamClient,
        hSteamPipe: HSteamPipe,
    ) -> HSteamUser;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_CreateLocalUser(
        self_: *mut ISteamClient,
        phSteamPipe: *mut HSteamPipe,
        eAccountType: EAccountType,
    ) -> HSteamUser;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_ReleaseUser(
        self_: *mut ISteamClient,
        hSteamPipe: HSteamPipe,
        hUser: HSteamUser,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamUser(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamUser;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamGameServer(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamGameServer;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_SetLocalIPBinding(
        self_: *mut ISteamClient,
        unIP: *const SteamIPAddress_t,
        usPort: uint16,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamFriends(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamFriends;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamUtils(
        self_: *mut ISteamClient,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamUtils;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamMatchmaking(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamMatchmaking;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamMatchmakingServers(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamMatchmakingServers;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamGenericInterface(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamUserStats(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamUserStats;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamGameServerStats(
        self_: *mut ISteamClient,
        hSteamuser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamGameServerStats;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamApps(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamApps;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamNetworking(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamNetworking;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamRemoteStorage(
        self_: *mut ISteamClient,
        hSteamuser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamRemoteStorage;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamScreenshots(
        self_: *mut ISteamClient,
        hSteamuser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamScreenshots;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamGameSearch(
        self_: *mut ISteamClient,
        hSteamuser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamGameSearch;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetIPCCallCount(self_: *mut ISteamClient) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_SetWarningMessageHook(
        self_: *mut ISteamClient,
        pFunction: SteamAPIWarningMessageHook_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamClient_BShutdownIfAllPipesClosed(self_: *mut ISteamClient) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamHTTP(
        self_: *mut ISteamClient,
        hSteamuser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamHTTP;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamController(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamController;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamUGC(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamUGC;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamMusic(
        self_: *mut ISteamClient,
        hSteamuser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamMusic;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamMusicRemote(
        self_: *mut ISteamClient,
        hSteamuser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamMusicRemote;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamHTMLSurface(
        self_: *mut ISteamClient,
        hSteamuser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamHTMLSurface;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamInventory(
        self_: *mut ISteamClient,
        hSteamuser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamInventory;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamVideo(
        self_: *mut ISteamClient,
        hSteamuser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamVideo;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamParentalSettings(
        self_: *mut ISteamClient,
        hSteamuser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamParentalSettings;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamInput(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamInput;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamParties(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamParties;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamRemotePlay(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamRemotePlay;
}
extern "C" {
    pub fn SteamAPI_SteamUser_v023() -> *mut ISteamUser;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetHSteamUser(self_: *mut ISteamUser) -> HSteamUser;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_BLoggedOn(self_: *mut ISteamUser) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetSteamID(self_: *mut ISteamUser) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_InitiateGameConnection_DEPRECATED(
        self_: *mut ISteamUser,
        pAuthBlob: *mut ::std::os::raw::c_void,
        cbMaxAuthBlob: ::std::os::raw::c_int,
        steamIDGameServer: uint64_steamid,
        unIPServer: uint32,
        usPortServer: uint16,
        bSecure: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_TerminateGameConnection_DEPRECATED(
        self_: *mut ISteamUser,
        unIPServer: uint32,
        usPortServer: uint16,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamUser_TrackAppUsageEvent(
        self_: *mut ISteamUser,
        gameID: uint64_gameid,
        eAppUsageEvent: ::std::os::raw::c_int,
        pchExtraInfo: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetUserDataFolder(
        self_: *mut ISteamUser,
        pchBuffer: *mut ::std::os::raw::c_char,
        cubBuffer: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_StartVoiceRecording(self_: *mut ISteamUser);
}
extern "C" {
    pub fn SteamAPI_ISteamUser_StopVoiceRecording(self_: *mut ISteamUser);
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetAvailableVoice(
        self_: *mut ISteamUser,
        pcbCompressed: *mut uint32,
        pcbUncompressed_Deprecated: *mut uint32,
        nUncompressedVoiceDesiredSampleRate_Deprecated: uint32,
    ) -> EVoiceResult;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetVoice(
        self_: *mut ISteamUser,
        bWantCompressed: bool,
        pDestBuffer: *mut ::std::os::raw::c_void,
        cbDestBufferSize: uint32,
        nBytesWritten: *mut uint32,
        bWantUncompressed_Deprecated: bool,
        pUncompressedDestBuffer_Deprecated: *mut ::std::os::raw::c_void,
        cbUncompressedDestBufferSize_Deprecated: uint32,
        nUncompressBytesWritten_Deprecated: *mut uint32,
        nUncompressedVoiceDesiredSampleRate_Deprecated: uint32,
    ) -> EVoiceResult;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_DecompressVoice(
        self_: *mut ISteamUser,
        pCompressed: *const ::std::os::raw::c_void,
        cbCompressed: uint32,
        pDestBuffer: *mut ::std::os::raw::c_void,
        cbDestBufferSize: uint32,
        nBytesWritten: *mut uint32,
        nDesiredSampleRate: uint32,
    ) -> EVoiceResult;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetVoiceOptimalSampleRate(self_: *mut ISteamUser) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetAuthSessionTicket(
        self_: *mut ISteamUser,
        pTicket: *mut ::std::os::raw::c_void,
        cbMaxTicket: ::std::os::raw::c_int,
        pcbTicket: *mut uint32,
        pSteamNetworkingIdentity: *const SteamNetworkingIdentity,
    ) -> HAuthTicket;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetAuthTicketForWebApi(
        self_: *mut ISteamUser,
        pchIdentity: *const ::std::os::raw::c_char,
    ) -> HAuthTicket;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_BeginAuthSession(
        self_: *mut ISteamUser,
        pAuthTicket: *const ::std::os::raw::c_void,
        cbAuthTicket: ::std::os::raw::c_int,
        steamID: uint64_steamid,
    ) -> EBeginAuthSessionResult;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_EndAuthSession(self_: *mut ISteamUser, steamID: uint64_steamid);
}
extern "C" {
    pub fn SteamAPI_ISteamUser_CancelAuthTicket(self_: *mut ISteamUser, hAuthTicket: HAuthTicket);
}
extern "C" {
    pub fn SteamAPI_ISteamUser_UserHasLicenseForApp(
        self_: *mut ISteamUser,
        steamID: uint64_steamid,
        appID: AppId_t,
    ) -> EUserHasLicenseForAppResult;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_BIsBehindNAT(self_: *mut ISteamUser) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_AdvertiseGame(
        self_: *mut ISteamUser,
        steamIDGameServer: uint64_steamid,
        unIPServer: uint32,
        usPortServer: uint16,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamUser_RequestEncryptedAppTicket(
        self_: *mut ISteamUser,
        pDataToInclude: *mut ::std::os::raw::c_void,
        cbDataToInclude: ::std::os::raw::c_int,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetEncryptedAppTicket(
        self_: *mut ISteamUser,
        pTicket: *mut ::std::os::raw::c_void,
        cbMaxTicket: ::std::os::raw::c_int,
        pcbTicket: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetGameBadgeLevel(
        self_: *mut ISteamUser,
        nSeries: ::std::os::raw::c_int,
        bFoil: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetPlayerSteamLevel(self_: *mut ISteamUser)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_RequestStoreAuthURL(
        self_: *mut ISteamUser,
        pchRedirectURL: *const ::std::os::raw::c_char,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_BIsPhoneVerified(self_: *mut ISteamUser) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_BIsTwoFactorEnabled(self_: *mut ISteamUser) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_BIsPhoneIdentifying(self_: *mut ISteamUser) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_BIsPhoneRequiringVerification(self_: *mut ISteamUser) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetMarketEligibility(self_: *mut ISteamUser) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetDurationControl(self_: *mut ISteamUser) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_BSetDurationControlOnlineState(
        self_: *mut ISteamUser,
        eNewState: EDurationControlOnlineState,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamFriends_v018() -> *mut ISteamFriends;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetPersonaName(
        self_: *mut ISteamFriends,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetPersonaState(self_: *mut ISteamFriends) -> EPersonaState;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendCount(
        self_: *mut ISteamFriends,
        iFriendFlags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendByIndex(
        self_: *mut ISteamFriends,
        iFriend: ::std::os::raw::c_int,
        iFriendFlags: ::std::os::raw::c_int,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendRelationship(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
    ) -> EFriendRelationship;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendPersonaState(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
    ) -> EPersonaState;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendPersonaName(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendGamePlayed(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
        pFriendGameInfo: *mut FriendGameInfo_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendPersonaNameHistory(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
        iPersonaName: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendSteamLevel(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetPlayerNickname(
        self_: *mut ISteamFriends,
        steamIDPlayer: uint64_steamid,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendsGroupCount(
        self_: *mut ISteamFriends,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendsGroupIDByIndex(
        self_: *mut ISteamFriends,
        iFG: ::std::os::raw::c_int,
    ) -> FriendsGroupID_t;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendsGroupName(
        self_: *mut ISteamFriends,
        friendsGroupID: FriendsGroupID_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendsGroupMembersCount(
        self_: *mut ISteamFriends,
        friendsGroupID: FriendsGroupID_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendsGroupMembersList(
        self_: *mut ISteamFriends,
        friendsGroupID: FriendsGroupID_t,
        pOutSteamIDMembers: *mut CSteamID,
        nMembersCount: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_HasFriend(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
        iFriendFlags: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetClanCount(self_: *mut ISteamFriends) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetClanByIndex(
        self_: *mut ISteamFriends,
        iClan: ::std::os::raw::c_int,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetClanName(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetClanTag(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetClanActivityCounts(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
        pnOnline: *mut ::std::os::raw::c_int,
        pnInGame: *mut ::std::os::raw::c_int,
        pnChatting: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_DownloadClanActivityCounts(
        self_: *mut ISteamFriends,
        psteamIDClans: *mut CSteamID,
        cClansToRequest: ::std::os::raw::c_int,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendCountFromSource(
        self_: *mut ISteamFriends,
        steamIDSource: uint64_steamid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendFromSourceByIndex(
        self_: *mut ISteamFriends,
        steamIDSource: uint64_steamid,
        iFriend: ::std::os::raw::c_int,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_IsUserInSource(
        self_: *mut ISteamFriends,
        steamIDUser: uint64_steamid,
        steamIDSource: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_SetInGameVoiceSpeaking(
        self_: *mut ISteamFriends,
        steamIDUser: uint64_steamid,
        bSpeaking: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_ActivateGameOverlay(
        self_: *mut ISteamFriends,
        pchDialog: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_ActivateGameOverlayToUser(
        self_: *mut ISteamFriends,
        pchDialog: *const ::std::os::raw::c_char,
        steamID: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_ActivateGameOverlayToWebPage(
        self_: *mut ISteamFriends,
        pchURL: *const ::std::os::raw::c_char,
        eMode: EActivateGameOverlayToWebPageMode,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_ActivateGameOverlayToStore(
        self_: *mut ISteamFriends,
        nAppID: AppId_t,
        eFlag: EOverlayToStoreFlag,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_SetPlayedWith(
        self_: *mut ISteamFriends,
        steamIDUserPlayedWith: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_ActivateGameOverlayInviteDialog(
        self_: *mut ISteamFriends,
        steamIDLobby: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetSmallFriendAvatar(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetMediumFriendAvatar(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetLargeFriendAvatar(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_RequestUserInformation(
        self_: *mut ISteamFriends,
        steamIDUser: uint64_steamid,
        bRequireNameOnly: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_RequestClanOfficerList(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetClanOwner(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetClanOfficerCount(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetClanOfficerByIndex(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
        iOfficer: ::std::os::raw::c_int,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_SetRichPresence(
        self_: *mut ISteamFriends,
        pchKey: *const ::std::os::raw::c_char,
        pchValue: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_ClearRichPresence(self_: *mut ISteamFriends);
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendRichPresence(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
        pchKey: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendRichPresenceKeyCount(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendRichPresenceKeyByIndex(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
        iKey: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_RequestFriendRichPresence(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_InviteUserToGame(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
        pchConnectString: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetCoplayFriendCount(
        self_: *mut ISteamFriends,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetCoplayFriend(
        self_: *mut ISteamFriends,
        iCoplayFriend: ::std::os::raw::c_int,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendCoplayTime(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendCoplayGame(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
    ) -> AppId_t;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_JoinClanChatRoom(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_LeaveClanChatRoom(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetClanChatMemberCount(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetChatMemberByIndex(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
        iUser: ::std::os::raw::c_int,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_SendClanChatMessage(
        self_: *mut ISteamFriends,
        steamIDClanChat: uint64_steamid,
        pchText: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetClanChatMessage(
        self_: *mut ISteamFriends,
        steamIDClanChat: uint64_steamid,
        iMessage: ::std::os::raw::c_int,
        prgchText: *mut ::std::os::raw::c_void,
        cchTextMax: ::std::os::raw::c_int,
        peChatEntryType: *mut EChatEntryType,
        psteamidChatter: *mut CSteamID,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_IsClanChatAdmin(
        self_: *mut ISteamFriends,
        steamIDClanChat: uint64_steamid,
        steamIDUser: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_IsClanChatWindowOpenInSteam(
        self_: *mut ISteamFriends,
        steamIDClanChat: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_OpenClanChatWindowInSteam(
        self_: *mut ISteamFriends,
        steamIDClanChat: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_CloseClanChatWindowInSteam(
        self_: *mut ISteamFriends,
        steamIDClanChat: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_SetListenForFriendsMessages(
        self_: *mut ISteamFriends,
        bInterceptEnabled: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_ReplyToFriendMessage(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
        pchMsgToSend: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendMessage(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
        iMessageID: ::std::os::raw::c_int,
        pvData: *mut ::std::os::raw::c_void,
        cubData: ::std::os::raw::c_int,
        peChatEntryType: *mut EChatEntryType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFollowerCount(
        self_: *mut ISteamFriends,
        steamID: uint64_steamid,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_IsFollowing(
        self_: *mut ISteamFriends,
        steamID: uint64_steamid,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_EnumerateFollowingList(
        self_: *mut ISteamFriends,
        unStartIndex: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_IsClanPublic(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_IsClanOfficialGameGroup(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetNumChatsWithUnreadPriorityMessages(
        self_: *mut ISteamFriends,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_ActivateGameOverlayRemotePlayTogetherInviteDialog(
        self_: *mut ISteamFriends,
        steamIDLobby: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_RegisterProtocolInOverlayBrowser(
        self_: *mut ISteamFriends,
        pchProtocol: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_ActivateGameOverlayInviteDialogConnectString(
        self_: *mut ISteamFriends,
        pchConnectString: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_RequestEquippedProfileItems(
        self_: *mut ISteamFriends,
        steamID: uint64_steamid,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_BHasEquippedProfileItem(
        self_: *mut ISteamFriends,
        steamID: uint64_steamid,
        itemType: ECommunityProfileItemType,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetProfileItemPropertyString(
        self_: *mut ISteamFriends,
        steamID: uint64_steamid,
        itemType: ECommunityProfileItemType,
        prop: ECommunityProfileItemProperty,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetProfileItemPropertyUint(
        self_: *mut ISteamFriends,
        steamID: uint64_steamid,
        itemType: ECommunityProfileItemType,
        prop: ECommunityProfileItemProperty,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_SteamUtils_v010() -> *mut ISteamUtils;
}
extern "C" {
    pub fn SteamAPI_SteamGameServerUtils_v010() -> *mut ISteamUtils;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetSecondsSinceAppActive(self_: *mut ISteamUtils) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetSecondsSinceComputerActive(self_: *mut ISteamUtils) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetConnectedUniverse(self_: *mut ISteamUtils) -> EUniverse;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetServerRealTime(self_: *mut ISteamUtils) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetIPCountry(
        self_: *mut ISteamUtils,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetImageSize(
        self_: *mut ISteamUtils,
        iImage: ::std::os::raw::c_int,
        pnWidth: *mut uint32,
        pnHeight: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetImageRGBA(
        self_: *mut ISteamUtils,
        iImage: ::std::os::raw::c_int,
        pubDest: *mut uint8,
        nDestBufferSize: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetCurrentBatteryPower(self_: *mut ISteamUtils) -> uint8;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetAppID(self_: *mut ISteamUtils) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_SetOverlayNotificationPosition(
        self_: *mut ISteamUtils,
        eNotificationPosition: ENotificationPosition,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_IsAPICallCompleted(
        self_: *mut ISteamUtils,
        hSteamAPICall: SteamAPICall_t,
        pbFailed: *mut bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetAPICallFailureReason(
        self_: *mut ISteamUtils,
        hSteamAPICall: SteamAPICall_t,
    ) -> ESteamAPICallFailure;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetAPICallResult(
        self_: *mut ISteamUtils,
        hSteamAPICall: SteamAPICall_t,
        pCallback: *mut ::std::os::raw::c_void,
        cubCallback: ::std::os::raw::c_int,
        iCallbackExpected: ::std::os::raw::c_int,
        pbFailed: *mut bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetIPCCallCount(self_: *mut ISteamUtils) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_SetWarningMessageHook(
        self_: *mut ISteamUtils,
        pFunction: SteamAPIWarningMessageHook_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_IsOverlayEnabled(self_: *mut ISteamUtils) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_BOverlayNeedsPresent(self_: *mut ISteamUtils) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_CheckFileSignature(
        self_: *mut ISteamUtils,
        szFileName: *const ::std::os::raw::c_char,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_ShowGamepadTextInput(
        self_: *mut ISteamUtils,
        eInputMode: EGamepadTextInputMode,
        eLineInputMode: EGamepadTextInputLineMode,
        pchDescription: *const ::std::os::raw::c_char,
        unCharMax: uint32,
        pchExistingText: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetEnteredGamepadTextLength(self_: *mut ISteamUtils) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetEnteredGamepadTextInput(
        self_: *mut ISteamUtils,
        pchText: *mut ::std::os::raw::c_char,
        cchText: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetSteamUILanguage(
        self_: *mut ISteamUtils,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_IsSteamRunningInVR(self_: *mut ISteamUtils) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_SetOverlayNotificationInset(
        self_: *mut ISteamUtils,
        nHorizontalInset: ::std::os::raw::c_int,
        nVerticalInset: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_IsSteamInBigPictureMode(self_: *mut ISteamUtils) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_StartVRDashboard(self_: *mut ISteamUtils);
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_IsVRHeadsetStreamingEnabled(self_: *mut ISteamUtils) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_SetVRHeadsetStreamingEnabled(
        self_: *mut ISteamUtils,
        bEnabled: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_IsSteamChinaLauncher(self_: *mut ISteamUtils) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_InitFilterText(
        self_: *mut ISteamUtils,
        unFilterOptions: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_FilterText(
        self_: *mut ISteamUtils,
        eContext: ETextFilteringContext,
        sourceSteamID: uint64_steamid,
        pchInputMessage: *const ::std::os::raw::c_char,
        pchOutFilteredText: *mut ::std::os::raw::c_char,
        nByteSizeOutFilteredText: uint32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetIPv6ConnectivityState(
        self_: *mut ISteamUtils,
        eProtocol: ESteamIPv6ConnectivityProtocol,
    ) -> ESteamIPv6ConnectivityState;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_IsSteamRunningOnSteamDeck(self_: *mut ISteamUtils) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_ShowFloatingGamepadTextInput(
        self_: *mut ISteamUtils,
        eKeyboardMode: EFloatingGamepadTextInputMode,
        nTextFieldXPosition: ::std::os::raw::c_int,
        nTextFieldYPosition: ::std::os::raw::c_int,
        nTextFieldWidth: ::std::os::raw::c_int,
        nTextFieldHeight: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_SetGameLauncherMode(self_: *mut ISteamUtils, bLauncherMode: bool);
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_DismissFloatingGamepadTextInput(self_: *mut ISteamUtils) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_DismissGamepadTextInput(self_: *mut ISteamUtils) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamMatchmaking_v009() -> *mut ISteamMatchmaking;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetFavoriteGameCount(
        self_: *mut ISteamMatchmaking,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetFavoriteGame(
        self_: *mut ISteamMatchmaking,
        iGame: ::std::os::raw::c_int,
        pnAppID: *mut AppId_t,
        pnIP: *mut uint32,
        pnConnPort: *mut uint16,
        pnQueryPort: *mut uint16,
        punFlags: *mut uint32,
        pRTime32LastPlayedOnServer: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_AddFavoriteGame(
        self_: *mut ISteamMatchmaking,
        nAppID: AppId_t,
        nIP: uint32,
        nConnPort: uint16,
        nQueryPort: uint16,
        unFlags: uint32,
        rTime32LastPlayedOnServer: uint32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_RemoveFavoriteGame(
        self_: *mut ISteamMatchmaking,
        nAppID: AppId_t,
        nIP: uint32,
        nConnPort: uint16,
        nQueryPort: uint16,
        unFlags: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_RequestLobbyList(
        self_: *mut ISteamMatchmaking,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_AddRequestLobbyListStringFilter(
        self_: *mut ISteamMatchmaking,
        pchKeyToMatch: *const ::std::os::raw::c_char,
        pchValueToMatch: *const ::std::os::raw::c_char,
        eComparisonType: ELobbyComparison,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_AddRequestLobbyListNumericalFilter(
        self_: *mut ISteamMatchmaking,
        pchKeyToMatch: *const ::std::os::raw::c_char,
        nValueToMatch: ::std::os::raw::c_int,
        eComparisonType: ELobbyComparison,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_AddRequestLobbyListNearValueFilter(
        self_: *mut ISteamMatchmaking,
        pchKeyToMatch: *const ::std::os::raw::c_char,
        nValueToBeCloseTo: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_AddRequestLobbyListFilterSlotsAvailable(
        self_: *mut ISteamMatchmaking,
        nSlotsAvailable: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_AddRequestLobbyListDistanceFilter(
        self_: *mut ISteamMatchmaking,
        eLobbyDistanceFilter: ELobbyDistanceFilter,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_AddRequestLobbyListResultCountFilter(
        self_: *mut ISteamMatchmaking,
        cMaxResults: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_AddRequestLobbyListCompatibleMembersFilter(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetLobbyByIndex(
        self_: *mut ISteamMatchmaking,
        iLobby: ::std::os::raw::c_int,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_CreateLobby(
        self_: *mut ISteamMatchmaking,
        eLobbyType: ELobbyType,
        cMaxMembers: ::std::os::raw::c_int,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_JoinLobby(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_LeaveLobby(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_InviteUserToLobby(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        steamIDInvitee: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetNumLobbyMembers(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetLobbyMemberByIndex(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        iMember: ::std::os::raw::c_int,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetLobbyData(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        pchKey: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_SetLobbyData(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        pchKey: *const ::std::os::raw::c_char,
        pchValue: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetLobbyDataCount(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetLobbyDataByIndex(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        iLobbyData: ::std::os::raw::c_int,
        pchKey: *mut ::std::os::raw::c_char,
        cchKeyBufferSize: ::std::os::raw::c_int,
        pchValue: *mut ::std::os::raw::c_char,
        cchValueBufferSize: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_DeleteLobbyData(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        pchKey: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetLobbyMemberData(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        steamIDUser: uint64_steamid,
        pchKey: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_SetLobbyMemberData(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        pchKey: *const ::std::os::raw::c_char,
        pchValue: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_SendLobbyChatMsg(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        pvMsgBody: *const ::std::os::raw::c_void,
        cubMsgBody: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetLobbyChatEntry(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        iChatID: ::std::os::raw::c_int,
        pSteamIDUser: *mut CSteamID,
        pvData: *mut ::std::os::raw::c_void,
        cubData: ::std::os::raw::c_int,
        peChatEntryType: *mut EChatEntryType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_RequestLobbyData(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_SetLobbyGameServer(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        unGameServerIP: uint32,
        unGameServerPort: uint16,
        steamIDGameServer: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetLobbyGameServer(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        punGameServerIP: *mut uint32,
        punGameServerPort: *mut uint16,
        psteamIDGameServer: *mut CSteamID,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_SetLobbyMemberLimit(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        cMaxMembers: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetLobbyMemberLimit(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_SetLobbyType(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        eLobbyType: ELobbyType,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_SetLobbyJoinable(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        bLobbyJoinable: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetLobbyOwner(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_SetLobbyOwner(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        steamIDNewOwner: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_SetLinkedLobby(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        steamIDLobbyDependent: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServerListResponse_ServerResponded(
        self_: *mut ISteamMatchmakingServerListResponse,
        hRequest: HServerListRequest,
        iServer: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServerListResponse_ServerFailedToRespond(
        self_: *mut ISteamMatchmakingServerListResponse,
        hRequest: HServerListRequest,
        iServer: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServerListResponse_RefreshComplete(
        self_: *mut ISteamMatchmakingServerListResponse,
        hRequest: HServerListRequest,
        response: EMatchMakingServerResponse,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingPingResponse_ServerResponded(
        self_: *mut ISteamMatchmakingPingResponse,
        server: *mut gameserveritem_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingPingResponse_ServerFailedToRespond(
        self_: *mut ISteamMatchmakingPingResponse,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingPlayersResponse_AddPlayerToList(
        self_: *mut ISteamMatchmakingPlayersResponse,
        pchName: *const ::std::os::raw::c_char,
        nScore: ::std::os::raw::c_int,
        flTimePlayed: f32,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingPlayersResponse_PlayersFailedToRespond(
        self_: *mut ISteamMatchmakingPlayersResponse,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingPlayersResponse_PlayersRefreshComplete(
        self_: *mut ISteamMatchmakingPlayersResponse,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingRulesResponse_RulesResponded(
        self_: *mut ISteamMatchmakingRulesResponse,
        pchRule: *const ::std::os::raw::c_char,
        pchValue: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingRulesResponse_RulesFailedToRespond(
        self_: *mut ISteamMatchmakingRulesResponse,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingRulesResponse_RulesRefreshComplete(
        self_: *mut ISteamMatchmakingRulesResponse,
    );
}
extern "C" {
    pub fn SteamAPI_SteamMatchmakingServers_v002() -> *mut ISteamMatchmakingServers;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_RequestInternetServerList(
        self_: *mut ISteamMatchmakingServers,
        iApp: AppId_t,
        ppchFilters: *mut *mut MatchMakingKeyValuePair_t,
        nFilters: uint32,
        pRequestServersResponse: *mut ISteamMatchmakingServerListResponse,
    ) -> HServerListRequest;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_RequestLANServerList(
        self_: *mut ISteamMatchmakingServers,
        iApp: AppId_t,
        pRequestServersResponse: *mut ISteamMatchmakingServerListResponse,
    ) -> HServerListRequest;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_RequestFriendsServerList(
        self_: *mut ISteamMatchmakingServers,
        iApp: AppId_t,
        ppchFilters: *mut *mut MatchMakingKeyValuePair_t,
        nFilters: uint32,
        pRequestServersResponse: *mut ISteamMatchmakingServerListResponse,
    ) -> HServerListRequest;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_RequestFavoritesServerList(
        self_: *mut ISteamMatchmakingServers,
        iApp: AppId_t,
        ppchFilters: *mut *mut MatchMakingKeyValuePair_t,
        nFilters: uint32,
        pRequestServersResponse: *mut ISteamMatchmakingServerListResponse,
    ) -> HServerListRequest;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_RequestHistoryServerList(
        self_: *mut ISteamMatchmakingServers,
        iApp: AppId_t,
        ppchFilters: *mut *mut MatchMakingKeyValuePair_t,
        nFilters: uint32,
        pRequestServersResponse: *mut ISteamMatchmakingServerListResponse,
    ) -> HServerListRequest;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_RequestSpectatorServerList(
        self_: *mut ISteamMatchmakingServers,
        iApp: AppId_t,
        ppchFilters: *mut *mut MatchMakingKeyValuePair_t,
        nFilters: uint32,
        pRequestServersResponse: *mut ISteamMatchmakingServerListResponse,
    ) -> HServerListRequest;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_ReleaseRequest(
        self_: *mut ISteamMatchmakingServers,
        hServerListRequest: HServerListRequest,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_GetServerDetails(
        self_: *mut ISteamMatchmakingServers,
        hRequest: HServerListRequest,
        iServer: ::std::os::raw::c_int,
    ) -> *mut gameserveritem_t;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_CancelQuery(
        self_: *mut ISteamMatchmakingServers,
        hRequest: HServerListRequest,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_RefreshQuery(
        self_: *mut ISteamMatchmakingServers,
        hRequest: HServerListRequest,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_IsRefreshing(
        self_: *mut ISteamMatchmakingServers,
        hRequest: HServerListRequest,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_GetServerCount(
        self_: *mut ISteamMatchmakingServers,
        hRequest: HServerListRequest,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_RefreshServer(
        self_: *mut ISteamMatchmakingServers,
        hRequest: HServerListRequest,
        iServer: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_PingServer(
        self_: *mut ISteamMatchmakingServers,
        unIP: uint32,
        usPort: uint16,
        pRequestServersResponse: *mut ISteamMatchmakingPingResponse,
    ) -> HServerQuery;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_PlayerDetails(
        self_: *mut ISteamMatchmakingServers,
        unIP: uint32,
        usPort: uint16,
        pRequestServersResponse: *mut ISteamMatchmakingPlayersResponse,
    ) -> HServerQuery;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_ServerRules(
        self_: *mut ISteamMatchmakingServers,
        unIP: uint32,
        usPort: uint16,
        pRequestServersResponse: *mut ISteamMatchmakingRulesResponse,
    ) -> HServerQuery;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_CancelServerQuery(
        self_: *mut ISteamMatchmakingServers,
        hServerQuery: HServerQuery,
    );
}
extern "C" {
    pub fn SteamAPI_SteamGameSearch_v001() -> *mut ISteamGameSearch;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_AddGameSearchParams(
        self_: *mut ISteamGameSearch,
        pchKeyToFind: *const ::std::os::raw::c_char,
        pchValuesToFind: *const ::std::os::raw::c_char,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_SearchForGameWithLobby(
        self_: *mut ISteamGameSearch,
        steamIDLobby: uint64_steamid,
        nPlayerMin: ::std::os::raw::c_int,
        nPlayerMax: ::std::os::raw::c_int,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_SearchForGameSolo(
        self_: *mut ISteamGameSearch,
        nPlayerMin: ::std::os::raw::c_int,
        nPlayerMax: ::std::os::raw::c_int,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_AcceptGame(
        self_: *mut ISteamGameSearch,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_DeclineGame(
        self_: *mut ISteamGameSearch,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_RetrieveConnectionDetails(
        self_: *mut ISteamGameSearch,
        steamIDHost: uint64_steamid,
        pchConnectionDetails: *mut ::std::os::raw::c_char,
        cubConnectionDetails: ::std::os::raw::c_int,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_EndGameSearch(
        self_: *mut ISteamGameSearch,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_SetGameHostParams(
        self_: *mut ISteamGameSearch,
        pchKey: *const ::std::os::raw::c_char,
        pchValue: *const ::std::os::raw::c_char,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_SetConnectionDetails(
        self_: *mut ISteamGameSearch,
        pchConnectionDetails: *const ::std::os::raw::c_char,
        cubConnectionDetails: ::std::os::raw::c_int,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_RequestPlayersForGame(
        self_: *mut ISteamGameSearch,
        nPlayerMin: ::std::os::raw::c_int,
        nPlayerMax: ::std::os::raw::c_int,
        nMaxTeamSize: ::std::os::raw::c_int,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_HostConfirmGameStart(
        self_: *mut ISteamGameSearch,
        ullUniqueGameID: uint64,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_CancelRequestPlayersForGame(
        self_: *mut ISteamGameSearch,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_SubmitPlayerResult(
        self_: *mut ISteamGameSearch,
        ullUniqueGameID: uint64,
        steamIDPlayer: uint64_steamid,
        EPlayerResult: EPlayerResult_t,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_EndGame(
        self_: *mut ISteamGameSearch,
        ullUniqueGameID: uint64,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_SteamParties_v002() -> *mut ISteamParties;
}
extern "C" {
    pub fn SteamAPI_ISteamParties_GetNumActiveBeacons(self_: *mut ISteamParties) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamParties_GetBeaconByIndex(
        self_: *mut ISteamParties,
        unIndex: uint32,
    ) -> PartyBeaconID_t;
}
extern "C" {
    pub fn SteamAPI_ISteamParties_GetBeaconDetails(
        self_: *mut ISteamParties,
        ulBeaconID: PartyBeaconID_t,
        pSteamIDBeaconOwner: *mut CSteamID,
        pLocation: *mut SteamPartyBeaconLocation_t,
        pchMetadata: *mut ::std::os::raw::c_char,
        cchMetadata: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamParties_JoinParty(
        self_: *mut ISteamParties,
        ulBeaconID: PartyBeaconID_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamParties_GetNumAvailableBeaconLocations(
        self_: *mut ISteamParties,
        puNumLocations: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamParties_GetAvailableBeaconLocations(
        self_: *mut ISteamParties,
        pLocationList: *mut SteamPartyBeaconLocation_t,
        uMaxNumLocations: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamParties_CreateBeacon(
        self_: *mut ISteamParties,
        unOpenSlots: uint32,
        pBeaconLocation: *mut SteamPartyBeaconLocation_t,
        pchConnectString: *const ::std::os::raw::c_char,
        pchMetadata: *const ::std::os::raw::c_char,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamParties_OnReservationCompleted(
        self_: *mut ISteamParties,
        ulBeacon: PartyBeaconID_t,
        steamIDUser: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamParties_CancelReservation(
        self_: *mut ISteamParties,
        ulBeacon: PartyBeaconID_t,
        steamIDUser: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamParties_ChangeNumOpenSlots(
        self_: *mut ISteamParties,
        ulBeacon: PartyBeaconID_t,
        unOpenSlots: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamParties_DestroyBeacon(
        self_: *mut ISteamParties,
        ulBeacon: PartyBeaconID_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamParties_GetBeaconLocationData(
        self_: *mut ISteamParties,
        BeaconLocation: SteamPartyBeaconLocation_t,
        eData: ESteamPartyBeaconLocationData,
        pchDataStringOut: *mut ::std::os::raw::c_char,
        cchDataStringOut: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamRemoteStorage_v016() -> *mut ISteamRemoteStorage;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileWrite(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
        pvData: *const ::std::os::raw::c_void,
        cubData: int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileRead(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
        pvData: *mut ::std::os::raw::c_void,
        cubDataToRead: int32,
    ) -> int32;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileWriteAsync(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
        pvData: *const ::std::os::raw::c_void,
        cubData: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileReadAsync(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
        nOffset: uint32,
        cubToRead: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileReadAsyncComplete(
        self_: *mut ISteamRemoteStorage,
        hReadCall: SteamAPICall_t,
        pvBuffer: *mut ::std::os::raw::c_void,
        cubToRead: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileForget(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileDelete(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileShare(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_SetSyncPlatforms(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
        eRemoteStoragePlatform: ERemoteStoragePlatform,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileWriteStreamOpen(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
    ) -> UGCFileWriteStreamHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileWriteStreamWriteChunk(
        self_: *mut ISteamRemoteStorage,
        writeHandle: UGCFileWriteStreamHandle_t,
        pvData: *const ::std::os::raw::c_void,
        cubData: int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileWriteStreamClose(
        self_: *mut ISteamRemoteStorage,
        writeHandle: UGCFileWriteStreamHandle_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileWriteStreamCancel(
        self_: *mut ISteamRemoteStorage,
        writeHandle: UGCFileWriteStreamHandle_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileExists(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FilePersisted(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetFileSize(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
    ) -> int32;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetFileTimestamp(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
    ) -> int64;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetSyncPlatforms(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
    ) -> ERemoteStoragePlatform;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetFileCount(self_: *mut ISteamRemoteStorage) -> int32;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetFileNameAndSize(
        self_: *mut ISteamRemoteStorage,
        iFile: ::std::os::raw::c_int,
        pnFileSizeInBytes: *mut int32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetQuota(
        self_: *mut ISteamRemoteStorage,
        pnTotalBytes: *mut uint64,
        puAvailableBytes: *mut uint64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_IsCloudEnabledForAccount(
        self_: *mut ISteamRemoteStorage,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_IsCloudEnabledForApp(
        self_: *mut ISteamRemoteStorage,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_SetCloudEnabledForApp(
        self_: *mut ISteamRemoteStorage,
        bEnabled: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_UGCDownload(
        self_: *mut ISteamRemoteStorage,
        hContent: UGCHandle_t,
        unPriority: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetUGCDownloadProgress(
        self_: *mut ISteamRemoteStorage,
        hContent: UGCHandle_t,
        pnBytesDownloaded: *mut int32,
        pnBytesExpected: *mut int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetUGCDetails(
        self_: *mut ISteamRemoteStorage,
        hContent: UGCHandle_t,
        pnAppID: *mut AppId_t,
        ppchName: *mut *mut ::std::os::raw::c_char,
        pnFileSizeInBytes: *mut int32,
        pSteamIDOwner: *mut CSteamID,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_UGCRead(
        self_: *mut ISteamRemoteStorage,
        hContent: UGCHandle_t,
        pvData: *mut ::std::os::raw::c_void,
        cubDataToRead: int32,
        cOffset: uint32,
        eAction: EUGCReadAction,
    ) -> int32;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetCachedUGCCount(self_: *mut ISteamRemoteStorage)
        -> int32;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetCachedUGCHandle(
        self_: *mut ISteamRemoteStorage,
        iCachedContent: int32,
    ) -> UGCHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_PublishWorkshopFile(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
        pchPreviewFile: *const ::std::os::raw::c_char,
        nConsumerAppId: AppId_t,
        pchTitle: *const ::std::os::raw::c_char,
        pchDescription: *const ::std::os::raw::c_char,
        eVisibility: ERemoteStoragePublishedFileVisibility,
        pTags: *mut SteamParamStringArray_t,
        eWorkshopFileType: EWorkshopFileType,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_CreatePublishedFileUpdateRequest(
        self_: *mut ISteamRemoteStorage,
        unPublishedFileId: PublishedFileId_t,
    ) -> PublishedFileUpdateHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_UpdatePublishedFileFile(
        self_: *mut ISteamRemoteStorage,
        updateHandle: PublishedFileUpdateHandle_t,
        pchFile: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_UpdatePublishedFilePreviewFile(
        self_: *mut ISteamRemoteStorage,
        updateHandle: PublishedFileUpdateHandle_t,
        pchPreviewFile: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_UpdatePublishedFileTitle(
        self_: *mut ISteamRemoteStorage,
        updateHandle: PublishedFileUpdateHandle_t,
        pchTitle: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_UpdatePublishedFileDescription(
        self_: *mut ISteamRemoteStorage,
        updateHandle: PublishedFileUpdateHandle_t,
        pchDescription: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_UpdatePublishedFileVisibility(
        self_: *mut ISteamRemoteStorage,
        updateHandle: PublishedFileUpdateHandle_t,
        eVisibility: ERemoteStoragePublishedFileVisibility,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_UpdatePublishedFileTags(
        self_: *mut ISteamRemoteStorage,
        updateHandle: PublishedFileUpdateHandle_t,
        pTags: *mut SteamParamStringArray_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_CommitPublishedFileUpdate(
        self_: *mut ISteamRemoteStorage,
        updateHandle: PublishedFileUpdateHandle_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetPublishedFileDetails(
        self_: *mut ISteamRemoteStorage,
        unPublishedFileId: PublishedFileId_t,
        unMaxSecondsOld: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_DeletePublishedFile(
        self_: *mut ISteamRemoteStorage,
        unPublishedFileId: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_EnumerateUserPublishedFiles(
        self_: *mut ISteamRemoteStorage,
        unStartIndex: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_SubscribePublishedFile(
        self_: *mut ISteamRemoteStorage,
        unPublishedFileId: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_EnumerateUserSubscribedFiles(
        self_: *mut ISteamRemoteStorage,
        unStartIndex: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_UnsubscribePublishedFile(
        self_: *mut ISteamRemoteStorage,
        unPublishedFileId: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_UpdatePublishedFileSetChangeDescription(
        self_: *mut ISteamRemoteStorage,
        updateHandle: PublishedFileUpdateHandle_t,
        pchChangeDescription: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetPublishedItemVoteDetails(
        self_: *mut ISteamRemoteStorage,
        unPublishedFileId: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_UpdateUserPublishedItemVote(
        self_: *mut ISteamRemoteStorage,
        unPublishedFileId: PublishedFileId_t,
        bVoteUp: bool,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetUserPublishedItemVoteDetails(
        self_: *mut ISteamRemoteStorage,
        unPublishedFileId: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_EnumerateUserSharedWorkshopFiles(
        self_: *mut ISteamRemoteStorage,
        steamId: uint64_steamid,
        unStartIndex: uint32,
        pRequiredTags: *mut SteamParamStringArray_t,
        pExcludedTags: *mut SteamParamStringArray_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_PublishVideo(
        self_: *mut ISteamRemoteStorage,
        eVideoProvider: EWorkshopVideoProvider,
        pchVideoAccount: *const ::std::os::raw::c_char,
        pchVideoIdentifier: *const ::std::os::raw::c_char,
        pchPreviewFile: *const ::std::os::raw::c_char,
        nConsumerAppId: AppId_t,
        pchTitle: *const ::std::os::raw::c_char,
        pchDescription: *const ::std::os::raw::c_char,
        eVisibility: ERemoteStoragePublishedFileVisibility,
        pTags: *mut SteamParamStringArray_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_SetUserPublishedFileAction(
        self_: *mut ISteamRemoteStorage,
        unPublishedFileId: PublishedFileId_t,
        eAction: EWorkshopFileAction,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_EnumeratePublishedFilesByUserAction(
        self_: *mut ISteamRemoteStorage,
        eAction: EWorkshopFileAction,
        unStartIndex: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_EnumeratePublishedWorkshopFiles(
        self_: *mut ISteamRemoteStorage,
        eEnumerationType: EWorkshopEnumerationType,
        unStartIndex: uint32,
        unCount: uint32,
        unDays: uint32,
        pTags: *mut SteamParamStringArray_t,
        pUserTags: *mut SteamParamStringArray_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_UGCDownloadToLocation(
        self_: *mut ISteamRemoteStorage,
        hContent: UGCHandle_t,
        pchLocation: *const ::std::os::raw::c_char,
        unPriority: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetLocalFileChangeCount(
        self_: *mut ISteamRemoteStorage,
    ) -> int32;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetLocalFileChange(
        self_: *mut ISteamRemoteStorage,
        iFile: ::std::os::raw::c_int,
        pEChangeType: *mut ERemoteStorageLocalFileChange,
        pEFilePathType: *mut ERemoteStorageFilePathType,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_BeginFileWriteBatch(
        self_: *mut ISteamRemoteStorage,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_EndFileWriteBatch(self_: *mut ISteamRemoteStorage) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamUserStats_v013() -> *mut ISteamUserStats;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetStatInt32(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
        pData: *mut int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetStatFloat(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
        pData: *mut f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_SetStatInt32(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
        nData: int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_SetStatFloat(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
        fData: f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_UpdateAvgRateStat(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
        flCountThisSession: f32,
        dSessionLength: f64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetAchievement(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
        pbAchieved: *mut bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_SetAchievement(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_ClearAchievement(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetAchievementAndUnlockTime(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
        pbAchieved: *mut bool,
        punUnlockTime: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_StoreStats(self_: *mut ISteamUserStats) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetAchievementIcon(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetAchievementDisplayAttribute(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
        pchKey: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_IndicateAchievementProgress(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
        nCurProgress: uint32,
        nMaxProgress: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetNumAchievements(self_: *mut ISteamUserStats) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetAchievementName(
        self_: *mut ISteamUserStats,
        iAchievement: uint32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_RequestUserStats(
        self_: *mut ISteamUserStats,
        steamIDUser: uint64_steamid,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetUserStatInt32(
        self_: *mut ISteamUserStats,
        steamIDUser: uint64_steamid,
        pchName: *const ::std::os::raw::c_char,
        pData: *mut int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetUserStatFloat(
        self_: *mut ISteamUserStats,
        steamIDUser: uint64_steamid,
        pchName: *const ::std::os::raw::c_char,
        pData: *mut f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetUserAchievement(
        self_: *mut ISteamUserStats,
        steamIDUser: uint64_steamid,
        pchName: *const ::std::os::raw::c_char,
        pbAchieved: *mut bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetUserAchievementAndUnlockTime(
        self_: *mut ISteamUserStats,
        steamIDUser: uint64_steamid,
        pchName: *const ::std::os::raw::c_char,
        pbAchieved: *mut bool,
        punUnlockTime: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_ResetAllStats(
        self_: *mut ISteamUserStats,
        bAchievementsToo: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_FindOrCreateLeaderboard(
        self_: *mut ISteamUserStats,
        pchLeaderboardName: *const ::std::os::raw::c_char,
        eLeaderboardSortMethod: ELeaderboardSortMethod,
        eLeaderboardDisplayType: ELeaderboardDisplayType,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_FindLeaderboard(
        self_: *mut ISteamUserStats,
        pchLeaderboardName: *const ::std::os::raw::c_char,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetLeaderboardName(
        self_: *mut ISteamUserStats,
        hSteamLeaderboard: SteamLeaderboard_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetLeaderboardEntryCount(
        self_: *mut ISteamUserStats,
        hSteamLeaderboard: SteamLeaderboard_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetLeaderboardSortMethod(
        self_: *mut ISteamUserStats,
        hSteamLeaderboard: SteamLeaderboard_t,
    ) -> ELeaderboardSortMethod;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetLeaderboardDisplayType(
        self_: *mut ISteamUserStats,
        hSteamLeaderboard: SteamLeaderboard_t,
    ) -> ELeaderboardDisplayType;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_DownloadLeaderboardEntries(
        self_: *mut ISteamUserStats,
        hSteamLeaderboard: SteamLeaderboard_t,
        eLeaderboardDataRequest: ELeaderboardDataRequest,
        nRangeStart: ::std::os::raw::c_int,
        nRangeEnd: ::std::os::raw::c_int,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_DownloadLeaderboardEntriesForUsers(
        self_: *mut ISteamUserStats,
        hSteamLeaderboard: SteamLeaderboard_t,
        prgUsers: *mut CSteamID,
        cUsers: ::std::os::raw::c_int,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetDownloadedLeaderboardEntry(
        self_: *mut ISteamUserStats,
        hSteamLeaderboardEntries: SteamLeaderboardEntries_t,
        index: ::std::os::raw::c_int,
        pLeaderboardEntry: *mut LeaderboardEntry_t,
        pDetails: *mut int32,
        cDetailsMax: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_UploadLeaderboardScore(
        self_: *mut ISteamUserStats,
        hSteamLeaderboard: SteamLeaderboard_t,
        eLeaderboardUploadScoreMethod: ELeaderboardUploadScoreMethod,
        nScore: int32,
        pScoreDetails: *const int32,
        cScoreDetailsCount: ::std::os::raw::c_int,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_AttachLeaderboardUGC(
        self_: *mut ISteamUserStats,
        hSteamLeaderboard: SteamLeaderboard_t,
        hUGC: UGCHandle_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetNumberOfCurrentPlayers(
        self_: *mut ISteamUserStats,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_RequestGlobalAchievementPercentages(
        self_: *mut ISteamUserStats,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetMostAchievedAchievementInfo(
        self_: *mut ISteamUserStats,
        pchName: *mut ::std::os::raw::c_char,
        unNameBufLen: uint32,
        pflPercent: *mut f32,
        pbAchieved: *mut bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetNextMostAchievedAchievementInfo(
        self_: *mut ISteamUserStats,
        iIteratorPrevious: ::std::os::raw::c_int,
        pchName: *mut ::std::os::raw::c_char,
        unNameBufLen: uint32,
        pflPercent: *mut f32,
        pbAchieved: *mut bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetAchievementAchievedPercent(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
        pflPercent: *mut f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_RequestGlobalStats(
        self_: *mut ISteamUserStats,
        nHistoryDays: ::std::os::raw::c_int,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetGlobalStatInt64(
        self_: *mut ISteamUserStats,
        pchStatName: *const ::std::os::raw::c_char,
        pData: *mut int64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetGlobalStatDouble(
        self_: *mut ISteamUserStats,
        pchStatName: *const ::std::os::raw::c_char,
        pData: *mut f64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetGlobalStatHistoryInt64(
        self_: *mut ISteamUserStats,
        pchStatName: *const ::std::os::raw::c_char,
        pData: *mut int64,
        cubData: uint32,
    ) -> int32;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetGlobalStatHistoryDouble(
        self_: *mut ISteamUserStats,
        pchStatName: *const ::std::os::raw::c_char,
        pData: *mut f64,
        cubData: uint32,
    ) -> int32;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetAchievementProgressLimitsInt32(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
        pnMinProgress: *mut int32,
        pnMaxProgress: *mut int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetAchievementProgressLimitsFloat(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
        pfMinProgress: *mut f32,
        pfMaxProgress: *mut f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamApps_v008() -> *mut ISteamApps;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_BIsSubscribed(self_: *mut ISteamApps) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_BIsLowViolence(self_: *mut ISteamApps) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_BIsCybercafe(self_: *mut ISteamApps) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_BIsVACBanned(self_: *mut ISteamApps) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetCurrentGameLanguage(
        self_: *mut ISteamApps,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetAvailableGameLanguages(
        self_: *mut ISteamApps,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_BIsSubscribedApp(self_: *mut ISteamApps, appID: AppId_t) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_BIsDlcInstalled(self_: *mut ISteamApps, appID: AppId_t) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetEarliestPurchaseUnixTime(
        self_: *mut ISteamApps,
        nAppID: AppId_t,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_BIsSubscribedFromFreeWeekend(self_: *mut ISteamApps) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetDLCCount(self_: *mut ISteamApps) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_BGetDLCDataByIndex(
        self_: *mut ISteamApps,
        iDLC: ::std::os::raw::c_int,
        pAppID: *mut AppId_t,
        pbAvailable: *mut bool,
        pchName: *mut ::std::os::raw::c_char,
        cchNameBufferSize: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_InstallDLC(self_: *mut ISteamApps, nAppID: AppId_t);
}
extern "C" {
    pub fn SteamAPI_ISteamApps_UninstallDLC(self_: *mut ISteamApps, nAppID: AppId_t);
}
extern "C" {
    pub fn SteamAPI_ISteamApps_RequestAppProofOfPurchaseKey(
        self_: *mut ISteamApps,
        nAppID: AppId_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetCurrentBetaName(
        self_: *mut ISteamApps,
        pchName: *mut ::std::os::raw::c_char,
        cchNameBufferSize: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_MarkContentCorrupt(
        self_: *mut ISteamApps,
        bMissingFilesOnly: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetInstalledDepots(
        self_: *mut ISteamApps,
        appID: AppId_t,
        pvecDepots: *mut DepotId_t,
        cMaxDepots: uint32,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetAppInstallDir(
        self_: *mut ISteamApps,
        appID: AppId_t,
        pchFolder: *mut ::std::os::raw::c_char,
        cchFolderBufferSize: uint32,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_BIsAppInstalled(self_: *mut ISteamApps, appID: AppId_t) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetAppOwner(self_: *mut ISteamApps) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetLaunchQueryParam(
        self_: *mut ISteamApps,
        pchKey: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetDlcDownloadProgress(
        self_: *mut ISteamApps,
        nAppID: AppId_t,
        punBytesDownloaded: *mut uint64,
        punBytesTotal: *mut uint64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetAppBuildId(self_: *mut ISteamApps) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_RequestAllProofOfPurchaseKeys(self_: *mut ISteamApps);
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetFileDetails(
        self_: *mut ISteamApps,
        pszFileName: *const ::std::os::raw::c_char,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetLaunchCommandLine(
        self_: *mut ISteamApps,
        pszCommandLine: *mut ::std::os::raw::c_char,
        cubCommandLine: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_BIsSubscribedFromFamilySharing(self_: *mut ISteamApps) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_BIsTimedTrial(
        self_: *mut ISteamApps,
        punSecondsAllowed: *mut uint32,
        punSecondsPlayed: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_SetDlcContext(self_: *mut ISteamApps, nAppID: AppId_t) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetNumBetas(
        self_: *mut ISteamApps,
        pnAvailable: *mut ::std::os::raw::c_int,
        pnPrivate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetBetaInfo(
        self_: *mut ISteamApps,
        iBetaIndex: ::std::os::raw::c_int,
        punFlags: *mut uint32,
        punBuildID: *mut uint32,
        pchBetaName: *mut ::std::os::raw::c_char,
        cchBetaName: ::std::os::raw::c_int,
        pchDescription: *mut ::std::os::raw::c_char,
        cchDescription: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_SetActiveBeta(
        self_: *mut ISteamApps,
        pchBetaName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworking_v006() -> *mut ISteamNetworking;
}
extern "C" {
    pub fn SteamAPI_SteamGameServerNetworking_v006() -> *mut ISteamNetworking;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_SendP2PPacket(
        self_: *mut ISteamNetworking,
        steamIDRemote: uint64_steamid,
        pubData: *const ::std::os::raw::c_void,
        cubData: uint32,
        eP2PSendType: EP2PSend,
        nChannel: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_IsP2PPacketAvailable(
        self_: *mut ISteamNetworking,
        pcubMsgSize: *mut uint32,
        nChannel: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_ReadP2PPacket(
        self_: *mut ISteamNetworking,
        pubDest: *mut ::std::os::raw::c_void,
        cubDest: uint32,
        pcubMsgSize: *mut uint32,
        psteamIDRemote: *mut CSteamID,
        nChannel: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_AcceptP2PSessionWithUser(
        self_: *mut ISteamNetworking,
        steamIDRemote: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_CloseP2PSessionWithUser(
        self_: *mut ISteamNetworking,
        steamIDRemote: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_CloseP2PChannelWithUser(
        self_: *mut ISteamNetworking,
        steamIDRemote: uint64_steamid,
        nChannel: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_GetP2PSessionState(
        self_: *mut ISteamNetworking,
        steamIDRemote: uint64_steamid,
        pConnectionState: *mut P2PSessionState_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_AllowP2PPacketRelay(
        self_: *mut ISteamNetworking,
        bAllow: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_CreateListenSocket(
        self_: *mut ISteamNetworking,
        nVirtualP2PPort: ::std::os::raw::c_int,
        nIP: SteamIPAddress_t,
        nPort: uint16,
        bAllowUseOfPacketRelay: bool,
    ) -> SNetListenSocket_t;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_CreateP2PConnectionSocket(
        self_: *mut ISteamNetworking,
        steamIDTarget: uint64_steamid,
        nVirtualPort: ::std::os::raw::c_int,
        nTimeoutSec: ::std::os::raw::c_int,
        bAllowUseOfPacketRelay: bool,
    ) -> SNetSocket_t;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_CreateConnectionSocket(
        self_: *mut ISteamNetworking,
        nIP: SteamIPAddress_t,
        nPort: uint16,
        nTimeoutSec: ::std::os::raw::c_int,
    ) -> SNetSocket_t;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_DestroySocket(
        self_: *mut ISteamNetworking,
        hSocket: SNetSocket_t,
        bNotifyRemoteEnd: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_DestroyListenSocket(
        self_: *mut ISteamNetworking,
        hSocket: SNetListenSocket_t,
        bNotifyRemoteEnd: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_SendDataOnSocket(
        self_: *mut ISteamNetworking,
        hSocket: SNetSocket_t,
        pubData: *mut ::std::os::raw::c_void,
        cubData: uint32,
        bReliable: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_IsDataAvailableOnSocket(
        self_: *mut ISteamNetworking,
        hSocket: SNetSocket_t,
        pcubMsgSize: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_RetrieveDataFromSocket(
        self_: *mut ISteamNetworking,
        hSocket: SNetSocket_t,
        pubDest: *mut ::std::os::raw::c_void,
        cubDest: uint32,
        pcubMsgSize: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_IsDataAvailable(
        self_: *mut ISteamNetworking,
        hListenSocket: SNetListenSocket_t,
        pcubMsgSize: *mut uint32,
        phSocket: *mut SNetSocket_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_RetrieveData(
        self_: *mut ISteamNetworking,
        hListenSocket: SNetListenSocket_t,
        pubDest: *mut ::std::os::raw::c_void,
        cubDest: uint32,
        pcubMsgSize: *mut uint32,
        phSocket: *mut SNetSocket_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_GetSocketInfo(
        self_: *mut ISteamNetworking,
        hSocket: SNetSocket_t,
        pSteamIDRemote: *mut CSteamID,
        peSocketStatus: *mut ::std::os::raw::c_int,
        punIPRemote: *mut SteamIPAddress_t,
        punPortRemote: *mut uint16,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_GetListenSocketInfo(
        self_: *mut ISteamNetworking,
        hListenSocket: SNetListenSocket_t,
        pnIP: *mut SteamIPAddress_t,
        pnPort: *mut uint16,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_GetSocketConnectionType(
        self_: *mut ISteamNetworking,
        hSocket: SNetSocket_t,
    ) -> ESNetSocketConnectionType;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_GetMaxPacketSize(
        self_: *mut ISteamNetworking,
        hSocket: SNetSocket_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_SteamScreenshots_v003() -> *mut ISteamScreenshots;
}
extern "C" {
    pub fn SteamAPI_ISteamScreenshots_WriteScreenshot(
        self_: *mut ISteamScreenshots,
        pubRGB: *mut ::std::os::raw::c_void,
        cubRGB: uint32,
        nWidth: ::std::os::raw::c_int,
        nHeight: ::std::os::raw::c_int,
    ) -> ScreenshotHandle;
}
extern "C" {
    pub fn SteamAPI_ISteamScreenshots_AddScreenshotToLibrary(
        self_: *mut ISteamScreenshots,
        pchFilename: *const ::std::os::raw::c_char,
        pchThumbnailFilename: *const ::std::os::raw::c_char,
        nWidth: ::std::os::raw::c_int,
        nHeight: ::std::os::raw::c_int,
    ) -> ScreenshotHandle;
}
extern "C" {
    pub fn SteamAPI_ISteamScreenshots_TriggerScreenshot(self_: *mut ISteamScreenshots);
}
extern "C" {
    pub fn SteamAPI_ISteamScreenshots_HookScreenshots(self_: *mut ISteamScreenshots, bHook: bool);
}
extern "C" {
    pub fn SteamAPI_ISteamScreenshots_SetLocation(
        self_: *mut ISteamScreenshots,
        hScreenshot: ScreenshotHandle,
        pchLocation: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamScreenshots_TagUser(
        self_: *mut ISteamScreenshots,
        hScreenshot: ScreenshotHandle,
        steamID: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamScreenshots_TagPublishedFile(
        self_: *mut ISteamScreenshots,
        hScreenshot: ScreenshotHandle,
        unPublishedFileID: PublishedFileId_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamScreenshots_IsScreenshotsHooked(self_: *mut ISteamScreenshots) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamScreenshots_AddVRScreenshotToLibrary(
        self_: *mut ISteamScreenshots,
        eType: EVRScreenshotType,
        pchFilename: *const ::std::os::raw::c_char,
        pchVRFilename: *const ::std::os::raw::c_char,
    ) -> ScreenshotHandle;
}
extern "C" {
    pub fn SteamAPI_SteamMusic_v001() -> *mut ISteamMusic;
}
extern "C" {
    pub fn SteamAPI_ISteamMusic_BIsEnabled(self_: *mut ISteamMusic) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusic_BIsPlaying(self_: *mut ISteamMusic) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusic_GetPlaybackStatus(self_: *mut ISteamMusic) -> AudioPlayback_Status;
}
extern "C" {
    pub fn SteamAPI_ISteamMusic_Play(self_: *mut ISteamMusic);
}
extern "C" {
    pub fn SteamAPI_ISteamMusic_Pause(self_: *mut ISteamMusic);
}
extern "C" {
    pub fn SteamAPI_ISteamMusic_PlayPrevious(self_: *mut ISteamMusic);
}
extern "C" {
    pub fn SteamAPI_ISteamMusic_PlayNext(self_: *mut ISteamMusic);
}
extern "C" {
    pub fn SteamAPI_ISteamMusic_SetVolume(self_: *mut ISteamMusic, flVolume: f32);
}
extern "C" {
    pub fn SteamAPI_ISteamMusic_GetVolume(self_: *mut ISteamMusic) -> f32;
}
extern "C" {
    pub fn SteamAPI_SteamMusicRemote_v001() -> *mut ISteamMusicRemote;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_RegisterSteamMusicRemote(
        self_: *mut ISteamMusicRemote,
        pchName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_DeregisterSteamMusicRemote(
        self_: *mut ISteamMusicRemote,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_BIsCurrentMusicRemote(self_: *mut ISteamMusicRemote) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_BActivationSuccess(
        self_: *mut ISteamMusicRemote,
        bValue: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_SetDisplayName(
        self_: *mut ISteamMusicRemote,
        pchDisplayName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_SetPNGIcon_64x64(
        self_: *mut ISteamMusicRemote,
        pvBuffer: *mut ::std::os::raw::c_void,
        cbBufferLength: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_EnablePlayPrevious(
        self_: *mut ISteamMusicRemote,
        bValue: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_EnablePlayNext(
        self_: *mut ISteamMusicRemote,
        bValue: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_EnableShuffled(
        self_: *mut ISteamMusicRemote,
        bValue: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_EnableLooped(
        self_: *mut ISteamMusicRemote,
        bValue: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_EnableQueue(
        self_: *mut ISteamMusicRemote,
        bValue: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_EnablePlaylists(
        self_: *mut ISteamMusicRemote,
        bValue: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_UpdatePlaybackStatus(
        self_: *mut ISteamMusicRemote,
        nStatus: AudioPlayback_Status,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_UpdateShuffled(
        self_: *mut ISteamMusicRemote,
        bValue: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_UpdateLooped(
        self_: *mut ISteamMusicRemote,
        bValue: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_UpdateVolume(
        self_: *mut ISteamMusicRemote,
        flValue: f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_CurrentEntryWillChange(self_: *mut ISteamMusicRemote)
        -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_CurrentEntryIsAvailable(
        self_: *mut ISteamMusicRemote,
        bAvailable: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_UpdateCurrentEntryText(
        self_: *mut ISteamMusicRemote,
        pchText: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_UpdateCurrentEntryElapsedSeconds(
        self_: *mut ISteamMusicRemote,
        nValue: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_UpdateCurrentEntryCoverArt(
        self_: *mut ISteamMusicRemote,
        pvBuffer: *mut ::std::os::raw::c_void,
        cbBufferLength: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_CurrentEntryDidChange(self_: *mut ISteamMusicRemote) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_QueueWillChange(self_: *mut ISteamMusicRemote) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_ResetQueueEntries(self_: *mut ISteamMusicRemote) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_SetQueueEntry(
        self_: *mut ISteamMusicRemote,
        nID: ::std::os::raw::c_int,
        nPosition: ::std::os::raw::c_int,
        pchEntryText: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_SetCurrentQueueEntry(
        self_: *mut ISteamMusicRemote,
        nID: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_QueueDidChange(self_: *mut ISteamMusicRemote) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_PlaylistWillChange(self_: *mut ISteamMusicRemote) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_ResetPlaylistEntries(self_: *mut ISteamMusicRemote) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_SetPlaylistEntry(
        self_: *mut ISteamMusicRemote,
        nID: ::std::os::raw::c_int,
        nPosition: ::std::os::raw::c_int,
        pchEntryText: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_SetCurrentPlaylistEntry(
        self_: *mut ISteamMusicRemote,
        nID: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_PlaylistDidChange(self_: *mut ISteamMusicRemote) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamHTTP_v003() -> *mut ISteamHTTP;
}
extern "C" {
    pub fn SteamAPI_SteamGameServerHTTP_v003() -> *mut ISteamHTTP;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_CreateHTTPRequest(
        self_: *mut ISteamHTTP,
        eHTTPRequestMethod: EHTTPMethod,
        pchAbsoluteURL: *const ::std::os::raw::c_char,
    ) -> HTTPRequestHandle;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_SetHTTPRequestContextValue(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        ulContextValue: uint64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_SetHTTPRequestNetworkActivityTimeout(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        unTimeoutSeconds: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_SetHTTPRequestHeaderValue(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        pchHeaderName: *const ::std::os::raw::c_char,
        pchHeaderValue: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_SetHTTPRequestGetOrPostParameter(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        pchParamName: *const ::std::os::raw::c_char,
        pchParamValue: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_SendHTTPRequest(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        pCallHandle: *mut SteamAPICall_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_SendHTTPRequestAndStreamResponse(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        pCallHandle: *mut SteamAPICall_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_DeferHTTPRequest(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_PrioritizeHTTPRequest(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_GetHTTPResponseHeaderSize(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        pchHeaderName: *const ::std::os::raw::c_char,
        unResponseHeaderSize: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_GetHTTPResponseHeaderValue(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        pchHeaderName: *const ::std::os::raw::c_char,
        pHeaderValueBuffer: *mut uint8,
        unBufferSize: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_GetHTTPResponseBodySize(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        unBodySize: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_GetHTTPResponseBodyData(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        pBodyDataBuffer: *mut uint8,
        unBufferSize: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_GetHTTPStreamingResponseBodyData(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        cOffset: uint32,
        pBodyDataBuffer: *mut uint8,
        unBufferSize: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_ReleaseHTTPRequest(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_GetHTTPDownloadProgressPct(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        pflPercentOut: *mut f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_SetHTTPRequestRawPostBody(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        pchContentType: *const ::std::os::raw::c_char,
        pubBody: *mut uint8,
        unBodyLen: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_CreateCookieContainer(
        self_: *mut ISteamHTTP,
        bAllowResponsesToModify: bool,
    ) -> HTTPCookieContainerHandle;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_ReleaseCookieContainer(
        self_: *mut ISteamHTTP,
        hCookieContainer: HTTPCookieContainerHandle,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_SetCookie(
        self_: *mut ISteamHTTP,
        hCookieContainer: HTTPCookieContainerHandle,
        pchHost: *const ::std::os::raw::c_char,
        pchUrl: *const ::std::os::raw::c_char,
        pchCookie: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_SetHTTPRequestCookieContainer(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        hCookieContainer: HTTPCookieContainerHandle,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_SetHTTPRequestUserAgentInfo(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        pchUserAgentInfo: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_SetHTTPRequestRequiresVerifiedCertificate(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        bRequireVerifiedCertificate: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_SetHTTPRequestAbsoluteTimeoutMS(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        unMilliseconds: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_GetHTTPRequestWasTimedOut(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        pbWasTimedOut: *mut bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamInput_v006() -> *mut ISteamInput;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_Init(
        self_: *mut ISteamInput,
        bExplicitlyCallRunFrame: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_Shutdown(self_: *mut ISteamInput) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_SetInputActionManifestFilePath(
        self_: *mut ISteamInput,
        pchInputActionManifestAbsolutePath: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_RunFrame(self_: *mut ISteamInput, bReservedValue: bool);
}
extern "C" {
    pub fn SteamAPI_ISteamInput_BWaitForData(
        self_: *mut ISteamInput,
        bWaitForever: bool,
        unTimeout: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_BNewDataAvailable(self_: *mut ISteamInput) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetConnectedControllers(
        self_: *mut ISteamInput,
        handlesOut: *mut InputHandle_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_EnableDeviceCallbacks(self_: *mut ISteamInput);
}
extern "C" {
    pub fn SteamAPI_ISteamInput_EnableActionEventCallbacks(
        self_: *mut ISteamInput,
        pCallback: SteamInputActionEventCallbackPointer,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetActionSetHandle(
        self_: *mut ISteamInput,
        pszActionSetName: *const ::std::os::raw::c_char,
    ) -> InputActionSetHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_ActivateActionSet(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        actionSetHandle: InputActionSetHandle_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetCurrentActionSet(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
    ) -> InputActionSetHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_ActivateActionSetLayer(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        actionSetLayerHandle: InputActionSetHandle_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInput_DeactivateActionSetLayer(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        actionSetLayerHandle: InputActionSetHandle_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInput_DeactivateAllActionSetLayers(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetActiveActionSetLayers(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        handlesOut: *mut InputActionSetHandle_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetDigitalActionHandle(
        self_: *mut ISteamInput,
        pszActionName: *const ::std::os::raw::c_char,
    ) -> InputDigitalActionHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetDigitalActionData(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        digitalActionHandle: InputDigitalActionHandle_t,
    ) -> InputDigitalActionData_t;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetDigitalActionOrigins(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        actionSetHandle: InputActionSetHandle_t,
        digitalActionHandle: InputDigitalActionHandle_t,
        originsOut: *mut EInputActionOrigin,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetStringForDigitalActionName(
        self_: *mut ISteamInput,
        eActionHandle: InputDigitalActionHandle_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetAnalogActionHandle(
        self_: *mut ISteamInput,
        pszActionName: *const ::std::os::raw::c_char,
    ) -> InputAnalogActionHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetAnalogActionData(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        analogActionHandle: InputAnalogActionHandle_t,
    ) -> InputAnalogActionData_t;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetAnalogActionOrigins(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        actionSetHandle: InputActionSetHandle_t,
        analogActionHandle: InputAnalogActionHandle_t,
        originsOut: *mut EInputActionOrigin,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetGlyphPNGForActionOrigin(
        self_: *mut ISteamInput,
        eOrigin: EInputActionOrigin,
        eSize: ESteamInputGlyphSize,
        unFlags: uint32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetGlyphSVGForActionOrigin(
        self_: *mut ISteamInput,
        eOrigin: EInputActionOrigin,
        unFlags: uint32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetGlyphForActionOrigin_Legacy(
        self_: *mut ISteamInput,
        eOrigin: EInputActionOrigin,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetStringForActionOrigin(
        self_: *mut ISteamInput,
        eOrigin: EInputActionOrigin,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetStringForAnalogActionName(
        self_: *mut ISteamInput,
        eActionHandle: InputAnalogActionHandle_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_StopAnalogActionMomentum(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        eAction: InputAnalogActionHandle_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetMotionData(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
    ) -> InputMotionData_t;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_TriggerVibration(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        usLeftSpeed: ::std::os::raw::c_ushort,
        usRightSpeed: ::std::os::raw::c_ushort,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInput_TriggerVibrationExtended(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        usLeftSpeed: ::std::os::raw::c_ushort,
        usRightSpeed: ::std::os::raw::c_ushort,
        usLeftTriggerSpeed: ::std::os::raw::c_ushort,
        usRightTriggerSpeed: ::std::os::raw::c_ushort,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInput_TriggerSimpleHapticEvent(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        eHapticLocation: EControllerHapticLocation,
        nIntensity: uint8,
        nGainDB: ::std::os::raw::c_char,
        nOtherIntensity: uint8,
        nOtherGainDB: ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInput_SetLEDColor(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        nColorR: uint8,
        nColorG: uint8,
        nColorB: uint8,
        nFlags: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInput_Legacy_TriggerHapticPulse(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        eTargetPad: ESteamControllerPad,
        usDurationMicroSec: ::std::os::raw::c_ushort,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInput_Legacy_TriggerRepeatedHapticPulse(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        eTargetPad: ESteamControllerPad,
        usDurationMicroSec: ::std::os::raw::c_ushort,
        usOffMicroSec: ::std::os::raw::c_ushort,
        unRepeat: ::std::os::raw::c_ushort,
        nFlags: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInput_ShowBindingPanel(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetInputTypeForHandle(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
    ) -> ESteamInputType;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetControllerForGamepadIndex(
        self_: *mut ISteamInput,
        nIndex: ::std::os::raw::c_int,
    ) -> InputHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetGamepadIndexForController(
        self_: *mut ISteamInput,
        ulinputHandle: InputHandle_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetStringForXboxOrigin(
        self_: *mut ISteamInput,
        eOrigin: EXboxOrigin,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetGlyphForXboxOrigin(
        self_: *mut ISteamInput,
        eOrigin: EXboxOrigin,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetActionOriginFromXboxOrigin(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        eOrigin: EXboxOrigin,
    ) -> EInputActionOrigin;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_TranslateActionOrigin(
        self_: *mut ISteamInput,
        eDestinationInputType: ESteamInputType,
        eSourceOrigin: EInputActionOrigin,
    ) -> EInputActionOrigin;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetDeviceBindingRevision(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        pMajor: *mut ::std::os::raw::c_int,
        pMinor: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetRemotePlaySessionID(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetSessionInputConfigurationSettings(
        self_: *mut ISteamInput,
    ) -> uint16;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_SetDualSenseTriggerEffect(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        pParam: *const ScePadTriggerEffectParam,
    );
}
extern "C" {
    pub fn SteamAPI_SteamController_v008() -> *mut ISteamController;
}
extern "C" {
    pub fn SteamAPI_ISteamController_Init(self_: *mut ISteamController) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamController_Shutdown(self_: *mut ISteamController) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamController_RunFrame(self_: *mut ISteamController);
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetConnectedControllers(
        self_: *mut ISteamController,
        handlesOut: *mut ControllerHandle_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetActionSetHandle(
        self_: *mut ISteamController,
        pszActionSetName: *const ::std::os::raw::c_char,
    ) -> ControllerActionSetHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamController_ActivateActionSet(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        actionSetHandle: ControllerActionSetHandle_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetCurrentActionSet(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
    ) -> ControllerActionSetHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamController_ActivateActionSetLayer(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        actionSetLayerHandle: ControllerActionSetHandle_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamController_DeactivateActionSetLayer(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        actionSetLayerHandle: ControllerActionSetHandle_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamController_DeactivateAllActionSetLayers(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetActiveActionSetLayers(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        handlesOut: *mut ControllerActionSetHandle_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetDigitalActionHandle(
        self_: *mut ISteamController,
        pszActionName: *const ::std::os::raw::c_char,
    ) -> ControllerDigitalActionHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetDigitalActionData(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        digitalActionHandle: ControllerDigitalActionHandle_t,
    ) -> InputDigitalActionData_t;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetDigitalActionOrigins(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        actionSetHandle: ControllerActionSetHandle_t,
        digitalActionHandle: ControllerDigitalActionHandle_t,
        originsOut: *mut EControllerActionOrigin,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetAnalogActionHandle(
        self_: *mut ISteamController,
        pszActionName: *const ::std::os::raw::c_char,
    ) -> ControllerAnalogActionHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetAnalogActionData(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        analogActionHandle: ControllerAnalogActionHandle_t,
    ) -> InputAnalogActionData_t;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetAnalogActionOrigins(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        actionSetHandle: ControllerActionSetHandle_t,
        analogActionHandle: ControllerAnalogActionHandle_t,
        originsOut: *mut EControllerActionOrigin,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetGlyphForActionOrigin(
        self_: *mut ISteamController,
        eOrigin: EControllerActionOrigin,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetStringForActionOrigin(
        self_: *mut ISteamController,
        eOrigin: EControllerActionOrigin,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamController_StopAnalogActionMomentum(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        eAction: ControllerAnalogActionHandle_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetMotionData(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
    ) -> InputMotionData_t;
}
extern "C" {
    pub fn SteamAPI_ISteamController_TriggerHapticPulse(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        eTargetPad: ESteamControllerPad,
        usDurationMicroSec: ::std::os::raw::c_ushort,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamController_TriggerRepeatedHapticPulse(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        eTargetPad: ESteamControllerPad,
        usDurationMicroSec: ::std::os::raw::c_ushort,
        usOffMicroSec: ::std::os::raw::c_ushort,
        unRepeat: ::std::os::raw::c_ushort,
        nFlags: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamController_TriggerVibration(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        usLeftSpeed: ::std::os::raw::c_ushort,
        usRightSpeed: ::std::os::raw::c_ushort,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamController_SetLEDColor(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        nColorR: uint8,
        nColorG: uint8,
        nColorB: uint8,
        nFlags: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamController_ShowBindingPanel(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetInputTypeForHandle(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
    ) -> ESteamInputType;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetControllerForGamepadIndex(
        self_: *mut ISteamController,
        nIndex: ::std::os::raw::c_int,
    ) -> ControllerHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetGamepadIndexForController(
        self_: *mut ISteamController,
        ulControllerHandle: ControllerHandle_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetStringForXboxOrigin(
        self_: *mut ISteamController,
        eOrigin: EXboxOrigin,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetGlyphForXboxOrigin(
        self_: *mut ISteamController,
        eOrigin: EXboxOrigin,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetActionOriginFromXboxOrigin(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        eOrigin: EXboxOrigin,
    ) -> EControllerActionOrigin;
}
extern "C" {
    pub fn SteamAPI_ISteamController_TranslateActionOrigin(
        self_: *mut ISteamController,
        eDestinationInputType: ESteamInputType,
        eSourceOrigin: EControllerActionOrigin,
    ) -> EControllerActionOrigin;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetControllerBindingRevision(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        pMajor: *mut ::std::os::raw::c_int,
        pMinor: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamUGC_v021() -> *mut ISteamUGC;
}
extern "C" {
    pub fn SteamAPI_SteamGameServerUGC_v021() -> *mut ISteamUGC;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_CreateQueryUserUGCRequest(
        self_: *mut ISteamUGC,
        unAccountID: AccountID_t,
        eListType: EUserUGCList,
        eMatchingUGCType: EUGCMatchingUGCType,
        eSortOrder: EUserUGCListSortOrder,
        nCreatorAppID: AppId_t,
        nConsumerAppID: AppId_t,
        unPage: uint32,
    ) -> UGCQueryHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_CreateQueryAllUGCRequestPage(
        self_: *mut ISteamUGC,
        eQueryType: EUGCQuery,
        eMatchingeMatchingUGCTypeFileType: EUGCMatchingUGCType,
        nCreatorAppID: AppId_t,
        nConsumerAppID: AppId_t,
        unPage: uint32,
    ) -> UGCQueryHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_CreateQueryAllUGCRequestCursor(
        self_: *mut ISteamUGC,
        eQueryType: EUGCQuery,
        eMatchingeMatchingUGCTypeFileType: EUGCMatchingUGCType,
        nCreatorAppID: AppId_t,
        nConsumerAppID: AppId_t,
        pchCursor: *const ::std::os::raw::c_char,
    ) -> UGCQueryHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_CreateQueryUGCDetailsRequest(
        self_: *mut ISteamUGC,
        pvecPublishedFileID: *mut PublishedFileId_t,
        unNumPublishedFileIDs: uint32,
    ) -> UGCQueryHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SendQueryUGCRequest(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCResult(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
        pDetails: *mut SteamUGCDetails_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCNumTags(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCTag(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
        indexTag: uint32,
        pchValue: *mut ::std::os::raw::c_char,
        cchValueSize: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCTagDisplayName(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
        indexTag: uint32,
        pchValue: *mut ::std::os::raw::c_char,
        cchValueSize: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCPreviewURL(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
        pchURL: *mut ::std::os::raw::c_char,
        cchURLSize: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCMetadata(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
        pchMetadata: *mut ::std::os::raw::c_char,
        cchMetadatasize: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCChildren(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
        pvecPublishedFileID: *mut PublishedFileId_t,
        cMaxEntries: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCStatistic(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
        eStatType: EItemStatistic,
        pStatValue: *mut uint64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCNumAdditionalPreviews(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCAdditionalPreview(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
        previewIndex: uint32,
        pchURLOrVideoID: *mut ::std::os::raw::c_char,
        cchURLSize: uint32,
        pchOriginalFileName: *mut ::std::os::raw::c_char,
        cchOriginalFileNameSize: uint32,
        pPreviewType: *mut EItemPreviewType,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCNumKeyValueTags(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCKeyValueTag(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
        keyValueTagIndex: uint32,
        pchKey: *mut ::std::os::raw::c_char,
        cchKeySize: uint32,
        pchValue: *mut ::std::os::raw::c_char,
        cchValueSize: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryFirstUGCKeyValueTag(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
        pchKey: *const ::std::os::raw::c_char,
        pchValue: *mut ::std::os::raw::c_char,
        cchValueSize: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetNumSupportedGameVersions(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetSupportedGameVersionData(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
        versionIndex: uint32,
        pchGameBranchMin: *mut ::std::os::raw::c_char,
        pchGameBranchMax: *mut ::std::os::raw::c_char,
        cchGameBranchSize: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCContentDescriptors(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
        pvecDescriptors: *mut EUGCContentDescriptorID,
        cMaxEntries: uint32,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_ReleaseQueryUGCRequest(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_AddRequiredTag(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        pTagName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_AddRequiredTagGroup(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        pTagGroups: *const SteamParamStringArray_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_AddExcludedTag(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        pTagName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetReturnOnlyIDs(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        bReturnOnlyIDs: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetReturnKeyValueTags(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        bReturnKeyValueTags: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetReturnLongDescription(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        bReturnLongDescription: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetReturnMetadata(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        bReturnMetadata: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetReturnChildren(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        bReturnChildren: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetReturnAdditionalPreviews(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        bReturnAdditionalPreviews: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetReturnTotalOnly(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        bReturnTotalOnly: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetReturnPlaytimeStats(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        unDays: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetLanguage(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        pchLanguage: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetAllowCachedResponse(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        unMaxAgeSeconds: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetAdminQuery(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        bAdminQuery: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetCloudFileNameFilter(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        pMatchCloudFileName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetMatchAnyTag(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        bMatchAnyTag: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetSearchText(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        pSearchText: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetRankedByTrendDays(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        unDays: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetTimeCreatedDateRange(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        rtStart: RTime32,
        rtEnd: RTime32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetTimeUpdatedDateRange(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        rtStart: RTime32,
        rtEnd: RTime32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_AddRequiredKeyValueTag(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        pKey: *const ::std::os::raw::c_char,
        pValue: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_RequestUGCDetails(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
        unMaxAgeSeconds: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_CreateItem(
        self_: *mut ISteamUGC,
        nConsumerAppId: AppId_t,
        eFileType: EWorkshopFileType,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_StartItemUpdate(
        self_: *mut ISteamUGC,
        nConsumerAppId: AppId_t,
        nPublishedFileID: PublishedFileId_t,
    ) -> UGCUpdateHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetItemTitle(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        pchTitle: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetItemDescription(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        pchDescription: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetItemUpdateLanguage(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        pchLanguage: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetItemMetadata(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        pchMetaData: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetItemVisibility(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        eVisibility: ERemoteStoragePublishedFileVisibility,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetItemTags(
        self_: *mut ISteamUGC,
        updateHandle: UGCUpdateHandle_t,
        pTags: *const SteamParamStringArray_t,
        bAllowAdminTags: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetItemContent(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        pszContentFolder: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetItemPreview(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        pszPreviewFile: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetAllowLegacyUpload(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        bAllowLegacyUpload: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_RemoveAllItemKeyValueTags(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_RemoveItemKeyValueTags(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        pchKey: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_AddItemKeyValueTag(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        pchKey: *const ::std::os::raw::c_char,
        pchValue: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_AddItemPreviewFile(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        pszPreviewFile: *const ::std::os::raw::c_char,
        type_: EItemPreviewType,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_AddItemPreviewVideo(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        pszVideoID: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_UpdateItemPreviewFile(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        index: uint32,
        pszPreviewFile: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_UpdateItemPreviewVideo(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        index: uint32,
        pszVideoID: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_RemoveItemPreview(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        index: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_AddContentDescriptor(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        descid: EUGCContentDescriptorID,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_RemoveContentDescriptor(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        descid: EUGCContentDescriptorID,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetRequiredGameVersions(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        pszGameBranchMin: *const ::std::os::raw::c_char,
        pszGameBranchMax: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SubmitItemUpdate(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        pchChangeNote: *const ::std::os::raw::c_char,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetItemUpdateProgress(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        punBytesProcessed: *mut uint64,
        punBytesTotal: *mut uint64,
    ) -> EItemUpdateStatus;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetUserItemVote(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
        bVoteUp: bool,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetUserItemVote(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_AddItemToFavorites(
        self_: *mut ISteamUGC,
        nAppId: AppId_t,
        nPublishedFileID: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_RemoveItemFromFavorites(
        self_: *mut ISteamUGC,
        nAppId: AppId_t,
        nPublishedFileID: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SubscribeItem(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_UnsubscribeItem(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetNumSubscribedItems(
        self_: *mut ISteamUGC,
        bIncludeLocallyDisabled: bool,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetSubscribedItems(
        self_: *mut ISteamUGC,
        pvecPublishedFileID: *mut PublishedFileId_t,
        cMaxEntries: uint32,
        bIncludeLocallyDisabled: bool,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetItemState(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetItemInstallInfo(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
        punSizeOnDisk: *mut uint64,
        pchFolder: *mut ::std::os::raw::c_char,
        cchFolderSize: uint32,
        punTimeStamp: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetItemDownloadInfo(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
        punBytesDownloaded: *mut uint64,
        punBytesTotal: *mut uint64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_DownloadItem(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
        bHighPriority: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_BInitWorkshopForGameServer(
        self_: *mut ISteamUGC,
        unWorkshopDepotID: DepotId_t,
        pszFolder: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SuspendDownloads(self_: *mut ISteamUGC, bSuspend: bool);
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_StartPlaytimeTracking(
        self_: *mut ISteamUGC,
        pvecPublishedFileID: *mut PublishedFileId_t,
        unNumPublishedFileIDs: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_StopPlaytimeTracking(
        self_: *mut ISteamUGC,
        pvecPublishedFileID: *mut PublishedFileId_t,
        unNumPublishedFileIDs: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_StopPlaytimeTrackingForAllItems(
        self_: *mut ISteamUGC,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_AddDependency(
        self_: *mut ISteamUGC,
        nParentPublishedFileID: PublishedFileId_t,
        nChildPublishedFileID: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_RemoveDependency(
        self_: *mut ISteamUGC,
        nParentPublishedFileID: PublishedFileId_t,
        nChildPublishedFileID: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_AddAppDependency(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
        nAppID: AppId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_RemoveAppDependency(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
        nAppID: AppId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetAppDependencies(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_DeleteItem(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_ShowWorkshopEULA(self_: *mut ISteamUGC) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetWorkshopEULAStatus(self_: *mut ISteamUGC) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetUserContentDescriptorPreferences(
        self_: *mut ISteamUGC,
        pvecDescriptors: *mut EUGCContentDescriptorID,
        cMaxEntries: uint32,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetItemsDisabledLocally(
        self_: *mut ISteamUGC,
        pvecPublishedFileIDs: *mut PublishedFileId_t,
        unNumPublishedFileIDs: uint32,
        bDisabledLocally: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetSubscriptionsLoadOrder(
        self_: *mut ISteamUGC,
        pvecPublishedFileIDs: *mut PublishedFileId_t,
        unNumPublishedFileIDs: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamHTMLSurface_v005() -> *mut ISteamHTMLSurface;
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_Init(self_: *mut ISteamHTMLSurface) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_Shutdown(self_: *mut ISteamHTMLSurface) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_CreateBrowser(
        self_: *mut ISteamHTMLSurface,
        pchUserAgent: *const ::std::os::raw::c_char,
        pchUserCSS: *const ::std::os::raw::c_char,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_RemoveBrowser(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_LoadURL(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        pchURL: *const ::std::os::raw::c_char,
        pchPostData: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_SetSize(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        unWidth: uint32,
        unHeight: uint32,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_StopLoad(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_Reload(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_GoBack(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_GoForward(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_AddHeader(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        pchKey: *const ::std::os::raw::c_char,
        pchValue: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_ExecuteJavascript(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        pchScript: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_MouseUp(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        eMouseButton: ISteamHTMLSurface_EHTMLMouseButton,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_MouseDown(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        eMouseButton: ISteamHTMLSurface_EHTMLMouseButton,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_MouseDoubleClick(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        eMouseButton: ISteamHTMLSurface_EHTMLMouseButton,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_MouseMove(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_MouseWheel(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        nDelta: int32,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_KeyDown(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        nNativeKeyCode: uint32,
        eHTMLKeyModifiers: ISteamHTMLSurface_EHTMLKeyModifiers,
        bIsSystemKey: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_KeyUp(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        nNativeKeyCode: uint32,
        eHTMLKeyModifiers: ISteamHTMLSurface_EHTMLKeyModifiers,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_KeyChar(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        cUnicodeChar: uint32,
        eHTMLKeyModifiers: ISteamHTMLSurface_EHTMLKeyModifiers,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_SetHorizontalScroll(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        nAbsolutePixelScroll: uint32,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_SetVerticalScroll(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        nAbsolutePixelScroll: uint32,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_SetKeyFocus(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        bHasKeyFocus: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_ViewSource(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_CopyToClipboard(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_PasteFromClipboard(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_Find(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        pchSearchStr: *const ::std::os::raw::c_char,
        bCurrentlyInFind: bool,
        bReverse: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_StopFind(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_GetLinkAtPosition(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_SetCookie(
        self_: *mut ISteamHTMLSurface,
        pchHostname: *const ::std::os::raw::c_char,
        pchKey: *const ::std::os::raw::c_char,
        pchValue: *const ::std::os::raw::c_char,
        pchPath: *const ::std::os::raw::c_char,
        nExpires: RTime32,
        bSecure: bool,
        bHTTPOnly: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_SetPageScaleFactor(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        flZoom: f32,
        nPointX: ::std::os::raw::c_int,
        nPointY: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_SetBackgroundMode(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        bBackgroundMode: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_SetDPIScalingFactor(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        flDPIScaling: f32,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_OpenDeveloperTools(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_AllowStartRequest(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        bAllowed: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_JSDialogResponse(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        bResult: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_FileLoadDialogResponse(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        pchSelectedFiles: *mut *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_SteamInventory_v003() -> *mut ISteamInventory;
}
extern "C" {
    pub fn SteamAPI_SteamGameServerInventory_v003() -> *mut ISteamInventory;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GetResultStatus(
        self_: *mut ISteamInventory,
        resultHandle: SteamInventoryResult_t,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GetResultItems(
        self_: *mut ISteamInventory,
        resultHandle: SteamInventoryResult_t,
        pOutItemsArray: *mut SteamItemDetails_t,
        punOutItemsArraySize: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GetResultItemProperty(
        self_: *mut ISteamInventory,
        resultHandle: SteamInventoryResult_t,
        unItemIndex: uint32,
        pchPropertyName: *const ::std::os::raw::c_char,
        pchValueBuffer: *mut ::std::os::raw::c_char,
        punValueBufferSizeOut: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GetResultTimestamp(
        self_: *mut ISteamInventory,
        resultHandle: SteamInventoryResult_t,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_CheckResultSteamID(
        self_: *mut ISteamInventory,
        resultHandle: SteamInventoryResult_t,
        steamIDExpected: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_DestroyResult(
        self_: *mut ISteamInventory,
        resultHandle: SteamInventoryResult_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GetAllItems(
        self_: *mut ISteamInventory,
        pResultHandle: *mut SteamInventoryResult_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GetItemsByID(
        self_: *mut ISteamInventory,
        pResultHandle: *mut SteamInventoryResult_t,
        pInstanceIDs: *const SteamItemInstanceID_t,
        unCountInstanceIDs: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_SerializeResult(
        self_: *mut ISteamInventory,
        resultHandle: SteamInventoryResult_t,
        pOutBuffer: *mut ::std::os::raw::c_void,
        punOutBufferSize: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_DeserializeResult(
        self_: *mut ISteamInventory,
        pOutResultHandle: *mut SteamInventoryResult_t,
        pBuffer: *const ::std::os::raw::c_void,
        unBufferSize: uint32,
        bRESERVED_MUST_BE_FALSE: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GenerateItems(
        self_: *mut ISteamInventory,
        pResultHandle: *mut SteamInventoryResult_t,
        pArrayItemDefs: *const SteamItemDef_t,
        punArrayQuantity: *const uint32,
        unArrayLength: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GrantPromoItems(
        self_: *mut ISteamInventory,
        pResultHandle: *mut SteamInventoryResult_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_AddPromoItem(
        self_: *mut ISteamInventory,
        pResultHandle: *mut SteamInventoryResult_t,
        itemDef: SteamItemDef_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_AddPromoItems(
        self_: *mut ISteamInventory,
        pResultHandle: *mut SteamInventoryResult_t,
        pArrayItemDefs: *const SteamItemDef_t,
        unArrayLength: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_ConsumeItem(
        self_: *mut ISteamInventory,
        pResultHandle: *mut SteamInventoryResult_t,
        itemConsume: SteamItemInstanceID_t,
        unQuantity: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_ExchangeItems(
        self_: *mut ISteamInventory,
        pResultHandle: *mut SteamInventoryResult_t,
        pArrayGenerate: *const SteamItemDef_t,
        punArrayGenerateQuantity: *const uint32,
        unArrayGenerateLength: uint32,
        pArrayDestroy: *const SteamItemInstanceID_t,
        punArrayDestroyQuantity: *const uint32,
        unArrayDestroyLength: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_TransferItemQuantity(
        self_: *mut ISteamInventory,
        pResultHandle: *mut SteamInventoryResult_t,
        itemIdSource: SteamItemInstanceID_t,
        unQuantity: uint32,
        itemIdDest: SteamItemInstanceID_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_SendItemDropHeartbeat(self_: *mut ISteamInventory);
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_TriggerItemDrop(
        self_: *mut ISteamInventory,
        pResultHandle: *mut SteamInventoryResult_t,
        dropListDefinition: SteamItemDef_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_TradeItems(
        self_: *mut ISteamInventory,
        pResultHandle: *mut SteamInventoryResult_t,
        steamIDTradePartner: uint64_steamid,
        pArrayGive: *const SteamItemInstanceID_t,
        pArrayGiveQuantity: *const uint32,
        nArrayGiveLength: uint32,
        pArrayGet: *const SteamItemInstanceID_t,
        pArrayGetQuantity: *const uint32,
        nArrayGetLength: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_LoadItemDefinitions(self_: *mut ISteamInventory) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GetItemDefinitionIDs(
        self_: *mut ISteamInventory,
        pItemDefIDs: *mut SteamItemDef_t,
        punItemDefIDsArraySize: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GetItemDefinitionProperty(
        self_: *mut ISteamInventory,
        iDefinition: SteamItemDef_t,
        pchPropertyName: *const ::std::os::raw::c_char,
        pchValueBuffer: *mut ::std::os::raw::c_char,
        punValueBufferSizeOut: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_RequestEligiblePromoItemDefinitionsIDs(
        self_: *mut ISteamInventory,
        steamID: uint64_steamid,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GetEligiblePromoItemDefinitionIDs(
        self_: *mut ISteamInventory,
        steamID: uint64_steamid,
        pItemDefIDs: *mut SteamItemDef_t,
        punItemDefIDsArraySize: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_StartPurchase(
        self_: *mut ISteamInventory,
        pArrayItemDefs: *const SteamItemDef_t,
        punArrayQuantity: *const uint32,
        unArrayLength: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_RequestPrices(self_: *mut ISteamInventory) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GetNumItemsWithPrices(self_: *mut ISteamInventory) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GetItemsWithPrices(
        self_: *mut ISteamInventory,
        pArrayItemDefs: *mut SteamItemDef_t,
        pCurrentPrices: *mut uint64,
        pBasePrices: *mut uint64,
        unArrayLength: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GetItemPrice(
        self_: *mut ISteamInventory,
        iDefinition: SteamItemDef_t,
        pCurrentPrice: *mut uint64,
        pBasePrice: *mut uint64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_StartUpdateProperties(
        self_: *mut ISteamInventory,
    ) -> SteamInventoryUpdateHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_RemoveProperty(
        self_: *mut ISteamInventory,
        handle: SteamInventoryUpdateHandle_t,
        nItemID: SteamItemInstanceID_t,
        pchPropertyName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_SetPropertyString(
        self_: *mut ISteamInventory,
        handle: SteamInventoryUpdateHandle_t,
        nItemID: SteamItemInstanceID_t,
        pchPropertyName: *const ::std::os::raw::c_char,
        pchPropertyValue: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_SetPropertyBool(
        self_: *mut ISteamInventory,
        handle: SteamInventoryUpdateHandle_t,
        nItemID: SteamItemInstanceID_t,
        pchPropertyName: *const ::std::os::raw::c_char,
        bValue: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_SetPropertyInt64(
        self_: *mut ISteamInventory,
        handle: SteamInventoryUpdateHandle_t,
        nItemID: SteamItemInstanceID_t,
        pchPropertyName: *const ::std::os::raw::c_char,
        nValue: int64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_SetPropertyFloat(
        self_: *mut ISteamInventory,
        handle: SteamInventoryUpdateHandle_t,
        nItemID: SteamItemInstanceID_t,
        pchPropertyName: *const ::std::os::raw::c_char,
        flValue: f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_SubmitUpdateProperties(
        self_: *mut ISteamInventory,
        handle: SteamInventoryUpdateHandle_t,
        pResultHandle: *mut SteamInventoryResult_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_InspectItem(
        self_: *mut ISteamInventory,
        pResultHandle: *mut SteamInventoryResult_t,
        pchItemToken: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamTimeline_v004() -> *mut ISteamTimeline;
}
extern "C" {
    pub fn SteamAPI_ISteamTimeline_SetTimelineTooltip(
        self_: *mut ISteamTimeline,
        pchDescription: *const ::std::os::raw::c_char,
        flTimeDelta: f32,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamTimeline_ClearTimelineTooltip(
        self_: *mut ISteamTimeline,
        flTimeDelta: f32,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamTimeline_SetTimelineGameMode(
        self_: *mut ISteamTimeline,
        eMode: ETimelineGameMode,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamTimeline_AddInstantaneousTimelineEvent(
        self_: *mut ISteamTimeline,
        pchTitle: *const ::std::os::raw::c_char,
        pchDescription: *const ::std::os::raw::c_char,
        pchIcon: *const ::std::os::raw::c_char,
        unIconPriority: uint32,
        flStartOffsetSeconds: f32,
        ePossibleClip: ETimelineEventClipPriority,
    ) -> TimelineEventHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamTimeline_AddRangeTimelineEvent(
        self_: *mut ISteamTimeline,
        pchTitle: *const ::std::os::raw::c_char,
        pchDescription: *const ::std::os::raw::c_char,
        pchIcon: *const ::std::os::raw::c_char,
        unIconPriority: uint32,
        flStartOffsetSeconds: f32,
        flDuration: f32,
        ePossibleClip: ETimelineEventClipPriority,
    ) -> TimelineEventHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamTimeline_StartRangeTimelineEvent(
        self_: *mut ISteamTimeline,
        pchTitle: *const ::std::os::raw::c_char,
        pchDescription: *const ::std::os::raw::c_char,
        pchIcon: *const ::std::os::raw::c_char,
        unPriority: uint32,
        flStartOffsetSeconds: f32,
        ePossibleClip: ETimelineEventClipPriority,
    ) -> TimelineEventHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamTimeline_UpdateRangeTimelineEvent(
        self_: *mut ISteamTimeline,
        ulEvent: TimelineEventHandle_t,
        pchTitle: *const ::std::os::raw::c_char,
        pchDescription: *const ::std::os::raw::c_char,
        pchIcon: *const ::std::os::raw::c_char,
        unPriority: uint32,
        ePossibleClip: ETimelineEventClipPriority,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamTimeline_EndRangeTimelineEvent(
        self_: *mut ISteamTimeline,
        ulEvent: TimelineEventHandle_t,
        flEndOffsetSeconds: f32,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamTimeline_RemoveTimelineEvent(
        self_: *mut ISteamTimeline,
        ulEvent: TimelineEventHandle_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamTimeline_DoesEventRecordingExist(
        self_: *mut ISteamTimeline,
        ulEvent: TimelineEventHandle_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamTimeline_StartGamePhase(self_: *mut ISteamTimeline);
}
extern "C" {
    pub fn SteamAPI_ISteamTimeline_EndGamePhase(self_: *mut ISteamTimeline);
}
extern "C" {
    pub fn SteamAPI_ISteamTimeline_SetGamePhaseID(
        self_: *mut ISteamTimeline,
        pchPhaseID: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamTimeline_DoesGamePhaseRecordingExist(
        self_: *mut ISteamTimeline,
        pchPhaseID: *const ::std::os::raw::c_char,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamTimeline_AddGamePhaseTag(
        self_: *mut ISteamTimeline,
        pchTagName: *const ::std::os::raw::c_char,
        pchTagIcon: *const ::std::os::raw::c_char,
        pchTagGroup: *const ::std::os::raw::c_char,
        unPriority: uint32,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamTimeline_SetGamePhaseAttribute(
        self_: *mut ISteamTimeline,
        pchAttributeGroup: *const ::std::os::raw::c_char,
        pchAttributeValue: *const ::std::os::raw::c_char,
        unPriority: uint32,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamTimeline_OpenOverlayToGamePhase(
        self_: *mut ISteamTimeline,
        pchPhaseID: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamTimeline_OpenOverlayToTimelineEvent(
        self_: *mut ISteamTimeline,
        ulEvent: TimelineEventHandle_t,
    );
}
extern "C" {
    pub fn SteamAPI_SteamVideo_v007() -> *mut ISteamVideo;
}
extern "C" {
    pub fn SteamAPI_ISteamVideo_GetVideoURL(self_: *mut ISteamVideo, unVideoAppID: AppId_t);
}
extern "C" {
    pub fn SteamAPI_ISteamVideo_IsBroadcasting(
        self_: *mut ISteamVideo,
        pnNumViewers: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamVideo_GetOPFSettings(self_: *mut ISteamVideo, unVideoAppID: AppId_t);
}
extern "C" {
    pub fn SteamAPI_ISteamVideo_GetOPFStringForApp(
        self_: *mut ISteamVideo,
        unVideoAppID: AppId_t,
        pchBuffer: *mut ::std::os::raw::c_char,
        pnBufferSize: *mut int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamParentalSettings_v001() -> *mut ISteamParentalSettings;
}
extern "C" {
    pub fn SteamAPI_ISteamParentalSettings_BIsParentalLockEnabled(
        self_: *mut ISteamParentalSettings,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamParentalSettings_BIsParentalLockLocked(
        self_: *mut ISteamParentalSettings,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamParentalSettings_BIsAppBlocked(
        self_: *mut ISteamParentalSettings,
        nAppID: AppId_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamParentalSettings_BIsAppInBlockList(
        self_: *mut ISteamParentalSettings,
        nAppID: AppId_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamParentalSettings_BIsFeatureBlocked(
        self_: *mut ISteamParentalSettings,
        eFeature: EParentalFeature,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamParentalSettings_BIsFeatureInBlockList(
        self_: *mut ISteamParentalSettings,
        eFeature: EParentalFeature,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamRemotePlay_v003() -> *mut ISteamRemotePlay;
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_GetSessionCount(self_: *mut ISteamRemotePlay) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_GetSessionID(
        self_: *mut ISteamRemotePlay,
        iSessionIndex: ::std::os::raw::c_int,
    ) -> RemotePlaySessionID_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_GetSessionSteamID(
        self_: *mut ISteamRemotePlay,
        unSessionID: RemotePlaySessionID_t,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_GetSessionClientName(
        self_: *mut ISteamRemotePlay,
        unSessionID: RemotePlaySessionID_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_GetSessionClientFormFactor(
        self_: *mut ISteamRemotePlay,
        unSessionID: RemotePlaySessionID_t,
    ) -> ESteamDeviceFormFactor;
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_BGetSessionClientResolution(
        self_: *mut ISteamRemotePlay,
        unSessionID: RemotePlaySessionID_t,
        pnResolutionX: *mut ::std::os::raw::c_int,
        pnResolutionY: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_ShowRemotePlayTogetherUI(self_: *mut ISteamRemotePlay)
        -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_BSendRemotePlayTogetherInvite(
        self_: *mut ISteamRemotePlay,
        steamIDFriend: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_BEnableRemotePlayTogetherDirectInput(
        self_: *mut ISteamRemotePlay,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_DisableRemotePlayTogetherDirectInput(
        self_: *mut ISteamRemotePlay,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_GetInput(
        self_: *mut ISteamRemotePlay,
        pInput: *mut RemotePlayInput_t,
        unMaxEvents: uint32,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_SetMouseVisibility(
        self_: *mut ISteamRemotePlay,
        unSessionID: RemotePlaySessionID_t,
        bVisible: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_SetMousePosition(
        self_: *mut ISteamRemotePlay,
        unSessionID: RemotePlaySessionID_t,
        flNormalizedX: f32,
        flNormalizedY: f32,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_CreateMouseCursor(
        self_: *mut ISteamRemotePlay,
        nWidth: ::std::os::raw::c_int,
        nHeight: ::std::os::raw::c_int,
        nHotX: ::std::os::raw::c_int,
        nHotY: ::std::os::raw::c_int,
        pBGRA: *const ::std::os::raw::c_void,
        nPitch: ::std::os::raw::c_int,
    ) -> RemotePlayCursorID_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_SetMouseCursor(
        self_: *mut ISteamRemotePlay,
        unSessionID: RemotePlaySessionID_t,
        unCursorID: RemotePlayCursorID_t,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingMessages_SteamAPI_v002() -> *mut ISteamNetworkingMessages;
}
extern "C" {
    pub fn SteamAPI_SteamGameServerNetworkingMessages_SteamAPI_v002(
    ) -> *mut ISteamNetworkingMessages;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingMessages_SendMessageToUser(
        self_: *mut ISteamNetworkingMessages,
        identityRemote: *const SteamNetworkingIdentity,
        pubData: *const ::std::os::raw::c_void,
        cubData: uint32,
        nSendFlags: ::std::os::raw::c_int,
        nRemoteChannel: ::std::os::raw::c_int,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingMessages_ReceiveMessagesOnChannel(
        self_: *mut ISteamNetworkingMessages,
        nLocalChannel: ::std::os::raw::c_int,
        ppOutMessages: *mut *mut SteamNetworkingMessage_t,
        nMaxMessages: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingMessages_AcceptSessionWithUser(
        self_: *mut ISteamNetworkingMessages,
        identityRemote: *const SteamNetworkingIdentity,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingMessages_CloseSessionWithUser(
        self_: *mut ISteamNetworkingMessages,
        identityRemote: *const SteamNetworkingIdentity,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingMessages_CloseChannelWithUser(
        self_: *mut ISteamNetworkingMessages,
        identityRemote: *const SteamNetworkingIdentity,
        nLocalChannel: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingMessages_GetSessionConnectionInfo(
        self_: *mut ISteamNetworkingMessages,
        identityRemote: *const SteamNetworkingIdentity,
        pConnectionInfo: *mut SteamNetConnectionInfo_t,
        pQuickStatus: *mut SteamNetConnectionRealTimeStatus_t,
    ) -> ESteamNetworkingConnectionState;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingSockets_SteamAPI_v012() -> *mut ISteamNetworkingSockets;
}
extern "C" {
    pub fn SteamAPI_SteamGameServerNetworkingSockets_SteamAPI_v012() -> *mut ISteamNetworkingSockets;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_CreateListenSocketIP(
        self_: *mut ISteamNetworkingSockets,
        localAddress: *const SteamNetworkingIPAddr,
        nOptions: ::std::os::raw::c_int,
        pOptions: *const SteamNetworkingConfigValue_t,
    ) -> HSteamListenSocket;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ConnectByIPAddress(
        self_: *mut ISteamNetworkingSockets,
        address: *const SteamNetworkingIPAddr,
        nOptions: ::std::os::raw::c_int,
        pOptions: *const SteamNetworkingConfigValue_t,
    ) -> HSteamNetConnection;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_CreateListenSocketP2P(
        self_: *mut ISteamNetworkingSockets,
        nLocalVirtualPort: ::std::os::raw::c_int,
        nOptions: ::std::os::raw::c_int,
        pOptions: *const SteamNetworkingConfigValue_t,
    ) -> HSteamListenSocket;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ConnectP2P(
        self_: *mut ISteamNetworkingSockets,
        identityRemote: *const SteamNetworkingIdentity,
        nRemoteVirtualPort: ::std::os::raw::c_int,
        nOptions: ::std::os::raw::c_int,
        pOptions: *const SteamNetworkingConfigValue_t,
    ) -> HSteamNetConnection;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_AcceptConnection(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_CloseConnection(
        self_: *mut ISteamNetworkingSockets,
        hPeer: HSteamNetConnection,
        nReason: ::std::os::raw::c_int,
        pszDebug: *const ::std::os::raw::c_char,
        bEnableLinger: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_CloseListenSocket(
        self_: *mut ISteamNetworkingSockets,
        hSocket: HSteamListenSocket,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_SetConnectionUserData(
        self_: *mut ISteamNetworkingSockets,
        hPeer: HSteamNetConnection,
        nUserData: int64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetConnectionUserData(
        self_: *mut ISteamNetworkingSockets,
        hPeer: HSteamNetConnection,
    ) -> int64;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_SetConnectionName(
        self_: *mut ISteamNetworkingSockets,
        hPeer: HSteamNetConnection,
        pszName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetConnectionName(
        self_: *mut ISteamNetworkingSockets,
        hPeer: HSteamNetConnection,
        pszName: *mut ::std::os::raw::c_char,
        nMaxLen: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_SendMessageToConnection(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
        pData: *const ::std::os::raw::c_void,
        cbData: uint32,
        nSendFlags: ::std::os::raw::c_int,
        pOutMessageNumber: *mut int64,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_SendMessages(
        self_: *mut ISteamNetworkingSockets,
        nMessages: ::std::os::raw::c_int,
        pMessages: *const *mut SteamNetworkingMessage_t,
        pOutMessageNumberOrResult: *mut int64,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_FlushMessagesOnConnection(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ReceiveMessagesOnConnection(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
        ppOutMessages: *mut *mut SteamNetworkingMessage_t,
        nMaxMessages: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetConnectionInfo(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
        pInfo: *mut SteamNetConnectionInfo_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetConnectionRealTimeStatus(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
        pStatus: *mut SteamNetConnectionRealTimeStatus_t,
        nLanes: ::std::os::raw::c_int,
        pLanes: *mut SteamNetConnectionRealTimeLaneStatus_t,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetDetailedConnectionStatus(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
        pszBuf: *mut ::std::os::raw::c_char,
        cbBuf: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetListenSocketAddress(
        self_: *mut ISteamNetworkingSockets,
        hSocket: HSteamListenSocket,
        address: *mut SteamNetworkingIPAddr,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_CreateSocketPair(
        self_: *mut ISteamNetworkingSockets,
        pOutConnection1: *mut HSteamNetConnection,
        pOutConnection2: *mut HSteamNetConnection,
        bUseNetworkLoopback: bool,
        pIdentity1: *const SteamNetworkingIdentity,
        pIdentity2: *const SteamNetworkingIdentity,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ConfigureConnectionLanes(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
        nNumLanes: ::std::os::raw::c_int,
        pLanePriorities: *const ::std::os::raw::c_int,
        pLaneWeights: *const uint16,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetIdentity(
        self_: *mut ISteamNetworkingSockets,
        pIdentity: *mut SteamNetworkingIdentity,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_InitAuthentication(
        self_: *mut ISteamNetworkingSockets,
    ) -> ESteamNetworkingAvailability;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetAuthenticationStatus(
        self_: *mut ISteamNetworkingSockets,
        pDetails: *mut SteamNetAuthenticationStatus_t,
    ) -> ESteamNetworkingAvailability;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_CreatePollGroup(
        self_: *mut ISteamNetworkingSockets,
    ) -> HSteamNetPollGroup;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_DestroyPollGroup(
        self_: *mut ISteamNetworkingSockets,
        hPollGroup: HSteamNetPollGroup,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_SetConnectionPollGroup(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
        hPollGroup: HSteamNetPollGroup,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ReceiveMessagesOnPollGroup(
        self_: *mut ISteamNetworkingSockets,
        hPollGroup: HSteamNetPollGroup,
        ppOutMessages: *mut *mut SteamNetworkingMessage_t,
        nMaxMessages: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ReceivedRelayAuthTicket(
        self_: *mut ISteamNetworkingSockets,
        pvTicket: *const ::std::os::raw::c_void,
        cbTicket: ::std::os::raw::c_int,
        pOutParsedTicket: *mut SteamDatagramRelayAuthTicket,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_FindRelayAuthTicketForServer(
        self_: *mut ISteamNetworkingSockets,
        identityGameServer: *const SteamNetworkingIdentity,
        nRemoteVirtualPort: ::std::os::raw::c_int,
        pOutParsedTicket: *mut SteamDatagramRelayAuthTicket,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ConnectToHostedDedicatedServer(
        self_: *mut ISteamNetworkingSockets,
        identityTarget: *const SteamNetworkingIdentity,
        nRemoteVirtualPort: ::std::os::raw::c_int,
        nOptions: ::std::os::raw::c_int,
        pOptions: *const SteamNetworkingConfigValue_t,
    ) -> HSteamNetConnection;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerPort(
        self_: *mut ISteamNetworkingSockets,
    ) -> uint16;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerPOPID(
        self_: *mut ISteamNetworkingSockets,
    ) -> SteamNetworkingPOPID;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerAddress(
        self_: *mut ISteamNetworkingSockets,
        pRouting: *mut SteamDatagramHostedAddress,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_CreateHostedDedicatedServerListenSocket(
        self_: *mut ISteamNetworkingSockets,
        nLocalVirtualPort: ::std::os::raw::c_int,
        nOptions: ::std::os::raw::c_int,
        pOptions: *const SteamNetworkingConfigValue_t,
    ) -> HSteamListenSocket;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetGameCoordinatorServerLogin(
        self_: *mut ISteamNetworkingSockets,
        pLoginInfo: *mut SteamDatagramGameCoordinatorServerLogin,
        pcbSignedBlob: *mut ::std::os::raw::c_int,
        pBlob: *mut ::std::os::raw::c_void,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ConnectP2PCustomSignaling(
        self_: *mut ISteamNetworkingSockets,
        pSignaling: *mut ISteamNetworkingConnectionSignaling,
        pPeerIdentity: *const SteamNetworkingIdentity,
        nRemoteVirtualPort: ::std::os::raw::c_int,
        nOptions: ::std::os::raw::c_int,
        pOptions: *const SteamNetworkingConfigValue_t,
    ) -> HSteamNetConnection;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ReceivedP2PCustomSignal(
        self_: *mut ISteamNetworkingSockets,
        pMsg: *const ::std::os::raw::c_void,
        cbMsg: ::std::os::raw::c_int,
        pContext: *mut ISteamNetworkingSignalingRecvContext,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetCertificateRequest(
        self_: *mut ISteamNetworkingSockets,
        pcbBlob: *mut ::std::os::raw::c_int,
        pBlob: *mut ::std::os::raw::c_void,
        errMsg: *mut SteamNetworkingErrMsg,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_SetCertificate(
        self_: *mut ISteamNetworkingSockets,
        pCertificate: *const ::std::os::raw::c_void,
        cbCertificate: ::std::os::raw::c_int,
        errMsg: *mut SteamNetworkingErrMsg,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ResetIdentity(
        self_: *mut ISteamNetworkingSockets,
        pIdentity: *const SteamNetworkingIdentity,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_RunCallbacks(self_: *mut ISteamNetworkingSockets);
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_BeginAsyncRequestFakeIP(
        self_: *mut ISteamNetworkingSockets,
        nNumPorts: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetFakeIP(
        self_: *mut ISteamNetworkingSockets,
        idxFirstPort: ::std::os::raw::c_int,
        pInfo: *mut SteamNetworkingFakeIPResult_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_CreateListenSocketP2PFakeIP(
        self_: *mut ISteamNetworkingSockets,
        idxFakePort: ::std::os::raw::c_int,
        nOptions: ::std::os::raw::c_int,
        pOptions: *const SteamNetworkingConfigValue_t,
    ) -> HSteamListenSocket;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetRemoteFakeIPForConnection(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
        pOutAddr: *mut SteamNetworkingIPAddr,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_CreateFakeUDPPort(
        self_: *mut ISteamNetworkingSockets,
        idxFakeServerPort: ::std::os::raw::c_int,
    ) -> *mut ISteamNetworkingFakeUDPPort;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingUtils_SteamAPI_v004() -> *mut ISteamNetworkingUtils;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_AllocateMessage(
        self_: *mut ISteamNetworkingUtils,
        cbAllocateBuffer: ::std::os::raw::c_int,
    ) -> *mut SteamNetworkingMessage_t;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_InitRelayNetworkAccess(self_: *mut ISteamNetworkingUtils);
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetRelayNetworkStatus(
        self_: *mut ISteamNetworkingUtils,
        pDetails: *mut SteamRelayNetworkStatus_t,
    ) -> ESteamNetworkingAvailability;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetLocalPingLocation(
        self_: *mut ISteamNetworkingUtils,
        result: *mut SteamNetworkPingLocation_t,
    ) -> f32;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_EstimatePingTimeBetweenTwoLocations(
        self_: *mut ISteamNetworkingUtils,
        location1: *const SteamNetworkPingLocation_t,
        location2: *const SteamNetworkPingLocation_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_EstimatePingTimeFromLocalHost(
        self_: *mut ISteamNetworkingUtils,
        remoteLocation: *const SteamNetworkPingLocation_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_ConvertPingLocationToString(
        self_: *mut ISteamNetworkingUtils,
        location: *const SteamNetworkPingLocation_t,
        pszBuf: *mut ::std::os::raw::c_char,
        cchBufSize: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_ParsePingLocationString(
        self_: *mut ISteamNetworkingUtils,
        pszString: *const ::std::os::raw::c_char,
        result: *mut SteamNetworkPingLocation_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_CheckPingDataUpToDate(
        self_: *mut ISteamNetworkingUtils,
        flMaxAgeSeconds: f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetPingToDataCenter(
        self_: *mut ISteamNetworkingUtils,
        popID: SteamNetworkingPOPID,
        pViaRelayPoP: *mut SteamNetworkingPOPID,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetDirectPingToPOP(
        self_: *mut ISteamNetworkingUtils,
        popID: SteamNetworkingPOPID,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetPOPCount(
        self_: *mut ISteamNetworkingUtils,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetPOPList(
        self_: *mut ISteamNetworkingUtils,
        list: *mut SteamNetworkingPOPID,
        nListSz: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetLocalTimestamp(
        self_: *mut ISteamNetworkingUtils,
    ) -> SteamNetworkingMicroseconds;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetDebugOutputFunction(
        self_: *mut ISteamNetworkingUtils,
        eDetailLevel: ESteamNetworkingSocketsDebugOutputType,
        pfnFunc: FSteamNetworkingSocketsDebugOutput,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_IsFakeIPv4(
        self_: *mut ISteamNetworkingUtils,
        nIPv4: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetIPv4FakeIPType(
        self_: *mut ISteamNetworkingUtils,
        nIPv4: uint32,
    ) -> ESteamNetworkingFakeIPType;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetRealIdentityForFakeIP(
        self_: *mut ISteamNetworkingUtils,
        fakeIP: *const SteamNetworkingIPAddr,
        pOutRealIdentity: *mut SteamNetworkingIdentity,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueInt32(
        self_: *mut ISteamNetworkingUtils,
        eValue: ESteamNetworkingConfigValue,
        val: int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueFloat(
        self_: *mut ISteamNetworkingUtils,
        eValue: ESteamNetworkingConfigValue,
        val: f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueString(
        self_: *mut ISteamNetworkingUtils,
        eValue: ESteamNetworkingConfigValue,
        val: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValuePtr(
        self_: *mut ISteamNetworkingUtils,
        eValue: ESteamNetworkingConfigValue,
        val: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueInt32(
        self_: *mut ISteamNetworkingUtils,
        hConn: HSteamNetConnection,
        eValue: ESteamNetworkingConfigValue,
        val: int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueFloat(
        self_: *mut ISteamNetworkingUtils,
        hConn: HSteamNetConnection,
        eValue: ESteamNetworkingConfigValue,
        val: f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueString(
        self_: *mut ISteamNetworkingUtils,
        hConn: HSteamNetConnection,
        eValue: ESteamNetworkingConfigValue,
        val: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamNetConnectionStatusChanged(
        self_: *mut ISteamNetworkingUtils,
        fnCallback: FnSteamNetConnectionStatusChanged,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamNetAuthenticationStatusChanged(
        self_: *mut ISteamNetworkingUtils,
        fnCallback: FnSteamNetAuthenticationStatusChanged,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamRelayNetworkStatusChanged(
        self_: *mut ISteamNetworkingUtils,
        fnCallback: FnSteamRelayNetworkStatusChanged,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_FakeIPResult(
        self_: *mut ISteamNetworkingUtils,
        fnCallback: FnSteamNetworkingFakeIPResult,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_MessagesSessionRequest(
        self_: *mut ISteamNetworkingUtils,
        fnCallback: FnSteamNetworkingMessagesSessionRequest,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_MessagesSessionFailed(
        self_: *mut ISteamNetworkingUtils,
        fnCallback: FnSteamNetworkingMessagesSessionFailed,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetConfigValue(
        self_: *mut ISteamNetworkingUtils,
        eValue: ESteamNetworkingConfigValue,
        eScopeType: ESteamNetworkingConfigScope,
        scopeObj: isize,
        eDataType: ESteamNetworkingConfigDataType,
        pArg: *const ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetConfigValueStruct(
        self_: *mut ISteamNetworkingUtils,
        opt: *const SteamNetworkingConfigValue_t,
        eScopeType: ESteamNetworkingConfigScope,
        scopeObj: isize,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetConfigValue(
        self_: *mut ISteamNetworkingUtils,
        eValue: ESteamNetworkingConfigValue,
        eScopeType: ESteamNetworkingConfigScope,
        scopeObj: isize,
        pOutDataType: *mut ESteamNetworkingConfigDataType,
        pResult: *mut ::std::os::raw::c_void,
        cbResult: *mut usize,
    ) -> ESteamNetworkingGetConfigValueResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetConfigValueInfo(
        self_: *mut ISteamNetworkingUtils,
        eValue: ESteamNetworkingConfigValue,
        pOutDataType: *mut ESteamNetworkingConfigDataType,
        pOutScope: *mut ESteamNetworkingConfigScope,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_IterateGenericEditableConfigValues(
        self_: *mut ISteamNetworkingUtils,
        eCurrent: ESteamNetworkingConfigValue,
        bEnumerateDevVars: bool,
    ) -> ESteamNetworkingConfigValue;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_ToString(
        self_: *mut ISteamNetworkingUtils,
        addr: *const SteamNetworkingIPAddr,
        buf: *mut ::std::os::raw::c_char,
        cbBuf: uint32,
        bWithPort: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_ParseString(
        self_: *mut ISteamNetworkingUtils,
        pAddr: *mut SteamNetworkingIPAddr,
        pszStr: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_GetFakeIPType(
        self_: *mut ISteamNetworkingUtils,
        addr: *const SteamNetworkingIPAddr,
    ) -> ESteamNetworkingFakeIPType;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SteamNetworkingIdentity_ToString(
        self_: *mut ISteamNetworkingUtils,
        identity: *const SteamNetworkingIdentity,
        buf: *mut ::std::os::raw::c_char,
        cbBuf: uint32,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SteamNetworkingIdentity_ParseString(
        self_: *mut ISteamNetworkingUtils,
        pIdentity: *mut SteamNetworkingIdentity,
        pszStr: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamGameServer_v015() -> *mut ISteamGameServer;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetProduct(
        self_: *mut ISteamGameServer,
        pszProduct: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetGameDescription(
        self_: *mut ISteamGameServer,
        pszGameDescription: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetModDir(
        self_: *mut ISteamGameServer,
        pszModDir: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetDedicatedServer(
        self_: *mut ISteamGameServer,
        bDedicated: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_LogOn(
        self_: *mut ISteamGameServer,
        pszToken: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_LogOnAnonymous(self_: *mut ISteamGameServer);
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_LogOff(self_: *mut ISteamGameServer);
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_BLoggedOn(self_: *mut ISteamGameServer) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_BSecure(self_: *mut ISteamGameServer) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_GetSteamID(self_: *mut ISteamGameServer) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_WasRestartRequested(self_: *mut ISteamGameServer) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetMaxPlayerCount(
        self_: *mut ISteamGameServer,
        cPlayersMax: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetBotPlayerCount(
        self_: *mut ISteamGameServer,
        cBotplayers: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetServerName(
        self_: *mut ISteamGameServer,
        pszServerName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetMapName(
        self_: *mut ISteamGameServer,
        pszMapName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetPasswordProtected(
        self_: *mut ISteamGameServer,
        bPasswordProtected: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetSpectatorPort(
        self_: *mut ISteamGameServer,
        unSpectatorPort: uint16,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetSpectatorServerName(
        self_: *mut ISteamGameServer,
        pszSpectatorServerName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_ClearAllKeyValues(self_: *mut ISteamGameServer);
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetKeyValue(
        self_: *mut ISteamGameServer,
        pKey: *const ::std::os::raw::c_char,
        pValue: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetGameTags(
        self_: *mut ISteamGameServer,
        pchGameTags: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetGameData(
        self_: *mut ISteamGameServer,
        pchGameData: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetRegion(
        self_: *mut ISteamGameServer,
        pszRegion: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetAdvertiseServerActive(
        self_: *mut ISteamGameServer,
        bActive: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_GetAuthSessionTicket(
        self_: *mut ISteamGameServer,
        pTicket: *mut ::std::os::raw::c_void,
        cbMaxTicket: ::std::os::raw::c_int,
        pcbTicket: *mut uint32,
        pSnid: *const SteamNetworkingIdentity,
    ) -> HAuthTicket;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_BeginAuthSession(
        self_: *mut ISteamGameServer,
        pAuthTicket: *const ::std::os::raw::c_void,
        cbAuthTicket: ::std::os::raw::c_int,
        steamID: uint64_steamid,
    ) -> EBeginAuthSessionResult;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_EndAuthSession(
        self_: *mut ISteamGameServer,
        steamID: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_CancelAuthTicket(
        self_: *mut ISteamGameServer,
        hAuthTicket: HAuthTicket,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_UserHasLicenseForApp(
        self_: *mut ISteamGameServer,
        steamID: uint64_steamid,
        appID: AppId_t,
    ) -> EUserHasLicenseForAppResult;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_RequestUserGroupStatus(
        self_: *mut ISteamGameServer,
        steamIDUser: uint64_steamid,
        steamIDGroup: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_GetGameplayStats(self_: *mut ISteamGameServer);
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_GetServerReputation(
        self_: *mut ISteamGameServer,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_GetPublicIP(self_: *mut ISteamGameServer) -> SteamIPAddress_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_HandleIncomingPacket(
        self_: *mut ISteamGameServer,
        pData: *const ::std::os::raw::c_void,
        cbData: ::std::os::raw::c_int,
        srcIP: uint32,
        srcPort: uint16,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_GetNextOutgoingPacket(
        self_: *mut ISteamGameServer,
        pOut: *mut ::std::os::raw::c_void,
        cbMaxOut: ::std::os::raw::c_int,
        pNetAdr: *mut uint32,
        pPort: *mut uint16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_AssociateWithClan(
        self_: *mut ISteamGameServer,
        steamIDClan: uint64_steamid,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_ComputeNewPlayerCompatibility(
        self_: *mut ISteamGameServer,
        steamIDNewPlayer: uint64_steamid,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SendUserConnectAndAuthenticate_DEPRECATED(
        self_: *mut ISteamGameServer,
        unIPClient: uint32,
        pvAuthBlob: *const ::std::os::raw::c_void,
        cubAuthBlobSize: uint32,
        pSteamIDUser: *mut CSteamID,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_CreateUnauthenticatedUserConnection(
        self_: *mut ISteamGameServer,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SendUserDisconnect_DEPRECATED(
        self_: *mut ISteamGameServer,
        steamIDUser: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_BUpdateUserData(
        self_: *mut ISteamGameServer,
        steamIDUser: uint64_steamid,
        pchPlayerName: *const ::std::os::raw::c_char,
        uScore: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamGameServerStats_v001() -> *mut ISteamGameServerStats;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServerStats_RequestUserStats(
        self_: *mut ISteamGameServerStats,
        steamIDUser: uint64_steamid,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServerStats_GetUserStatInt32(
        self_: *mut ISteamGameServerStats,
        steamIDUser: uint64_steamid,
        pchName: *const ::std::os::raw::c_char,
        pData: *mut int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServerStats_GetUserStatFloat(
        self_: *mut ISteamGameServerStats,
        steamIDUser: uint64_steamid,
        pchName: *const ::std::os::raw::c_char,
        pData: *mut f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServerStats_GetUserAchievement(
        self_: *mut ISteamGameServerStats,
        steamIDUser: uint64_steamid,
        pchName: *const ::std::os::raw::c_char,
        pbAchieved: *mut bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServerStats_SetUserStatInt32(
        self_: *mut ISteamGameServerStats,
        steamIDUser: uint64_steamid,
        pchName: *const ::std::os::raw::c_char,
        nData: int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServerStats_SetUserStatFloat(
        self_: *mut ISteamGameServerStats,
        steamIDUser: uint64_steamid,
        pchName: *const ::std::os::raw::c_char,
        fData: f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServerStats_UpdateUserAvgRateStat(
        self_: *mut ISteamGameServerStats,
        steamIDUser: uint64_steamid,
        pchName: *const ::std::os::raw::c_char,
        flCountThisSession: f32,
        dSessionLength: f64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServerStats_SetUserAchievement(
        self_: *mut ISteamGameServerStats,
        steamIDUser: uint64_steamid,
        pchName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServerStats_ClearUserAchievement(
        self_: *mut ISteamGameServerStats,
        steamIDUser: uint64_steamid,
        pchName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServerStats_StoreUserStats(
        self_: *mut ISteamGameServerStats,
        steamIDUser: uint64_steamid,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingFakeUDPPort_DestroyFakeUDPPort(
        self_: *mut ISteamNetworkingFakeUDPPort,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingFakeUDPPort_SendMessageToFakeIP(
        self_: *mut ISteamNetworkingFakeUDPPort,
        remoteAddress: *const SteamNetworkingIPAddr,
        pData: *const ::std::os::raw::c_void,
        cbData: uint32,
        nSendFlags: ::std::os::raw::c_int,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingFakeUDPPort_ReceiveMessages(
        self_: *mut ISteamNetworkingFakeUDPPort,
        ppOutMessages: *mut *mut SteamNetworkingMessage_t,
        nMaxMessages: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingFakeUDPPort_ScheduleCleanup(
        self_: *mut ISteamNetworkingFakeUDPPort,
        remoteAddress: *const SteamNetworkingIPAddr,
    );
}
extern "C" {
    pub fn SteamAPI_SteamIPAddress_t_IsSet(self_: *mut SteamIPAddress_t) -> bool;
}
extern "C" {
    pub fn SteamAPI_MatchMakingKeyValuePair_t_Construct(self_: *mut MatchMakingKeyValuePair_t);
}
extern "C" {
    pub fn SteamAPI_servernetadr_t_Construct(self_: *mut servernetadr_t);
}
extern "C" {
    pub fn SteamAPI_servernetadr_t_Init(
        self_: *mut servernetadr_t,
        ip: ::std::os::raw::c_uint,
        usQueryPort: uint16,
        usConnectionPort: uint16,
    );
}
extern "C" {
    pub fn SteamAPI_servernetadr_t_GetQueryPort(self_: *mut servernetadr_t) -> uint16;
}
extern "C" {
    pub fn SteamAPI_servernetadr_t_SetQueryPort(self_: *mut servernetadr_t, usPort: uint16);
}
extern "C" {
    pub fn SteamAPI_servernetadr_t_GetConnectionPort(self_: *mut servernetadr_t) -> uint16;
}
extern "C" {
    pub fn SteamAPI_servernetadr_t_SetConnectionPort(self_: *mut servernetadr_t, usPort: uint16);
}
extern "C" {
    pub fn SteamAPI_servernetadr_t_GetIP(self_: *mut servernetadr_t) -> uint32;
}
extern "C" {
    pub fn SteamAPI_servernetadr_t_SetIP(self_: *mut servernetadr_t, unIP: uint32);
}
extern "C" {
    pub fn SteamAPI_servernetadr_t_GetConnectionAddressString(
        self_: *mut servernetadr_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_servernetadr_t_GetQueryAddressString(
        self_: *mut servernetadr_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_servernetadr_t_IsLessThan(
        self_: *mut servernetadr_t,
        netadr: *const servernetadr_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_servernetadr_t_Assign(self_: *mut servernetadr_t, that: *const servernetadr_t);
}
extern "C" {
    pub fn SteamAPI_gameserveritem_t_Construct(self_: *mut gameserveritem_t);
}
extern "C" {
    pub fn SteamAPI_gameserveritem_t_GetName(
        self_: *mut gameserveritem_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_gameserveritem_t_SetName(
        self_: *mut gameserveritem_t,
        pName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_Clear(self_: *mut SteamNetworkingIPAddr);
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_IsIPv6AllZeros(self_: *mut SteamNetworkingIPAddr)
        -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_SetIPv6(
        self_: *mut SteamNetworkingIPAddr,
        ipv6: *const uint8,
        nPort: uint16,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_SetIPv4(
        self_: *mut SteamNetworkingIPAddr,
        nIP: uint32,
        nPort: uint16,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_IsIPv4(self_: *mut SteamNetworkingIPAddr) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_GetIPv4(self_: *mut SteamNetworkingIPAddr) -> uint32;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_SetIPv6LocalHost(
        self_: *mut SteamNetworkingIPAddr,
        nPort: uint16,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_IsLocalHost(self_: *mut SteamNetworkingIPAddr) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_ToString(
        self_: *mut SteamNetworkingIPAddr,
        buf: *mut ::std::os::raw::c_char,
        cbBuf: uint32,
        bWithPort: bool,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_ParseString(
        self_: *mut SteamNetworkingIPAddr,
        pszStr: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_IsEqualTo(
        self_: *mut SteamNetworkingIPAddr,
        x: *const SteamNetworkingIPAddr,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_GetFakeIPType(
        self_: *mut SteamNetworkingIPAddr,
    ) -> ESteamNetworkingFakeIPType;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_IsFakeIP(self_: *mut SteamNetworkingIPAddr) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_Clear(self_: *mut SteamNetworkingIdentity);
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_IsInvalid(self_: *mut SteamNetworkingIdentity) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_SetSteamID(
        self_: *mut SteamNetworkingIdentity,
        steamID: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_GetSteamID(
        self_: *mut SteamNetworkingIdentity,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_SetSteamID64(
        self_: *mut SteamNetworkingIdentity,
        steamID: uint64,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_GetSteamID64(
        self_: *mut SteamNetworkingIdentity,
    ) -> uint64;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_SetXboxPairwiseID(
        self_: *mut SteamNetworkingIdentity,
        pszString: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_GetXboxPairwiseID(
        self_: *mut SteamNetworkingIdentity,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_SetPSNID(
        self_: *mut SteamNetworkingIdentity,
        id: uint64,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_GetPSNID(self_: *mut SteamNetworkingIdentity)
        -> uint64;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_SetIPAddr(
        self_: *mut SteamNetworkingIdentity,
        addr: *const SteamNetworkingIPAddr,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_GetIPAddr(
        self_: *mut SteamNetworkingIdentity,
    ) -> *const SteamNetworkingIPAddr;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_SetIPv4Addr(
        self_: *mut SteamNetworkingIdentity,
        nIPv4: uint32,
        nPort: uint16,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_GetIPv4(self_: *mut SteamNetworkingIdentity) -> uint32;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_GetFakeIPType(
        self_: *mut SteamNetworkingIdentity,
    ) -> ESteamNetworkingFakeIPType;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_IsFakeIP(self_: *mut SteamNetworkingIdentity) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_SetLocalHost(self_: *mut SteamNetworkingIdentity);
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_IsLocalHost(
        self_: *mut SteamNetworkingIdentity,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_SetGenericString(
        self_: *mut SteamNetworkingIdentity,
        pszString: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_GetGenericString(
        self_: *mut SteamNetworkingIdentity,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_SetGenericBytes(
        self_: *mut SteamNetworkingIdentity,
        data: *const ::std::os::raw::c_void,
        cbLen: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_GetGenericBytes(
        self_: *mut SteamNetworkingIdentity,
        cbLen: *mut ::std::os::raw::c_int,
    ) -> *const uint8;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_IsEqualTo(
        self_: *mut SteamNetworkingIdentity,
        x: *const SteamNetworkingIdentity,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_ToString(
        self_: *mut SteamNetworkingIdentity,
        buf: *mut ::std::os::raw::c_char,
        cbBuf: uint32,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_ParseString(
        self_: *mut SteamNetworkingIdentity,
        pszStr: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingMessage_t_Release(self_: *mut SteamNetworkingMessage_t);
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingConfigValue_t_SetInt32(
        self_: *mut SteamNetworkingConfigValue_t,
        eVal: ESteamNetworkingConfigValue,
        data: i32,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingConfigValue_t_SetInt64(
        self_: *mut SteamNetworkingConfigValue_t,
        eVal: ESteamNetworkingConfigValue,
        data: i64,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingConfigValue_t_SetFloat(
        self_: *mut SteamNetworkingConfigValue_t,
        eVal: ESteamNetworkingConfigValue,
        data: f32,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingConfigValue_t_SetPtr(
        self_: *mut SteamNetworkingConfigValue_t,
        eVal: ESteamNetworkingConfigValue,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingConfigValue_t_SetString(
        self_: *mut SteamNetworkingConfigValue_t,
        eVal: ESteamNetworkingConfigValue,
        data: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_SteamDatagramHostedAddress_Clear(self_: *mut SteamDatagramHostedAddress);
}
extern "C" {
    pub fn SteamAPI_SteamDatagramHostedAddress_GetPopID(
        self_: *mut SteamDatagramHostedAddress,
    ) -> SteamNetworkingPOPID;
}
extern "C" {
    pub fn SteamAPI_SteamDatagramHostedAddress_SetDevAddress(
        self_: *mut SteamDatagramHostedAddress,
        nIP: uint32,
        nPort: uint16,
        popid: SteamNetworkingPOPID,
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EServerMode {
    eServerModeInvalid = 0,
    eServerModeNoAuthentication = 1,
    eServerModeAuthentication = 2,
    eServerModeAuthenticationAndSecure = 3,
}
#[doc = " Pass to SteamGameServer_Init to indicate that the same UDP port will be used for game traffic\n UDP queries for server browser pings and LAN discovery.  In this case, Steam will not open up a\n socket to handle server browser queries, and you must use ISteamGameServer::HandleIncomingPacket\n and ISteamGameServer::GetNextOutgoingPacket to handle packets related to server discovery on your socket."]
pub const STEAMGAMESERVER_QUERY_PORT_SHARED: uint16 = 65535;
pub const MASTERSERVERUPDATERPORT_USEGAMESOCKETSHARE: uint16 = 65535;
extern "C" {
    pub fn SteamGameServer_Shutdown();
}
extern "C" {
    pub fn SteamGameServer_BSecure() -> bool;
}
extern "C" {
    pub fn SteamGameServer_GetSteamID() -> uint64;
}
extern "C" {
    pub fn SteamInternal_GameServer_Init_V2(
        unIP: uint32,
        usGamePort: uint16,
        usQueryPort: uint16,
        eServerMode: EServerMode,
        pchVersionString: *const ::std::os::raw::c_char,
        pszInternalCheckInterfaceVersions: *const ::std::os::raw::c_char,
        pOutErrMsg: *mut SteamErrMsg,
    ) -> ESteamAPIInitResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
